# Warning: Keep host-specific declarations near the beginning of the file.{{{
#
#    > Since  the  first obtained  value  for  each  parameter is  used,  more
#    > **host-specific declarations should be given near the beginning of the file**, and
#    > **general defaults at the end**.
#
# Source: `man 5 ssh_config`
#
#    > Any configuration value is only changed the first time it is set.
#    > Thus, **host-specific definitions should be at the beginning of the**
#    > **configuration file, and defaults at the end**.
#
# Source: `/etc/ssh/ssh_config`
#
# ---
#
# For example, don't write this:
#
#     Host *
#         Port 123
#
#     Host myserver
#         Port 456
#
# But this:
#
#     Host myserver
#         Port 456
#
#     Host *
#         Port 123
#}}}
# Warning: Patterns arguments after `Host` and `Match` keywords are not matched against what you might think.{{{
#
# They're  matched   against  the   destination  *exactly*   as  typed   on  the
# *command-line*.
#
# For example, suppose  your local server listens on port  2222, and your client
# config contains this:
#
#     Host 127.0.0.1
#         Port 2222
#         ^-------^
#
# That command won't work:
#
#     $ ssh localhost
#     ssh: connect to host localhost port 22: Connection refused
#                                    ^-----^
#
# `Port 2222`  was  not applied;  the  `Host`  block  was skipped,  even  though
# `localhost` has the IP `127.0.0.1`  (as per `/etc/hosts`).  That's because, on
# the command-line,  you typed `localhost`,  and `localhost` does not  match the
# pattern `127.0.0.1`.
#
# The  comparison is  performed  *before*  any kind  of  resolution  (be it  via
# `/etc/hosts`, `/etc/resolv.conf`, a DNS query, ...).
#
# For `$ ssh localhost` to work, you would need this config:
#
#                    v-------v
#     Host 127.0.0.1 localhost
#         Port 2222
#}}}
# Pitfall: I'm assigning multiple values to a given keyword.  `ssh(1)` complains about the configuration!{{{
#
# Make sure you used the correct syntax to separate the values.
#
# For example, `Host` accepts multiple values, separated by a space:
#
#     Host a.some.domain b.some.domain
#                       ^
#
# But `Address` expects comma-separated values:
#
#     Address 192.0.2.0/25, 198.51.100.0/24
#                         ^
#
# ---
#
# In a  *server* config file,  `HostKey` and  `Port` can appear  multiple times,
# with different values:
#
#     HostKey /etc/ssh/ssh_host_rsa_key
#     HostKey /etc/ssh/ssh_host_ecdsa_key
#     HostKey /etc/ssh/ssh_host_ed25519_key
#
#     Port 123
#     Port 456
#     Port 789
#}}}

# `scp(1)` and `sftp(1)` should be configured here as much as possible.{{{
#
# SCP and  SFTP are designed to  replace RCP and  FTP.  That's why the  flags of
# their CLI programs are more consistent with `rcp(1)`/`ftp(1)` rather than with
# `ssh(1)`.  For  example, to change  the port they use,  you need to  pass them
# `-P`, instead of `-p` (as for `ssh(1)`).  This is confusing; fortunately, they
# all read `ssh_config`, so put as much of your configuration over here:
#
#     ✘
#     $ scp -P 123 file john@some.domain:
#           ^----^      ^---^
#
#     ✔
#     $ cat /etc/ssh/ssh_config
#     Host some.domain
#         Port 123
#         ^------^
#         User john
#         ^-------^
#
#     $ scp file some.domain:
#}}}

# The local host can have several names/IPs; see `/etc/hosts`.
Host localhost 127.0.0.1 127.0.1.1 ::1 debian ubuntu *.home.arpa
    # Allow the connection to a server with a changed public key to proceed.{{{
    #
    # Connection to a server whose key  has changed is never allowed, unless the
    # option is set to `no`.
    #
    # If set to  `yes`, the connection is  allowed if, and only if,  the key has
    # already been cached (i.e. added to `known_hosts`).
    #}}}
    # This option also controls whether a new server key is automatically cached:{{{
    #
    #    - `yes`: never
    #    - `no` or `accept-new`: always
    #    - `ask` (the default): only after the user's acceptance
    #}}}
    StrictHostKeyChecking no

    # A side effect of `StrictHostKeyChecking no` is  that a new server key will
    # be cached.  But we don't want it to be cached here.
    UserKnownHostsFile /dev/null

    # Don't print a warning either.{{{
    #
    #     Warning: Permanently added '127.0.0.1' (ECDSA) to the list of known hosts.
    #
    # ---
    #
    # Possible values are:
    #
    #     QUIET
    #     FATAL
    #     ERROR
    #     INFO
    #     VERBOSE
    #     DEBUG
    #     DEBUG1
    #     DEBUG2
    #     DEBUG3
    #
    # The default is `INFO`.
    #}}}
    LogLevel QUIET

# global defaults
# Don't write them outside of a `Host` block.{{{
#
# You would lose the ability to write a block before:
#
#     ✘
#     Host 192.168.*
#         Port 456
#
#     Port 123
#
# Here, `Port 123`  is actually part of  the `Host` block (contrary  to what the
# misleading indentation suggests).   So `Port 123` would never  be applied (not
# even on the local network).
#
# Also, it  might give you  the wrong impression  that this could  work (because
# something similar to that can work in the server config file):
#
#     ✘
#     Port 123
#     Host 192.168.*
#         Port 456
#
# It doesn't.   Remember that the first  match wins.  `Port 456` would  never be
# applied, because `Port 123` matched before.
#
# You can check yourself like this:
#
#     $ tee /tmp/ssh_config <<'EOF'
#         Port 123
#         Host 192.168.*
#             Port 456
#     EOF
#
#     $ ssh -G -F /tmp/ssh_config 192.168.1.2 | grep '^port'
#     port 123
#
# ---
#
# Also, that's what the system-wide config does (see `/etc/ssh/ssh_config`).
# All global defaults are inside a `Host *` block over there.
#}}}
Host *
    # When a user authentication key is loaded from a file, automatically add it to `ssh-agent(1)`.{{{
    #
    # That is, if you're  prompted for a passphrase when trying  to connect to a
    # server, and  you provide it,  the private key  and its passphrase  will be
    # automatically added to the agent, as if you had run `$ ssh-add <file>`.
    #
    # This is convenient in case you forget to use `ssh-add(1)`, and you connect
    # multiple times with the same key.
    #}}}
    # For now, I prefer to keep the default value `no`.{{{
    #
    # So as  to get better control  over what is  loaded in the agent  (it seems
    # more secure).
    #}}}
    #     AddKeysToAgent yes

    # Agent forwarding is useful if you connect to an intermediate server, and use a key to authenticate.{{{
    #
    #     A (local) → B (intermediate) → C (final)
    #
    # Since C will  not send its authentication request to  you directly, but to
    # B, you would need to copy your private  key from A to B, which is terrible
    # security practice (it should be on as  few hosts as possible, and not on a
    # server).  Instead, you can forward  the authentication request back from B
    # to A.
    #}}}
    # But it's an insecure feature.{{{
    #
    # Anyone who has root access on  the intermediate server can access your SSH
    # agent  socket; which  means they  can use  your private  key without  even
    # having to give a  passphrase.  In turn, this means they  can assume any of
    # your identities currently running into  the agent in order to authenticate
    # to your known remote servers.
    #}}}
    # Only enable it  on an intermediate server where you're  the only user with
    # root access.   A safer alternative  might be  to use a  **jump host** (see
    # `man ssh /^\s*-J`).
    ForwardAgent no

    # When a key is accepted, do *not* hash its host name or IP address before adding it into the cache.{{{
    #
    # Debian sets it to `yes` in `/etc/ssh/ssh_config`; but it's not set upstream:
    #
    #    > HashKnownHosts
    #    >         [...]
    #    >         The default is no.
    #
    # Source: `man 5 ssh_config`
    #
    # Besides, it  creates too much noise,  because each name/IP with  which you
    # want to connect to  a host needs to be hashed separately  on its own line.
    # For example, you go from this line in a non-hashed file:
    #
    #     name.my.domain,name,n.my.domain,n,1.2.3.4,1.2.4.4 ❬key_type❭ ❬key❭
    #
    # To this group of mostly duplicate lines in a hashed one:
    #
    #                             v--------------v
    #     ❬hashed_name.my.domain❭ ❬key_type❭ ❬key❭
    #     ❬hashed_name❭ ❬key_type❭ ❬key❭
    #     ❬hashed_n.my.domain❭ ❬key_type❭ ❬key❭
    #     ❬hashed_n❭ ❬key_type❭ ❬key❭
    #     ❬hashed_1.2.3.4❭ ❬key_type❭ ❬key❭
    #     ❬hashed_1.2.4.4❭ ❬key_type❭ ❬key❭
    #                      ^--------------^
    #                      repeated on each line
    #
    # In particular, that  happens if you set an alias  in `/etc/hosts`, because
    # then `ssh(1)` wants  to write `alias,IP` in the host  name field, which it
    # has to hash on two lines.
    #
    # Also, it  makes the  file harder  to read and  maintain, because  it often
    # makes the host  name field longer, and  you no longer know  what each line
    # refers to.  At best  you can try and guess whether a given  host is in the
    # file (and on which line) with this command:
    #
    #     $ ssh-keygen -F <host> -f ~/.ssh/known_hosts
    #
    # But that's cumbersome to use.
    #
    # And, it causes `~/.ssh/known_hosts.old` to  be created every time the file
    # is hashed.
    #
    # Finally, it  might break  facilities such as  tab-completion that  rely on
    # being able to read unhashed host names.
    #
    # ---
    #
    # Setting this keyword  to `yes` is meant to prevent  an intruder who breaks
    # into your desktop from  getting a list of host names  to target for future
    # attacks.   Also, it  can simply  prevent  sysadmins and  other users  from
    # snooping on you.
    #
    # ---
    #
    # Setting this keyword to `yes` only works  on host names of keys which will
    # be  added  in the  future.   Not  on host  names  in  plain text  of  keys
    # which  are already  present  in the  file.   For those,  you  need to  run
    # `$ ssh-keygen -H`.
    #}}}
    HashKnownHosts no

    # The public key authentication method is  the most commonly used because it
    # offers the best balance between security and convenience.
    PubkeyAuthentication yes
    # Do *not* disable password-based authentication globally.{{{
    #
    #     ✘
    #     PasswordAuthentication no
    #     ChallengeResponseAuthentication no
    #
    # Some servers might not support  public key authentication.  Or they might,
    # but you haven't yet installed your `authorized_keys` on them.
    #
    # You *can* disable password-based  authentication in your *server*'s config
    # though; but  only after making sure  you can connect from  a remote client
    # and as a user who can become root to administer the server.
    #}}}

    # What's the difference between TCP and SSH keepalives?{{{
    #
    # With TCP keepalives,  it takes a long  time for the client  to notice when
    # the connection dies:
    #
    #    > This option only uses TCP keepalives (as opposed to using ssh level
    #    > keepalives), so takes a long time to notice when the connection dies.
    #
    # Source: `man 5 ssh_config /DESCRIPTION/;/TCPKeepAlive`
    #
    # I *guess* it means that TCP keepalives are sent much less frequently.
    #
    # Also (from the "SSH Mastery" book):
    #
    #    > An SSH keepalive is also more likely to continue holding a session
    #    > open even through a lengthy router reboot.
    #
    # I think it means the network can become sluggish (e.g. because of a router
    # taking a long time to reboot)  causing the client and server to experience
    # slow response  times.  And if  that happens,  TCP keepalives might  not be
    # sent quick enough  to maintain the connection alive,  while SSH keepalives
    # can be sent faster.  For example, suppose that:
    #
    #    - a firewall or an ISP terminates TCP connections which have been idle
    #      for the last 3 minutes
    #
    #    - TCP keepalives are sent every 2 minutes
    #
    #    - the SSH session has been idle since the client sent its latest TCP
    #      keepalive
    #
    #    - when the client sends its next TCP keepalive, an intermediate router
    #      has just started rebooting; it will take 1 minute for the router to
    #      be up again
    #
    # In that  scenario, we might  need to  wait more than  3 minutes for  a TCP
    # keepalive to  reach the server, which  is not quick enough  to prevent the
    # firewall/ISP from terminating  the connection.  OTOH, if  we configure SSH
    # keepalives to be sent every minute, they should always reach the server in
    # less than 3 minutes, which is quick enough.
    #
    # In any  case, SSH keepalives are  more configurable.  You can  specify how
    # much time  should `ssh(1)` wait before  sending a new message,  as well as
    # how many unanswered messages are allowed before disconnecting.
    #}}}
    # Send occasional TCP keepalives back and forth just to remind everyone that connections are still used.{{{
    #
    # Rationale: Most  firewalls,  and  some ISPs,  deliberately  terminate  TCP
    # connections left idle  for a period of time.  This  can be problematic for
    # port forwardings.
    #}}}
    TCPKeepAlive yes
    # If the server did not send any data recently, send it a "server alive" message to request a response.{{{
    #
    # Rationale: SSH sessions left  idle will eventually be  disconnected by the
    # server, the client, or some network device in between.
    #
    # ---
    #
    # `90s` is based on what we read in the "SSH Mastery" book:
    #
    #    > How often you need to send a TCP keepalive depends on your operating
    #    > system’s TCP stack, but it should never be longer than two minutes.
    #    > [...]
    #    > In most cases, sending a TCP keepalive every 90 seconds suffices to
    #    > hold the connection open.
    #
    # The time value can be expressed in other units.
    # See: `man 5 sshd_config /TIME FORMATS`.
    #}}}
    ServerAliveInterval 90s
    # Disconnect from the server if it was sent 6 server alive messages, but did not respond back.
    # Warning: This might terminate your sessions unnecessarily.{{{
    #
    # If your  ISP has a temporary  problem in the  middle of the night  and the
    # keepalive segments cannot cross the network for a few minutes, your client
    # will  terminate the  connection.  Try  to find  the right  value for  your
    # network.  For now, we settle on `6`;  this means that our client will only
    # disconnect after 9 minutes (`6 * 90s`) without the server answering.
    #
    # If necessary use a high value:
    #
    #    > If you want to keep your connection alive no matter what, cranking
    #    > AliveCountMax to high values helps, especially when you’re behind a
    #    > cheap Network Address Translation device such as many home routers.
    #
    # Source: "SSH Mastery" book.
    #}}}
    ServerAliveCountMax 6

    # Verify the remote key by looking up the SSHFP resource record for the server's domain name.{{{
    #
    # This only  works if  the server's key  has been stored  as the  DNS record
    # SSHFP.
    #
    # By setting the option to "yes", the client will implicitly trust keys that
    # match a secure fingerprint from DNS; no question will be asked.
    #}}}
    # Warning: Slows down the connection if DNS  fails (because you need to wait
    # for a full DNS timeout).
    VerifyHostKeyDNS yes
