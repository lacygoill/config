#!/bin/bash

readonly SCRIPT="${0##*/}"

if (( $# == 0 )); then
  tee >&2 <<EOF
Usage:
  \$ $SCRIPT status
  \$ $SCRIPT add /path/to/file
  \$ $SCRIPT commit --message='my message'
  \$ $SCRIPT push

  \$ $SCRIPT diff
  \$ $SCRIPT rm /path/to/file

  \$ $SCRIPT grep pattern

  \$ $SCRIPT jump grep pattern
  \$ $SCRIPT jump diff
  \$ $SCRIPT jump merge
  \$ $SCRIPT jump ws

  \$ $SCRIPT log

  \$ $SCRIPT ls-files
  \$ $SCRIPT ls-files --filetype=bash
EOF
  exit 1
fi

readonly -a GIT_OPTIONS=( --git-dir="$HOME/.cfg/" --work-tree="$HOME" )
# No need to specify `--line-number` and `--column`.{{{
#
# Those are  only useful  for Vim.  But  for Vim, we  should use  `git-jump` (in
# `grep` mode) which already specifies those options.
#}}}
readonly -a GREP_OPTIONS=( --ignore-case --perl-regexp )
readonly SUBCMD="$1"
shift

# We need to `cd` into our `$HOME` for some subcommands.
# But  not   all;  for  example,   you  don't  want   to  change  the   CWD  for
# `$ config add relative/path`.
if [[ "$SUBCMD" =~ ^(grep|jump|ls-files|untracked)$ ]]; then
  cd || exit 1
fi

function list_files_with_given_filetype {
  if ! [[ -e "$CONFIG_FILETYPES" ]]; then
    printf '"%s" does not exist; run ":ConfigGrep -filetype=c pattern" from Vim to re-generate the cache.\n' "$CONFIG_FILETYPES"
    exit 1
  fi
  local filetype="$1"
  jq --raw-output ".$filetype | values[]" "$CONFIG_FILETYPES"
}

case $SUBCMD in
add|rm|commit|diff|status)
  # Make sure not to add a file with a newline in its path.
  # Such a file can cause too many issues down the line.{{{
  #
  # For example, if a file name can  contain a newline, then we should implement
  # a `-z`  option for `$ config ls-files` (so  that its output can  be reliably
  # iterated over by another command).
  #}}}
  if [[ "$PWD" == *$'\n'* ]]; then
    printf 'cannot process a file in a directory with a newline in its path: %q\n' "$PWD" >&2
    exit 1
  fi
  # `$ config add` can be passed a simple file name, or a relative path.
  for relpath in "$@"; do
    if [[ "$relpath" == *$'\n'* ]]; then
      printf 'cannot process a file with a newline in its path: %q\n' "$relpath" >&2
      exit 1
    fi
  done

  # to suppress:
  #     empty string is not a valid pathspec. please use . instead if you meant to match all paths
  if (( $# == 0 )); then
    declare -a cmd=( git "${GIT_OPTIONS[@]}" "$SUBCMD" )
  else
    declare -a cmd=( git "${GIT_OPTIONS[@]}" "$SUBCMD" "$@" )
  fi

  if [[ "$SUBCMD" == 'status' ]]; then
    cmd+=(--short)
  elif [[ "$SUBCMD" == 'add' ]] || [[ "$SUBCMD" == 'rm' ]]; then
    # invalidate cache
    rm --force "${CONFIG_FILETYPES:=}"
  fi

  "${cmd[@]}"
;;

grep)
  # Some file creates too much noise!{{{
  #
  # Does  it contain  non-reproducible data?   If it  does not  (e.g. it  can be
  # generated by  a script or  downloaded from a  website), remove it  from your
  # config:
  #
  #     $ config rm --cached "$HOME/path/to/file"
  #
  # Then, back it up in `~/bin/backup`.
  #}}}
  # Do *not* prepend `--` before `"$@"`.{{{
  #
  # At runtime, we might want to pass some options to `git-grep(1)`:
  #
  #     $ config grep -e function --and -e class
  #                   ^^          ^---^ ^^
  #
  # With `--`, they  would lose their special meaning, and  be wrongly parsed as
  # filenames.
  #}}}
  git "${GIT_OPTIONS[@]}" grep "${GREP_OPTIONS[@]}" "$@"
;;

jump)
  mode="$1"
  shift

  # Run `$ git jump` to see the modes supported by `~/.local/bin/git-jump`.
  case $mode in
  grep)
    git "${GIT_OPTIONS[@]}" jump grep "${GREP_OPTIONS[@]}" "$@"
  ;;

  diff|merge|ws)
    git "${GIT_OPTIONS[@]}" jump "$mode" "$@"
  ;;

  *)
    git jump "$@" 2>&1 | sed 's/git jump/config jump/g' >&2
    exit 1
  ;;
  esac
;;

log)
  git "${GIT_OPTIONS[@]}" log
;;

ls-files)
  case $1 in
  --filetype)
    shift
    #     $ config ls-files --filetype bash
    #                                 ^
    filetype="$1"
    list_files_with_given_filetype "$filetype"
  ;;

  --filetype=*)
    #     $ config ls-files --filetype=bash
    #                                 ^
    filetype="${1#*=}"
    list_files_with_given_filetype "$filetype"
  ;;

  ?*)
    printf 'invalid option: %s\n' "$1" >&2
    exit 1
  ;;

  *)
    #     $ config ls-files
    git "${GIT_OPTIONS[@]}" ls-files -z \
      | while IFS= read -r -d '' file; do
        # We filter out non-existing files.{{{
        #
        # That might happen if we've removed  a config file, but not updated our
        # Git repo yet (with `add --update`).
        #}}}
        # Don't filter out symlinks.{{{
        #
        # For   example,   we   do   want  to   see   systemd   symlinks   under
        # `~/.config/systemd/user/`.
        #}}}
        # `[[ -L "$file" ]]` is useful for a symlink whose target is not a file.{{{
        #
        # Most file  operators, like `-f`, operate  on the target of  a symlink.
        # `-L` operates on the symlink itself.
        #}}}
        if [[ -f "$file" ]] || [[ -L "$file" ]]; then
          # We prepend `$HOME` to get absolute  paths.{{{
          #
          # It's handy  to set the Vim  quickfix list with valid  entries, while
          # our shell CWD is not `$HOME`:
          #
          #     $ cd /tmp
          #     $ vim -q <(config grep 'test')
          #}}}
          echo "$HOME/$file"
        fi
      done
  ;;
  esac
;;

push)
  # Make sure all our Vim plugins are version-controlled.
  # But ignore a plugin with a `.git` directory.{{{
  #
  # First,  you probably  made a  mistake;  such a  plugin should  not be  under
  # `mine/` (only under `vendor/`).
  #
  # Second, it gives a warning:
  #
  #     warning: adding embedded git repository: .vim/pack/mine/opt/awk
  #     hint: You've added another git repository inside your current repository.
  #     hint: Clones of the outer repository will not contain the contents of
  #     hint: the embedded repository and will not know how to obtain it.
  #     hint: If you meant to add a submodule, use:
  #     hint:
  #     hint:   git submodule add <url> .vim/pack/mine/opt/awk
  #     hint:
  #     hint: If you added this path by mistake, you can remove it from the
  #     hint: index with:
  #     hint:
  #     hint:   git rm --cached .vim/pack/mine/opt/awk
  #     hint:
  #     hint: See "git help submodule" for more information.
  #
  # If that happens, run this:
  #
  #     $ git --git-dir=$HOME/.cfg/ --work-tree=$HOME rm --cached --force ~/.vim/pack/mine/opt/<plugin>
  #                                                      ^--------------^
  #                                                      yes, both options are necessary
  #}}}
  for plugin in "$HOME/.vim/pack/mine/opt/"*; do
    if [[ -e "$plugin/.git" ]]; then
      printf '%s: "%s" is ignored because it contains a .git/ directory\n' "$SCRIPT" "$plugin" >&2
    else
      git "${GIT_OPTIONS[@]}" add "$plugin"
    fi
  done

  # `--update` updates all tracked files in the entire working tree.{{{
  #
  # This removes  as well as modifies  index entries to match  the working tree,
  # but adds  no new files.   It's easier and  more reliable to  use `--update`,
  # than to manually add every modified file, and remove every deleted file:
  #
  #     $ git add --update
  #   â‡”
  #     $ git add file1 ... && git rm file2 ...
  #}}}
  if ! git "${GIT_OPTIONS[@]}" add --update; then
    exit 1
  fi
  if ! git "${GIT_OPTIONS[@]}" commit --message='update'; then
    exit 1
  fi
  # `--set-upstream origin main`: to avoid error when we push for the first time on a new system.{{{
  #
  #     The current branch main has no upstream branch.
  #     To push the current branch and set the remote as upstream, use
  #
  #         git push --set-upstream origin main
  #}}}
  if ! git "${GIT_OPTIONS[@]}" push --force --set-upstream origin main; then
    exit 1
  fi
;;

untracked)
  git "${GIT_OPTIONS[@]}" ls-files --others --directory --exclude-standard \
    | sed "s:^:$HOME/:"
;;

*)
  printf 'invalid subcommand: %s\n' "$SUBCMD" >&2
  exit 1
;;
esac
