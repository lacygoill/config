% sort

# test if text is sorted
sort --check=silent

# sort ignoring case and removing lines with same score
sort --ignore-case --unique
    # Note that 2 lines can score the same and still be different.
    # For  example, `1 a`  and `1 b`  are  different, but  score the  same in  a
    # numerical sort; `--unique` would delete `1 b`.

# sort file in-place
sort --output=<file>
    # A shell redirection would not work;  the shell would empty the file before
    # executing `sort(1)`.

# sort on N-th field
sort --key=<num>b,<num>
    # Without the  `b` option,  previous whitespace is  included in  the sorting
    # field, which can give confusing results.
    #
    # Without `,❬num❭`, the alphabetical sort would consider the text up to the last field.
    #
    # ---
    #
    # As soon as you specify one  or several single-letter options in a `--key`,
    # `sort(1)` assumes  that only  this/these options  should be  applied.  Any
    # *equivalent* global option is ignored.
    #
    #     $ sort --debug --key=1b,1 --human-numeric-sort
    #     sort: option '-h' is ignored
    #
    # Note that  a global  option such  as `--unique` is  never ignored,  because it
    # doesn't have any  equivalent single-letter option which can be  specified in a
    # `--key`.  From `man sort /DESCRIPTION/;/KEYDEF`:
    #
    #    > OPTS is one or more single-letter ordering options [bdfgiMhnRrV], which
    #    > override global ordering options for that key.
    #
    # Notice how `u` is absent from `[bdfgiMhnRrV]`.

# sort on N-th field with given separator (instead of default whitespace)
sort --key=<num>b,<num> --field-separator=<separator>

# sort alphabetically on 1st field; break tie with numerical sort on 2nd field
sort --key=1b,1 --key=2bn,2
    # The term  “key” comes from  the database  terminology.  A line  can be
    # viewed as a  record, which can be  split in fields, whose  contents can be
    # accessed via keys.
    #
    # ---
    #
    # `b` and `n` are single-letter ordering options, similar to global options:
    #
    #    - `b` = `--ignore-leading-blanks`
    #    - `n` = `--numeric-sort`
    #
    # Contrary to global options, their effect is limited to a given field.
    # In case they conflict with a global option, they override the latter.
    #
    # There exists a single-letter counterpart for every ordering global option.
    # For example, `r` for `--reverse`.

# sort on MM/DD/YYYY date in 3rd field
sort --key=3.7bnr,3 --key=3.1bnr,3 --key=3.4bnr,3
    # This works by  sorting on the 7th  character in the 3rd  field (to isolate
    # the year in `MM/DD/YYYY`), then on the 1st character (for the month), then
    # on the 4th (for the day).
    #
    # ---
    #
    # The `.N` syntax lets you specify an offset within a field.
    #
    # ---
    #
    # No need to specify an end for each part of the date (e.g. `3.1nbr,3.2nbr`)
    # because the sort is numerical, so  the slash (or EOL or whitespace) should
    # naturally end the sorting text.

# sort numerically supporting human-readable units
sort --human-numeric-sort

# sort numerically comparing numbers as floats (instead of integers)
LC_ALL=C sort --general-numeric-sort
    # Your locale might consider the comma as the decimal point.
    # That would be an issue if your number numbers use the dot.
    # `LC_ALL=C` prevents that.
    #
    # ---
    #
    # This should support numbers in scientific notation too (e.g. `1.234E10`).

# sort numerically comparing numbers as program versions
sort --version-sort
    # Each sequence of decimal digits is treated numerically as an index/version
    # number.  For example, `1.3` comes *before* `1.23`, because `3 < 23`.
    # And leading  zeros of  numeric parts are  ignored.  For  example, `1.0003`
    # comes *after* `1.2`, because `0003 = 3 > 2`.
    #
    # For more info: `$ info '(coreutils)Details about version sort'`

# debug problematic sort command
sort --debug ...
    # annotate the part of the line used to sort,
    # and warn about questionable usage to stderr
