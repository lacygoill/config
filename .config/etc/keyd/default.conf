# whitelist of devices which we want to customize
[ids]
# How to discover the IDs of my input devices?{{{
#
#     $ sudo keyd --monitor
#}}}

# You can use a whitelist:{{{
#
#     [ids]
#
#     <vendor id 1>:<product id 1>
#     <vendor id 2>:<product id 2>
#     ...
#}}}
#   Or a blacklist:{{{
#
#     [ids]
#
#     *
#     -<vendor id 1>:<product id 1>
#     -<vendor id 2>:<product id 2>
#     ...
#
# See: `man keyd /CONFIGURATION/;/exclude`
#}}}

# any keyboard{{{
#
# The IDs of our current keyboard are:
#
#     device added: 0fac:0ade keyd virtual keyboard (/dev/input/event18)
#                   ^-------^
#
# But we prefer to use a wildcard (`*`) to match any keyboard, in case we change
# the latter in the future.
#}}}
*

# We can't use a wildcard to match any mouse.{{{
#
# A wildcard only matches devices  which `keyd(1)` identifies as keyboards.  For
# mice, IDs must be explicitly listed:
#
#    > Note 2: The wildcard will only match devices which keyd identifies as
#    > keyboards. keyd is also capable of managing mice (e.g to facilitate
#    > clearing of oneshot modifiers on click), but their ids must be explic‐
#    > itly listed.
#
# Source: `man keyd /CONFIGURATION/;/mice`
#}}}
# Logitech USB Optical Mouse
046d:c077

[main]
# Many bindings are inspired from this layout:
# http://bepo.fr/wiki/Utilisateur:Kaze/B%C3%A9po-intl#Variante_.C2.AB.C2.A0d.C3.A9veloppeur.C2.A0.C2.BB

# Make the capslock key behave as escape or control:{{{
#
#    - escape when tapped (i.e. pressed then released)
#    - control when held (i.e. pressed but not released)
#}}}
capslock = overload(control, esc)
# make the enter key behave as enter when tapped, or control when held
enter = overload(control, enter)

shift = layer(programming_shift)
rightalt = layer(programming_altright)

[programming_shift:S]

# fix frequent mistake where we press `S+oe` instead of `S+&` to produce `1`
` = S-1

[programming_altright:G]
# Forget about what is written on the keycaps of your physical keyboard.{{{
#
# Usually, a binding has the form:
#
#     <key> = <keycode>
#
# To  find  `<key>`, press  the  physical  key you  want  to  bind (without  any
# modifier), while `$ sudo keyd --monitor` is running.
#
# To find `<keycode>`, do the same thing;  except this time, the key you need to
# press must be the one producing the new keysym.
#
# For more info:
#
#    > To elaborate, keyd uses key code  names based on a standard US qwerty keyboard
#    > (originally the same names used  in the kernel). The names themselves correspond
#    > to positions  (i.e they represent key  codes) which may have  different physical
#    > markings on them  if they are for a non-english  market. The display server then
#    > translates these into symbols based on the current layout.
#
#    > The key thing  to remember is that the physical markings on  the board bear no
#    > correspondence  to the  code they  emit. This is  done entirely  in software. In
#    > other words s  in keyd corresponds to  code 31 which produces z  if your display
#    > server layout is set to azerty.
#
# Source: https://github.com/rvaiya/keyd/issues/193#issuecomment-1103195151
#}}}

# G-é → <
2 = 102nd
# G-" → >
3 = S-102nd

# G-z → (
w = 5
# G-e → )
e = -

# G-s → [
s = G-5
# G-d → ]
d = G-minus

# G-x → {
x = G-4
# G-c → }
c = G-=

# G-f → -
f = 6
# G-g → +
g = S-=

# G-j → *
j = \
# G-k → #
k = G-3

# G-q → =
a = equal
# G-b → ~
b = G-2
# G-a → |
q = G-6
# G-t → `
t = G-7
# G-space → _
space = 8

# G-w → ß
# useful to add german words in Anki
z = G-s

# Don't insert any weird character if we press `G-<wrong key>`,
# where `<wrong key>` is in the set: `[hlmpruvy]`
# Do *not* assign the `noop` action.{{{
#
#     h = noop
#     l = noop
#     ...
#
# It might cause unexpected results.
# For example,  suppose you press  `_v$` in Vim  to visually select  the current
# line.  With our current layout, you will actually do:
#
#    1. press `rightalt`
#    2. tap `space`
#    3. release `rightalt`
#    4. tap `v`
#    5. tap `$`
#
# But in practice, you'll sometimes tap `v` before releasing `rightalt`.
# If you  assign `noop`,  nothing will be  sent to Vim;  you won't  enter visual
# mode, which is very annoying and distracting.
# If you assign `v`, `v` is sent to Vim, and you enter visual mode as usual.
#}}}
h = h
l = l
; = ;
p = p
r = r
u = u
v = v
y = y
