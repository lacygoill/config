# WARNING: On your first login on a remote server you administer, do **not** log out until you tested this config!{{{
#
# If you apply it without testing it  first, you might lock yourself out of your
# server!
#
# That might  happen if  the config contains  some keyword which  is set  with a
# wrong value, or  with a value which  – while it works on  your local machine
# – is problematic for the remote server.
#
# ---
#
# Here is a procedure you can follow on your first login.
# *For now, you'll need to authenticate via a password.*
#
# First, from your client, install your public key on the server:
#
#     $ ssh-copy-id -p <port> <user>@<host>
#
# Alternatively, run:
#
#     $ ssh -p <port> <user>@<host> 'tee --append ~/.ssh/authorized_keys
#         chmod 00700 ~/.ssh
#         chmod 0600 ~/.ssh/authorized_keys' < ~/.ssh/id_<algo>.pub
#
# And send your config:
#
#     $ scp /etc/ssh/sshd_config.d/99-local.conf <user>@<host>:
#
# Then, from your server, run `sshd(8)`  on an alternate port (for testing) with
# the config you just sent:
#
#     $ sudo /usr/sbin/sshd -f /tmp/sshd_config -p 2022
#                           ^-----------------^ ^-----^
#                            alternate config   alternate port
#
# Now, from your client, create a new SSH session to this alternate server; make
# sure you can connect and authenticate:
#
#     $ tee /tmp/ssh_config <<'EOF'
#         PubkeyAuthentication yes
#         PasswordAuthentication no
#         ChallengeResponseAuthentication no
#     EOF
#
#     $ ssh -p 2022 -F /tmp/ssh_config -v <user>@<host>
#                   ^----------------^
#     Minimal client config to be sure that `Control*` keywords do not interfere.
#     You might be able to connect for a short period of time (thanks to an
#     existing socket and `ControlPersist`), while your server config is
#     actually wrong.
#
# Finally, make sure you can become root from the account with which you logged in:
#
#     $ sudo --login
#     # whoami
#     root
#     ^--^
#
# If you did  become root successfully, using the original  client session, kill
# the *alternate* server (not the main one), then:
#
#     # move your config where sshd(8) can find it
#     $ sudo mv /tmp/sshd_config /etc/ssh/sshd_config.d/
#
#     # reload sshd(8)'s config
#     $ sudo systemctl reload sshd
#
# From your client, you should now be able to log in without giving a password:
#
#     $ ssh -p 2222 <user>@<host>
#
# You might still be prompted for a  passphrase to decrypt your private key.  To
# not be bothered every time you start a new SSH session, load the key into your
# SSH agent:
#
#     $ ssh-add
#
# If you can't log  in, debug your client's config; you  have the guarantee that
# you can at least log in with the minimal config at `/tmp/ssh_config`.
#}}}

# Global defaults {{{1
# Authentication {{{2

# Passwords are less secure than keys; disable password-based authentication.
PasswordAuthentication no
ChallengeResponseAuthentication no
# The public key authentication method offers the best balance between security and convenience.{{{
#
# A benefit of key-based authentication over password-based, is that it lets you
# run an automated task from an unattended script.  For example:
#
#     $ ssh -i ~/.ssh/task-backup <host>
#
# This assumes that `task-backup` is not encrypted by a passphrase, and that its
# access to the system is  properly restricted with options in `authorized_keys`
# (e.g. with `restrict,command="...",from="..."`).
#
# With  password-based authentication,  the  equivalent would  be  to create  an
# ad-hoc account with no  password.  But how would you limit  the rights of that
# account so that an intruder can't abuse it to inflict damage?  And even if you
# found a way (possibly via `chroot(8)`  or something similar like a container),
# it  would  look like  a  complex  hack;  especially  compared to  the  simpler
# previously mentioned key-based method.
#}}}
PubkeyAuthentication yes
# NOTE: These  3 options  can be  set both  in the  server *and*  client config.
# During the connection, when they negotiate the authentication method, both can
# communicate what they allow and disallow.

# Agent forwarding  is an  insecure feature  (even if  you own  the intermediate
# server,  because it  can still  get compromised).   See `ForwardAgent`  in our
# client config for more info.
# In the "Match blocks" section, you can override this on a per-address or per-user basis:{{{
#
#     Match Address ...
#         AllowAgentForwarding yes
#
#     Match User ...
#         AllowAgentForwarding yes
#}}}
AllowAgentForwarding no

# Disconnect after 2 minutes, if the user has not successfully logged in.
LoginGraceTime 2m

# Disallow more than 6 authentication attempts per connection.
# After half of them (i.e. here 3), log additional failures.
MaxAuthTries 6

# Verify login attempts against DNS.{{{
#
# That is, look  up the remote host name,  then look up the IP  address for that
# host name, and finally check that this  address matches the one from which the
# connection originates.
#
# This  can be  useful if  an intruder  controls the  reverse DNS  for their  IP
# address; in that case, they could change  their apparent host name to a domain
# that  you know  and trust  (e.g. within  your work  company).  I  *guess* that
# matters if your config contains a `Match RDomain` declaration.
#}}}
# Commented because:{{{
#
#    - if you're a home user, your ISP probably controls the reverse DNS on
#      your connection (not the intruder)
#
#    - when DNS fails, failed DNS checks will slow down all SSH logins
#    - DNS checks can increase system load (and the more SSH users you serve
#      simultaneously, the more that load is noticeable)
#
#    - your DNS must be tidy, coherent, and correct
#    - DNS checks don't help if the intruder can poison the server's DNS cache
#    - many IPv6 sites haven't configured reverse DNS and won't for the
#      foreseeable future
#}}}
#     UseDNS yes

# Disallow Root Access {{{2

# TODO: From "SSH Mastery":
#
#    > Sudo can be configured to authenticate via an SSH agent, so that the
#    > users’ credentials are never exposed to the server.
#
# How to configure `sudo(8)` to do that?
# Have a look at "Sudo Mastery" from Michael Lucas.

# Don't allow anyone to log in as root directly.{{{
#
# Instead, they should  log in as a  regular user, then switch to  the root user
# (or better,  use `sudo(8)`).   That lets  the system  log the  user's account,
# providing accountability in  case they break something.  If a  user logs in as
# root, and they break something, you don't know who is responsible; there is no
# audit trail.
#
# Besides, while a user is logged as root, they might be tempted to change their
# environment to make  it more friendly; in turn, those  changes might propagate
# into the environment of servers started by root, and disrupt their services.
# }}}
PermitRootLogin no
# Other values:
# `yes`: root login is allowed.
# `prohibit-password` (default): root login is allowed, but not with a password.
# `forced-commands-only`: root login with public key authentication is allowed, but only if a command is given.{{{
#
#     $ ssh ...  destination command
#                            ^-----^
#
# All other authentication methods are disabled for root.
#}}}

# Restricting Access by User or Group {{{2

# You can restrict access with 4 options:{{{
#
#    - `DenyUsers`
#    - `AllowUsers`
#    - `DenyGroups`
#    - `AllowGroups`
#
# The first one which matches a user wins; the others are not processed.
# IOW,  `DenyUsers` has  priority  over `AllowUsers`,  which  has priority  over
# `DenyGroups`, which has priority over `AllowGroups`.
#
# If a value contains several patterns,  they must be separated with spaces (not
# commas).
#}}}
# If you use `AllowUsers`, `DenyUsers` is useless.{{{
#
# Because in that case, all users are  denied access, unless listed in the value
# of  `AllowUsers`.   Similarly,  if  you  use  `AllowGroups`,  `DenyGroups`  is
# useless.
#}}}
# Whenever possible, prefer `*Groups` over `*Users`.{{{
#
# The former is more future-proof.  For example, suppose you're alice and write:
#
#     AllowUsers alice
#
# One day, you create an account for bob who is meant to help you administer the
# machine; you  want them to have  access to the  SSH server, so you'll  have to
# remember to add them to `AllowUsers`:
#
#     AllowUsers alice bob
#                      ^^^
#
# OTOH, if you write `AllowGroups adm`, you  won't have to do anything, provided
# bob is put in the `adm` group.
#}}}

# Give accounts  the least level  of privilege needed  by users and  programs to
# accomplish their tasks.
# Many networked applications require the user to have an account on the server.{{{
#
# These accounts  should be denied access  to the SSH server  because they don't
# need it.
#}}}
# Some applications (like `rsync(1)`) require the user to have an account with SSH access.{{{
#
# These accounts don't need SSH access  directly; only the application does.  If
# they're meant to use  that application from a known network,  try to limit the
# IP addresses from which they can log in (to that network):
#
#     AllowUsers bob@192.0.2.0/24
#                   ^^----------^
#                    network from which bob is meant to work
#
# Here, bob is only given access if they log in from a host on `192.0.2.0/24`.
#}}}

# Deny access to given users:
#     DenyUsers bob ...

# Allow access to given users:
#     AllowUsers alice ...

# Deny access to given groups:
#     DenyGroups users ...

# Allow access to given groups:
#     AllowGroups adm ...

# Network {{{2

# Run the server on a non-standard port.
# Reduce amount of random noise in our logs, to help us notice real problems.{{{
#
# By reducing the number of login attempts from SSH-cracking worms.
#
# ---
#
# This  might also  let  us  escape some  ineffective  firewalls (which  naïvely
# disallow SSH only based on the standard port 22?).
#
# ---
#
# This does  not add a  lot of security  though.  Scanners constantly  probe all
# ports of all Internet-connected IP addresses,  and can figure out what service
# is running on which port.  Changing the port might buy you a couple of minutes
# against a dedicated intruder, but no longer.
#}}}
Port 2222

# Over which IP protocol should requests be processed by `sshd(8)`.
# Valid values are:
#
#    - `any` (IPv4 and IPv6; the default)
#    - `inet` (IPv4 only)
#    - `inet6` (IPv6 only)
AddressFamily any

# listen for incoming requests no matter the IPv4 address of the server
ListenAddress 0.0.0.0
# same thing for an IPv6 address
ListenAddress ::

# Send occasional TCP keepalive messages back and forth just to remind everyone that connections are still used.{{{
#
# Rationale: If  clients  are regularly  disconnected  by  force (system  crash,
# network link  failure, ...), and the  server is up  for a long time,  it might
# accumulate many "ghost"  users and defunct `sshd(8)`  processes, which consume
# resources and are difficult to clean up.
#
# Also, a firewall  or an ISP can deliberately disconnect  a TCP connection left
# idle for some time (which can be especially problematic for port forwardings).
#}}}
TCPKeepAlive yes
# If the client did not send any data recently, send it a "client alive" message to request a response.{{{
#
# Rationale: SSH  sessions left  idle  will eventually  be  disconnected by  the
# server, the client, or some network device in between.
#
# ---
#
# `90s` is based on what we read in the "SSH Mastery" book:
#
#    > How often you need to send a TCP keepalive depends on your operating
#    > system’s TCP stack, but it should never be longer than two minutes.
#    > [...]
#    > In most cases, sending a TCP keepalive every 90 seconds suffices to
#    > hold the connection open.
#
# The time value can be expressed in other units.
# See: `man 5 sshd_config /TIME FORMATS`.
#}}}
ClientAliveInterval 90s
# Disconnect the client if it was sent 6 client alive messages, but did not respond back.
# Warning: This might terminate your sessions unnecessarily.{{{
#
# If  your ISP  has a  temporary problem  in  the middle  of the  night and  the
# keepalive segments  cannot cross the  network for  a few minutes,  your server
# will terminate the connection.  Try to  find the right value for your network.
# For now,  we settle on  `6`; this means that  our server will  only disconnect
# after 9 minutes (`6 * 90s`) without the client answering.
#
# If necessary use a high value:
#
#    > If you want to keep your connection alive no matter what, cranking
#    > AliveCountMax to high values helps, especially when you’re behind a
#    > cheap Network Address Translation device such as many home routers.
#
# Source: "SSH Mastery" book.
#}}}
ClientAliveCountMax 6

# Banner, Last Login, MOTD {{{2

# Warning: Nothing is printed if `~/.hushlogin` exists.
#
# TODO: We want  that file to exist  to suppress noise  when we log in  on TTY1.
# But printing info about the last login is helpful.  Can we suppress everything
# except the latter?

# Can help finding out  about an intrusion (e.g. last login  is from unknown IP,
# or at a ridiculous hour).
PrintLastLog yes

# Print `/etc/ssh/banner` *before* a user logs in.
# In practice, this can be used as a legal notice to intruders.
# Commented because it suffers from various pitfalls.{{{
#
#    - it might interfere with automated processes run over SSH
#    - it won't be seen by users who authenticate with public keys
#    - the SSH protocol  does not require the client to  display it (but
#      `ssh(1)` still does)
#}}}
#
#     Banner /etc/ssh/banner

# Print `/etc/motd` *after* a user logs in.
# More reliable than the banner.
# Commented because it's set by default, and that option probably has no effect anyway.{{{
#
# Indeed, on Debian-based systems, the printing of  the MOTD is enabled by a PAM
# module which overrides `PrintMotd`:
#
#     $ grep motd /etc/pam.d/sshd
#     # This includes a dynamically generated part from /run/motd.dynamic
#     # and a static (admin-editable) part from /etc/motd.
#     session    optional     pam_motd.so  motd=/run/motd.dynamic
#     session    optional     pam_motd.so noupdate
#     ^-----^    ^------^     ^---------^ ^------^
#      type      control      module path module arguments
#
# `/etc/pam.conf` is made up of rules whose syntax is:
#
#      service type control module-path module-arguments
#
# But  if  `/etc/pam.d/` exists,  `/etc/pam.conf`  is  ignored.  Files  in  that
# directory are made  up of similar rules, but without  the `service` field; the
# latter is read from the file name.
#
# The previous grep'ed rules mean that the module (here `pam_motd.so`) is called
# to  perform something  that  needs to  be  done for  the  user (here  printing
# the  MOTD) before/after  (here before)  they  can access  their service  (here
# `sshd(8)`).
#
# For more info about the `motd=` and `noupdate` arguments, see `man pam_motd`.
# For more info about the PAM configuration, see `man pam.conf`.
#}}}
# TODO: How to configure the PAM module so that it disables the printing of the MOTD?{{{
#
# Commenting out the `session ... pam_motd.so ...` lines is unreliable.
# `/etc/pam.d/sshd`  is owned  by  the `openssh-server`  package; local  changes
# might be lost when that package is upgraded.
#
# Have a look at "PAM Mastery" from Michael Lucas.
#}}}
#     PrintMotd yes

# System Administration {{{2

# where to write the PID of the SSH daemon (`none` to not write one)
PidFile /var/run/sshd.pid

# How verbose should `sshd(8)` be.{{{
#
# To read the logged messages, run either of:
#
#                               v--v
#     $ journalctl --identifier=sshd --since=today
#     $ journalctl --unit=ssh --since=today
#                         ^^^
#}}}
LogLevel INFO
# Which type of program should `sshd(8)` be considered as when it logs messages.{{{
#
# Here, `Auth` means that `sshd(8)` handles security/authorization.
# For more info: `man syslog /Values for facility`.
#}}}
SyslogFacility Auth

# Handle DOS attacks (or network congestion).{{{
#
# Problem: A common  attack is to  start a lot  of client connections  until the
# server exhausts all its resources and  falls over.  I *think* it works because
# OpenSSH is not multi-threaded; instead  it handles each incoming connection by
# starting a separate process.
#
# Solution: Set a  maximum number  of simultaneous  unauthenticated connections,
# and enable the RED protocol (Random  Early Drop).
#
# Here, we  don't accept more  than 90 simultaneous  unauthenticated connections
# (`full`).   Also, as  soon as  we  have more  than 10  (`start`), we  randomly
# refuse connection attempts  with a 30% probability  (`rate`).  The probability
# increases linearly  up to  100% when we  have 90  simultaneous unauthenticated
# connections.
#
# Thanks to  RED, an attacker needs  to devote much more  resources to guarantee
# that  we can't  get in.   During an  attack, we  just need  to keep  trying to
# connect; eventually, we'll be admitted.
#
# Indeed, RED  *de*values a connection  attempt.  For example, without  RED, the
# 11th connection  attempt consumes 1  established connection from  the server's
# maximal capacity.  But with RED,  it only consumes 0.7 established connections
# on average.  So, to  consume 1 more, an attacker needs  to generate around 1.4
# new connection attempts on average  (1/0.7).  And when the probability reaches
# 90%, they need  to generate 10 just to consume  1 established connection.  The
# goal is to maintain a minimum level  of service during an attack; users should
# not have to try to connect too many times.
#
# RED is  used by network  engineers to avoid  congestion, which is  a different
# kind of  issue.  But  a DOS  attack shares  many characteristics  with network
# congestion.
#}}}
#              rate: initial drop probability
#              vv
MaxStartups 10:30:90
#           ^^    ^^
#           |     full: we refuse simultaneous unauthenticated connections above that
#           start: we start refusing connections above that
# }}}1
# `Match` blocks {{{1
# Warning: Keep `Match` blocks after global defaults.
# Support SFTP {{{2

# Make `sshd(8)` start `sftp-server(8)` when it receives a request from an SFTP client.
# We keep this line commented because it's already used on Debian-based systems (`/etc/ssh/sshd_config`).{{{
#
# And if it's used twice, we get an error:
#
#     $ sudo sshd -t
#     /etc/ssh/sshd_config line ...: Subsystem 'sftp' already defined.
#
#     $ sudo systemctl daemon-reload && sudo systemctl restart sshd.service
#     Job for ssh.service failed because the control process exited with error code.
#}}}
#     Subsystem sftp /usr/lib/openssh/sftp-server

# Some users only need to copy files with SFTP.{{{
#
# There  is  no reason  to  give  them access  to  a  shell.  Create  an  ad-hoc
# `sftponly` group and put them inside:
#
#     $ sudo addgroup sftponly
#     $ sudo adduser <user> sftponly
#
# So that this `Match` block limits what they can do with the SSH server to only
# SFTP.
#}}}
Match Group sftponly
    # lock them in their home directory
    ChrootDirectory %h
    # Don't let them run any command.   Instead, start an in-process SFTP server
    # which will provide  all the userland commands and device  node access they
    # might need.
    ForceCommand internal-sftp
    # don't let them tunnel arbitrary traffic over SSH
    AllowTcpForwarding no
