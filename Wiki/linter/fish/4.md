Msg: Use single quotes around command substitution assigned to `--arguments` option of `complete`.


# Bad:

    complete --command=foo --arguments="$(ls)" --no-files
                                       ^     ^

# Good:

    complete --command=foo --arguments='$(ls)' --no-files
                                       ^     ^

# Rationale:

Double  quotes make  the output  of `$()`  static, and  cause its  output to  be
processed later, which is probably not what you want.

    $ cd
    $ complete --command=foo --erase
    $ complete --command=foo --arguments="$(ls)" --no-files
    $ cd /tmp
    $ foo Tab
    # expected: files under /tmp/ are suggested
    # actual: files under $HOME are suggested

Here, you need  to suppress the command substitution at  install-time (i.e. when
`complete` is executed), so that it's delayed until runtime (i.e. when you press
Tab):

    $ complete --command=foo --arguments='$(ls)' --no-files
                                         ^     ^

Besides, if  `ls(1)` outputs a  filename which  contains whitespace, it  will be
wrongly split at runtime:

    $ mkdir /tmp/test
    $ cd /tmp/test
    $ touch 'a b'
    $ complete --command=foo --erase
    $ complete --command=foo --arguments="$(ls)" --no-files
    $ foo Tab
    # expected: 'a b' is suggested
    # actual: 'a' and 'b' are suggested

Worse, if  `ls(1)` outputs  a filename which  contains parentheses,  whatever is
inside  will be  executed as  code  at runtime  (because `()`  is equivalent  to
`$()`).  Letting a  completion run  unpredictable and  arbitrary code  is a  big
no-no:

    $ mkdir /tmp/test
    $ cd /tmp/test
    $ touch '(wrongly_executed)'
    $ complete --command=foo --erase
    $ complete --command=foo --arguments="$(ls)" --no-files
    $ foo Tab
    wrongly_executed: command not found
    âœ˜

# Regex:

    \%(\%(--arguments\|-a\)[= ]\)\@12<="\ze$(
