# How is used
## the real user ID (RUID) of a process?

It identifies  the real  owner of  the process and  affects the  permissions for
sending signals.

A process  without superuser privileges can  signal another process only  if the
sender's RUID (or EUID) matches receiver's RUID (or SUID).
Because a child  process inherits its RUID  from its parent, a  child and parent
can signal each other.

<https://en.wikipedia.org/wiki/User_identifier#Real_user_ID>

## the effective user ID (EUID) of a process?

It's used for most access checks.
It's also used as the owner for files created by that process.

<https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID>

## the Saved User ID (SUID) of a process?

It's  used when  a process  running with  elevated privileges  needs to  do some
unprivileged work temporarily; changing EUID  from a privileged value (typically
0) to some unprivileged value causes the privileged value to be stored in SUID.

Later, the process's EUID  can be set back to the value stored  in SUID, so that
elevated privileges can be restored.

<https://en.wikipedia.org/wiki/User_identifier#Saved_user_ID>

##
# How can a misconfigured file capability let an attacker escalate privileges?

    $ cd /tmp
    $ cp "$(which python)" python
    $ sudo setcap CAP_SETUID+ep python
    $ ./python -c 'import os; os.setuid(0); os.system("/bin/sh")'
    # whoami
    root

---

Note that this doesn't work on a filesystem mounted with the `nosuid` option.
That's why it  doesn't work if you  run the previous commands  from under `/run`
instead of `/tmp`, on Ubuntu 20.04:

    $ grep '/run ' /etc/mtab
    tmpfs /run tmpfs rw,nosuid,nodev,noexec,relatime,size=369988k,mode=755,inode64 0 0
                        ^----^

##
# How to get
## the environment of the Vim process?  (2)

    $ tr '\0' '\n' </proc/$(pidof -s vim)/environ

Note that this shows the environment as it was when the process was spawned.
Any change the process might have made to its environment won't be visible:
<https://serverfault.com/a/79463>

---

Alternatively, start `htop`, select the Vim process, and press `e`.

## the list of processes whose name is 'firefox'?

    $ pidof firefox

## the list of processes whose name matches the regex `fire*`?

    $ pgrep 'fire*'

## the tree of processes from systemd down to the Vim process?

    $ pstree --long --show-parents --show-pids $(pidof -s vim)

##
##
##
# Concepts
## Session
### What's a login session?

The period of activity between a user logging in and logging out of the system.

### How is it implemented when there's no graphical user interface?

With a  kernel session: a  collection of process  groups with the  logout action
managed by a session leader.

### How is it implemented when an X display manager is used (like lightdm)?

With the lifetime of a designated user process that the display manager invokes.

### In a kernel session, what is the session leader?

A  process which  interacts with  the controlling  terminal to  ensure that  all
programs are terminated when a user “hangs up the terminal connection.

On our machine, atm, it seems the session leader is `upstart`:

    $ pstree --long --show-parents --show-pids $(pgrep --oldest upstart)
    systemd(1)---lightdm(980)---lightdm(1086)---upstart(1096)...˜
                                                             │˜
                  all the programs we start during a session ┘˜
                  are children of this `upstart` process˜

If the  session leader  is absent,  the processes  in the  terminal's foreground
process group are expected to handle hangups.

### When does a session end?

When the user logs out or exits their interactive shell.

### What happens then?

It terminates the session leader process.
The shell  process then  sends SIGHUP  to all  jobs, and  waits for  the process
groups to end before terminating itself.

###
## Process group
### What is a process group?

A collection of one or more related processes.

Any shell command starts a process group of one or several processes.
There  may be  several because  the  command may  be  a compound  command, or  a
pipeline.  Besides a process may spawn child processes.

#### How is it useful?

It allows for a signal to be sent to several related processes simultaneously.

###
### What is the purpose of the foreground process group of a terminal?

It determines  what processes may  perform I/O to and  from the terminal  at any
given time.

It's  also the  process  group to  which  the TTY  device  driver sends  signals
generated by keyboard interrupts, notably `C-C`, `C-Z` and `C-\`.

#### Who sets it?

The shell.

It partitions  the command pipelines that  it executes into process  groups, and
sets  what process  group is  the foreground  process group  of its  controlling
terminal.

###
## Special processes
### What's the term for a process
#### which has started (directly or indirectly) another process?

An ancestor process.

#### which has been started (directly or indirectly) by another process?

A descendant process.

###
### What's an orphan process?

A process whose parent has finished or been terminated, but is still running.

### What does “re-parenting” mean?

An operation  performed automatically by  the kernel, which consists  in setting
the parent of an orphan process to init (or a subreaper).

The term can be used in a sentence like so:

    The orphan process has been re-parented to the init process.
                                ^---------^ ^^

### What's a subreaper process?

A subreaper fulfills the role of init for its descendant processes.
Upon termination of a  process that is orphan and marked  as having a subreaper,
the nearest ancestor subreaper will receive  SIGCHLD and be able to `wait(2)` on
the orphan to discover its termination status.

For more info, see:

    man 2 prctl

<https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ebec18a6d3aa1e7d84aab16225e87fd25170ec2b>

###
### What does it mean for a parent process to `wait(2)` on a child?

It means that the parent calls the  system call `wait()` to get information when
the state of one of its child changes.

A state change can be:

   - the child has terminated
   - the child was stopped by a signal
   - the child was resumed by a signal

For more info, see:

    man 2 wait

### Why is it important to do so?

When a  child terminates,  performing a  wait allows the  system to  release the
resources associated with it.

### What happens to a terminated child which is not waited on?

It remains in a zombie state.

##
# ps
## What's the effect of the option?
### `a`

When you use  a BSD-style option – whose  name is not prefixed by  `-` – `ps(1)`
only displays processes owned by the current user.

`a` removes this restriction.

### `x`

When you use a BSD-style option, `ps(1)` only displays processes who have a TTY.

`x` removes this restriction.

### `f`

It draws some ASCII art to represent the parent-child relationship between processes.

The 'f' is for "forest".

### `u`

It selects information and format them according to a predefined user-oriented format.

---

Other similar options  exist to print information according  to other predefined
formats, highlighting various characteristics of processes:

    ┌───┬───────────────────────┐
    │ l │ BSD long format       │
    ├───┼───────────────────────┤
    │ s │ signal format         │
    ├───┼───────────────────────┤
    │ v │ virtual memory format │
    ├───┼───────────────────────┤
    │ X │ register format       │
    └───┴───────────────────────┘

### `w`

Long lines are wrapped.

You can also use `less(1)` to read long lines.

##
## How to only print the effective user, PID, TTY, state and command of all current processes?

    $ ps -e --forest --format=user,pid,tty,stat,args

`--format` lets  you specify  which information  you want to  see, and  how they
should be formatted.  See `man ps /STANDARD FORMAT SPECIFIERS` for the full list
of keywords you can use.

### The header of the TTY column is `TT`.  How to make `ps(1)` write `TTY` instead?

You  can populate  a  column header  with  an arbitrary  text  by suffixing  the
relevant keyword with `=mytext`:

    $ ps -e --forest --format=user,pid,tty=TTY,stat,args
                                          ^--^

#### And how to make the column 13 cells wide?

Specify the desired width after a colon:

    $ ps -e --forest --format=user,pid,tty:13=TTY,stat,args
                                          ^^^

---

Note that if  you specify `=mytext`, `:number` must precede,  otherwise it would
be wrongly interpreted as being part of the text in the column header:

    ✘
    $ ps -e --forest --format=user,pid,tty=TTY:13,stat,args
                                              ^^^
                                              would be  interpreted literally  as being  part of
                                              the column header for the TTY keyword

###
### How to suppress the output of the header line?

Empty every column header with an equal sign.

This is especially useful when you  only want the information about one process,
and the header is just noise:

    $ ps --format=pid=,tty=,stat=,args= --pid=$(pidof -s vim)
                     ^    ^     ^     ^

##
### How to also include the name of the kernel function where a process is sleeping?

Include the `wchan` keyword in your format:

    $ ps -e --format=pid,wchan,args
                         ^---^

#### What does it mean for `-` to be printed instead of a kernel function name?

The process is not sleeping.

##
## How to only print
### the processes whose effective user ID is root?

Use the `-u` option:

    $ ps -u root

### the processes whose PID are 12, 34 and 56?

Use the `--pid` option:

    $ ps --pid=12,34,56
         ^----^

### the 10 most memory-consuming processes?

Use the `--sort` option, pass it the `rss` keyword, and pipe the output of `ps(1)` to `head(1)`:

    $ ps -e --sort -rss | head --lines=11
                   ^
                   print the processes in a descending order

                   by default, or with a `+` sign, the processes would be
                   displayed in an ascending order

##
## What do the numbers in the TIME column mean?

They stand for how much cpu time the processes have consumed thus far.
They do *not* stand for how long the processes have been running.

## Where does the name of the `ps(1)` command come from?

Process Status

##
# Signals
## In which command(s) do I need to shorten a signal name by removing its `SIG` prefix?

`kill` and `trap` but only in the sh shell.

In bash, you can use the full name of a signal (e.g. SIGTERM).
Although, for consistency, and because it's shorter, I would recommend using the
shortened version of a signal name.

##
## When does a process receive
### SIGWINCH?

When the size of its graphical window  (could be a terminal emulator window) has
changed.  This is useful  to let it know that it should  redraw its interface so
that it fits the new geometry.

---

Note that apache unexpectedly reacts to this signal with a graceful shutdown:

   > You are correct that SIGWINCH is used to signal a windows size change to the
   > applications running on a terminal. Due to  the lack of other signal numbers
   > and given  the fact that  httpd normally runs  detached from a  terminal the
   > SIGWINCH signal was  chosen to instruct httpd to do  a graceful shutdown. So
   > this works as designed.

See: <https://bz.apache.org/bugzilla/show_bug.cgi?id=50669#c1>

### SIGCHLD?

When one of its children has stopped or died.

### SIGPIPE?

When it tries to write to a pipe while the reading end has been closed.

The idea is that if you run `$ foo  | bar` and `bar` exits, `foo` gets killed by
a SIGPIPE (sent by the shell?).

It doesn't necessarily give an error.
It  does only  if the  signal  handler for  SIGPIPE  has been  set to  `SIG_IGN`
(ignore); in that case, an error is reported via the exit status of write(2).

<https://unix.stackexchange.com/a/482254/289772>

##
## What's the number of the default signal sent by `kill` to a process?  What's its name?

    15

    SIGTERM
       ^--^
       TERMination

### What are the 4 other signals I can send to kill a process?  (name + number)

    ┌─────────┬────────┬─────────────────────────────────────────┐
    │ name    │ number │ meaning                                 │
    ├─────────┼────────┼─────────────────────────────────────────┤
    │ SIGHUP  │ 1      │ Hangup detected on controlling terminal │
    │         │        │ or death of controlling process         │
    ├─────────┼────────┼─────────────────────────────────────────┤
    │ SIGINT  │ 2      │ Interrupt from keyboard                 │
    ├─────────┼────────┼─────────────────────────────────────────┤
    │ SIGQUIT │ 3      │ Quit from keyboard                      │
    ├─────────┼────────┼─────────────────────────────────────────┤
    │ SIGKILL │ 9      │ Kill signal                             │
    └─────────┴────────┴─────────────────────────────────────────┘

#### How are they sorted, from the least effective to the most effective?

    int(2) < hup(1) ≈ term(15) < quit(3) < kill(9)

<https://unix.stackexchange.com/a/251267/289772>

##
## What happens when a process tries to read from the terminal or write to it, outside the foreground process group?

The TTY device driver sends to it the SIGTTIN (read) or SIGTTOU (write) signal.
Unless caught, these signals make the process stop.

Shells often  override the  default stop  action of  SIGTTOU so  that background
processes deliver their output to the controlling terminal by default.

## How do daemons usually react to SIGHUP?

They reload their config.

   > SIGHUP   also   has   a   completely  different   conventional   meaning   for
   > non-user-facing applications (daemons), which is to reload their configuration
   > file.

<https://unix.stackexchange.com/a/251267/289772>

As an example, see `man xbindkeys /HUP`.

###
## How to send – in a single command – SIGKILL to
### the processes whose PID are 123 and 456?

    $ kill -kill 123 456

### the jobs whose jobspec are %1, %2 and %3?

    $ kill -KILL %1 %2 %3

### the process group whose PGID is 123?

Use the PGID prefixed by `-`:

    $ kill -KILL -123
                 ^

---

If you wanted to send the default  signal (SIGTERM), you would need `--` to mark
the end of the optional arguments:

    $ kill -- -123
           ^^

##
## getting info
### Where can I find more info about the different signals that I can send to a process?

    man 7 signal /Standard signals

###
### How to get
#### the list of all possible signal names?

    $ kill -l

#### the number of the signal INT?

    $ kill -l int
    2˜

#### the name of the signal 8?

    $ kill -l 8
    FPE˜

#### the name of the signal which has terminated or stopped my process?

    $ kill -l <exit status>

Example:

    $ sleep
    C-c
    # the exit status is 130

    $ kill -l 130
    INT˜

###
### What does it mean for a process to “catch” a signal?

The process has registered a signal handler which will be automatically run when
the signal is received.
This handler will determine the behavior of the process, which may be completely
different than the  default behavior of the  process if the signal  had not been
caught.

### How to know which signals a given process block/ignore/catch?

    $ grep -E '^Sig(Blk|Ign|Cgt):' /proc/PID/status
                    │   │   │
                    │   │   └ caught signals
                    │   └ ignored signals
                    └ blocked signals

The numbers on the right are bitmasks written in hexadecimal.
To understand their meaning, you must convert them in binary:

    $ python -c 'print(bin(0xABC123))'
    0b101010111100000100100011

The *index* of each non-zero bit stands for the number of a signal.

So, for example, if you have this bitmask:

    SigCgt: 00000000280b2603

It can be converted in binary, and interpreted like so:

    SigCgt: 101010111100000100100011
                              │   ││
                              │   │└ the signal 1 is caught (SIGHUP)
                              │   └ the signal 2 is caught (SIGINT)
                              └ the signal 6 is caught (SIGUSR1)
            ...


To  automate the  binary  conversion and  interpretation, we  have  a script  in
`~/bin/signals-disposition`.  To use it, invoke  it on the command-line and pass
it the PID of a process as a parameter:

    $ signals-disposition $(pidof -s vim)

For more info, see:

<https://unix.stackexchange.com/a/85365/289772>

##
## keypress-generated signals
### What's the name of the signal generated by the keypress
#### C-c?

    SIGINT

#### C-\?

    SIGQUIT

#### C-z?

    SIGTSTP

### What happens when I press
#### C-c?

The SIGINT signal is sent to the foreground process group.
By default, SIGINT makes processes go back to the main loop.

Example:

    $ vim
    :silent call system('sleep 123')
    " can't interact with Vim anymore
    C-c
    " can interact again (presumably because Vim went back to its main loop)

#### C-\?

The SIGQUIT signal is sent to the foreground process group.
By default, SIGQUIT makes processes quit immediately.

#### C-z?

The SIGTSTP signal is sent to the foreground process group.
By default, SIGTSTP makes processes stop, and control is returned to the shell.

##
### How to change the character which I have to send to interrupt a process (by default C-c)?

    $ stty intr '^k'
                  │
                  └ case insensitive

Technically,  this command  tells the  terminal device  that the  character that
causes a SIGINT to be sent to the foreground job is `C-k`.

### How to tell the terminal device to never send SIGINT, SIGQUIT, SIGTSTP?

    $ stty -isig

##
## suspension
### Which signal(s) can I send to
#### suspend a job?

SIGTSTP or SIGSTOP.

Mnemonic for SIGTSTP: Typing SToPped

##### What's the difference between them?

SIGTSTP allows the process  to suspend gracefully (i.e. it can  use some time to
organize itself), and can be caught or ignored.

SIGSTOP forces  the process  to suspend  immediately, can't  be caught,  and may
leave the process in an unstable state (i.e. can't be resumed).

#### resume a suspended job in the background?

SIGCONT

###
### How to suspend the current job, which runs in the background, with `kill`?

    $ kill -tstp %

#### Without `kill`?

    $ fg
    C-z

##
### What should I do before suspending a GUI program with `kill` or `C-z`?

Minimize it.
Otherwise its frozen window will take valuable space on your desktop, and you'll
get confused if you try to interact with it (because it won't respond).

##
## traps
### How to list all the traps set in the current shell?

    $ trap

### How to make all future commands run in the shell ignore a given signal?

Install a trap running an empty command.

For example, to make all commands ignore SIGHUP:

    $ trap '' HUP
    $ sleep 1234

Then, from another terminal:

    $ kill -HUP $(pidof sleep)

The sleep process won't terminate.

### What does resetting a trap mean?

The specified signal is reset to its original disposition (the value it had upon
entrance to the shell).

#### How to do it?

Use the special argument `-`.

    $ trap - sigspec

---

Example:

    $ trap '' HUP
    $ trap
    trap -- '' HUP˜

    $ trap - HUP
    $ trap
    ''˜

##
# Pitfalls
## My process is taking too much time!

    $ strace --output=/tmp/log -r <cmd>
    $ sort log >sorted_log

The lines at the bottom should match the slowest system calls.
Try to understand why they take so much time...

---

For some reason, if you reverse the order of `sort(1)`, you lose Vim's syntax highlighting.
