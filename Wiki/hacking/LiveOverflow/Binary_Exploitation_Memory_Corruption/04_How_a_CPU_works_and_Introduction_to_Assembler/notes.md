<https://www.youtube.com/watch?v=6jSKldt7Eqs>

# What does assembly code look like?

Here is some code written in x86 assembler:
```asm
; store value 5 in register eax
mov eax, 0x5
; BTW, "load" is a synonym for "store".
; Also, notice how the semicolon can be used as a comment leader.

; add value 3 to that register
add eax, 0x3

; store value 8 in an another register
mov ebx, 0x8
;    ^

; subtract the 2nd register from the 1st,
; and store the result in the 1st
sub eax, ebx
```
# What if I need more than a few registers to write my program?

Whatever does not fit in the CPU registers, lives in the RAM.

For example, you could have some value in RAM at an address which is held by the
register `ebx`.  To store that value in register `eax`, you would write:

    mov eax, [ebx]
    ;        ^   ^

These brackets mean that you don't want the value in the CPU register `ebx`; you
want whatever value is held in the RAM at the address given by `ebx`.
Similarly, in Python, if you write:

    myarray[123]

You don't want the  value `123`; you want whatever item is  held by `myarray` at
the  index `123`.   In  the previous  `mov` instruction,  you  can imagine  that
`myarray` is implicitly the RAM:

    mov eax, RAM[ebx]
    ;        ^^^
    ; don't actually write that;
    ; it's just to make the code easier to understand

# How does the CPU understand instructions names such as `mov`, `add`, or `push`?

It doesn't.
A symbolic name is for the programmer, when they write their source code.
It's also called a mnemonic.

An assembler program must compile this source code into executable machine code.
In the latter, a mnemonic such as  `mov` is actually encoded as an opcode, which
is just a binary number interpreted by the CPU in a special way.

So, if you  were to read the machine  code of `mov eax, 5`  via a *dis*assembler
program, it would just look like a big binary number:

    that's the mov instruction (for the eax register)
    v------v
    1011100000000101000000000000000000000000
            ^------------------------------^
                  that's the 0x5 value

Actually, since  binary is  too hard  to read,  the disassembler  would probably
print it in its hexadecimal form:

    mov eax
    vv
    B805000000
      ^------^
        0x5
