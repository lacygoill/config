#!/usr/bin/python3

# Purpose: print "Knock, knock, NAME", where `NAME` is a runtime supplied argument
# Test: `$ ./matrix.py $USER`
# Input: an arbitrary name string
# Output: "Knock, knock, <your login name>"
# Reference: https://www.youtube.com/watch?v=ajy1PHWYeyQ


"""Module providing sys.argv and sys.stderr.write()."""
import sys

if len(sys.argv) != 2:
    # Notice  that `.write()`  doesn't do  anything implicitly.   If you  want a
    # newline at the end, you must write it explicitly.
    # OTOH, `print()`  assumes that you  always want a newline  at the end  of a
    # message, and appends one implicitly.
    #                                             vv
    sys.stderr.write(f"Usage: {sys.argv[0]} <name>\n")
    #                          ^---------^
    # This evaluates  to whatever you  wrote on  the command-line to  invoke the
    # script:
    #
    #     $ ./matrix.py $USER
    #       ^---------^
    #       assumes that you're in the same directory as the script
    #
    #     $ matrix.py $USER
    #       ^-------^
    #       assumes that you're in a directory which is present in your PATH
    #
    #     $ /path/to/matrix.py $USER
    #       ^----------------^
    sys.exit(1)

# This is an f-string.{{{
#
# `f` is a string prefix which lets  us specify a formatted string literal (also
# called **f-string**  for short),  which can  include expressions  inside curly
# brackets.
#
# See:
# https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-stringprefix
# https://docs.python.org/3/tutorial/inputoutput.html
#}}}
#     v
print(f"Knock, knock, {sys.argv[1]}.")
#                     ^-----------^
# This evaluates to the first argument passed to the script on the command-line:
#
#     $ ./matrix.py $USER
#                   ^---^
