<https://www.youtube.com/watch?v=qS4VWL5R_OM>

Like in a previous video, our goal is  to crack a program which asks for a valid
license key.  However,  this time, the valid  key can't be read  directly from a
register in GDB.

# crack the `license_2` binary by patching a jump around the key's validity check
## compile the binary

    $ gcc license_2.c -o build/license_2 -no-pie

## open it in radare2

    $ radare2 build/license_2

## analyze the code, seek to `main()`, and print the disassembly

    [0x...]> aaa
    [0x...]> s main
    [0x...]> pdf

## in the disassembly, find the instruction printing the "WRONG" message

     │    0x0040120a      817dec940300.  cmp dword [var_14h], 0x394
     │┌─< 0x00401211      750e           jne 0x401221
     ││   0x00401213      488d3d0d0e00.  lea rdi, str.Access_Granted_ ; 0x402027 ; "Access Granted!" ; const char *s
     ││   0x0040121a      e841feffff     call sym.imp.puts           ; int puts(const char *s)
    ┌───< 0x0040121f      eb0c           jmp 0x40122d
    │││   ; CODE XREF from main @ 0x401211(x)
    ││└─> 0x00401221      488d3d0f0e00.  lea rdi, str.WRONG_         ; 0x402037 ; "WRONG!" ; const char *s

## find where the branch comes from, and note its address

An arrow points to the instruction printing "WRONG"; follow it backward:

    v--------v
    0x0040120a      817dec940300.  cmp dword [var_14h], 0x394
    0x00401211      750e           jne 0x401221

Here, `0x0040120a`  is the address  of the instruction which  determines whether
the execution will follow the code path leading to the "WRONG" message.

---

BTW, notice that `cmp` compares some variable to the hexadecimal number `0x394`.
The latter can be converted into a decimal number in several ways.
From the shell, via python:

    $ python -c 'print(0x394)'
    916

Or via `rax2(1)`:

    $ rax2 0x394
    916

Also from radare2 itself, via `!rax2`:

    [0x...] !rax2 0x394

Or via `?`:

    [0x...]> ? 0x394
    int32   916
    ...

Notice that `916` matches our `VALID_SUM` macro in `license_2.c`:

    if (sum == VALID_SUM)

IOW, compiling this `if` statement likely results in the previous `cmp` assembly
instruction (as well as the following `jne`).

## add a breakpoint on it

    [0x...]> db 0x0040120a

## restart in debug mode providing some (wrong) key

    [0x...]> ood my-key

## continue execution until next breakpoint

    [0x...]> dc
    Checking License: my-key
    hit breakpoint at: 0x40120a

You can confirm that the execution has indeed stopped at `0x4011ff` by executing
`dr rip` to print the value held by the `rip` register:

    [0x...]> dr rip
    0x0040120a

## reset the `rip` register so that it points to the instruction granting us the access

The latter can be found in the output of `pdf`:

    0x00401213      488d3d0d0e00.  lea rdi, str.Access_Granted_ ; 0x402027 ; "Access Granted!" ; const char *s
    ^--------^

To reset `rip`, execute `dr`:

    [0x...]> dr rip=0x00401213
    0x... ->0x00401213

## continue execution (until the end) to be granted the access

    [0x...]> dc
    Access Granted!

##
# crack the `license_2` binary by writing a keygen
## reverse engineer the algorithm validating a key
### print a graph of `main()`

    [0x...]> s main
    [0x...]> VV

             ┌─────────────────────────────────────────────────────┐
             │ [0x401176]                                          │
             │   ; DATA XREF from entry0 @ 0x4010b1(r)             │
             │ 190: int main (int argc, char **argv, char **envp); │
             │ ; arg uint32_t argc @ dh                            │
             │ ; arg char **argv @ edx                             │
             │ ; var char *s @ rbp-0x8                             │
             │ ; var size_t var_ch @ rbp-0xc                       │
             │ ; var int64_t var_10h @ rbp-0x10                    │
             │ ; var uint32_t var_14h @ rbp-0x14                   │
             │ ; var uint32_t var_24h @ rbp-0x24                   │
             │ ; var char **var_30h @ rbp-0x30                     │
             │ endbr64                                             │
             │ push rbp                                            │
             │ mov rbp, rsp                                        │
             │ sub rsp, 0x30                                       │
             │ ; argc                                              │
             │ mov dword [var_24h], edi                            │
             │ ; argv                                              │
             │ mov qword [var_30h], rsi                            │
             │ cmp dword [var_24h], 2                              │
             │ je 0x4011a5                                         │
             └─────────────────────────────────────────────────────┘
                     f t
                     │ │
                     │ └────────────────────┐
        ┌────────────┘                      │
        │                                   │
    ┌──────────────────────────────┐    ┌────────────────────────────────────────┐
    │  0x40118f [oc]               │    │  0x4011a5 [of]                         │
    │ ; const char *s              │    │ ; CODE XREF from main @ 0x40118d(x)    │
    │ ; 0x402004                   │    │ mov dword [var_14h], 0                 │
    │ ; "Usage: <key>"             │    │ mov rax, qword [var_30h]               │
    │ lea rdi, str.Usage:__key_    │    │ mov rax, qword [rax + 8]               │
    │ ; int puts(const char *s)    │    │ mov qword [s], rax                     │
    │ call sym.imp.puts;[ob]       │    │ mov rax, qword [s]                     │
    │ mov eax, 1                   │    │ ; const char *s                        │
    │ jmp 0x401232                 │    │ mov rdi, rax                           │
    └──────────────────────────────┘    │ ; size_t strlen(const char *s)         │
        v                               │ call sym.imp.strlen;[od]               │
        │                               │ mov dword [var_ch], eax                │
        │                               │ mov rax, qword [s]                     │
        │                               │ mov rsi, rax                           │
        │                               │ ; const char *format                   │
        │                               │ ; 0x402011                             │
        │                               │ ; "Checking License: %s\n"             │
        │                               │ lea rdi, str.Checking_License:__s_n    │
        │                               │ mov eax, 0                             │
        │                               │ ; int printf(const char *format)       │
        │                               │ call sym.imp.printf;[oe]               │
        │                               │ mov dword [var_10h], 0                 │
        │                               │ jmp 0x401202                           │
        │                               └────────────────────────────────────────┘
        │                                   v
        │                                   │
        └───────┐                           │
                │                      ┌────┘
               ┌─────────────────────────┐
               ││                      │ │
               ││                ┌─────────────────────────────────────┐
               ││                │  0x401202 [oh]                      │
               ││                │ ; CODE XREF from main @ 0x4011e6(x) │
               ││                │ mov eax, dword [var_10h]            │
               ││                │ cmp eax, dword [var_ch]             │
               ││                │ jl 0x4011e8                         │
               ││                └─────────────────────────────────────┘
               ││                      t f
               ││                      │ │
               ││       ┌──────────────┘ │
               ││       │                └────────────────────────┐
               ││       │                                         │
               ││   ┌─────────────────────────────────────┐   ┌───────────────────────────────┐
               ││   │  0x4011e8 [og]                      │   │  0x40120a [oi]                │
               ││   │ ; CODE XREF from main @ 0x401208(x) │   │ cmp dword [var_14h], 0x394    │
               ││   │ mov eax, dword [var_10h]            │   │ jne 0x401221                  │
               ││   │ movsxd rdx, eax                     │   └───────────────────────────────┘
               ││   │ mov rax, qword [s]                  │           f t
               ││   │ add rax, rdx                        │           │ │
               ││   │ movzx eax, byte [rax]               │           │ │
               ││   │ movsx eax, al                       │           │ │
               ││   │ add dword [var_14h], eax            │           │ │
               ││   │ add dword [var_10h], 1              │           │ │
               ││   └─────────────────────────────────────┘           │ │
               ││       v                                             │ │
               ││       │                                             │ │
               └────────┘                                             │ │
                │                                                     │ └──────────┐
                │                            ┌────────────────────────┘            │
                │                            │                                     │
                │                        ┌─────────────────────────────────┐   ┌─────────────────────────────────────┐
                │                        │  0x401213 [oj]                  │   │  0x401221 [ok]                      │
                │                        │ ; const char *s                 │   │ ; const char *s                     │
                │                        │ ; 0x402027                      │   │ ; CODE XREF from main @ 0x401211(x) │
                │                        │ ; "Access Granted!"             │   │ ; 0x402037                          │
                │                        │ lea rdi, str.Access_Granted_    │   │ ; "WRONG!"                          │
                │                        │ ; int puts(const char *s)       │   │ lea rdi, str.WRONG_                 │
                │                        │ call sym.imp.puts;[ob]          │   │ ; int puts(const char *s)           │
                │                        │ jmp 0x40122d                    │   │ call sym.imp.puts;[ob]              │
                │                        └─────────────────────────────────┘   └─────────────────────────────────────┘
                │                            v                                     v
                │                            │                                     │
                │                            └───────────────────┐                 │
                │                                                │ ┌───────────────┘
                │                                                │ │
                │                                          ┌─────────────────────────────────────┐
                │                                          │  0x40122d [ol]                      │
                │                                          │ ; CODE XREF from main @ 0x40121f(x) │
                │                                          │ mov eax, 0                          │
                │                                          └─────────────────────────────────────┘
                │                                              v
                │                                              │
                │                 ┌────────────────────────────┘
                └───────────────────┐
                                  │ │
                            ┌─────────────────────────────────────┐
                            │  0x401232 [om]                      │
                            │ ; CODE XREF from main @ 0x4011a0(x) │
                            │ leave                               │
                            │ ret                                 │
                            └─────────────────────────────────────┘

### rename the assembly variables so that they match their C counterparts (to make the graph more readable)
#### `var_24h`

The only time `var_24h` is used in a meaningful way is in these instructions:

    cmp dword [var_24h], 2
    je 0x4011a5

It's compared  to `2`.  And  if it's not, the  program prints a  "Usage" message
then exits,  which is  only meant to  be printed if  something goes  wrong.  The
simplest  way to  cause the  program to  print a  "Usage" message  is to  run it
without a key.  So  the purpose of the test comparison is  probably to make sure
that we did provide a  key.  And the simplest way to make sure  of that – in C
–  is to  compare the  number of  arguments received  by the  program to  `2`.
Because in C, the `main()` function of the program receives all the words on the
command-line:

    $ ./build/license_2 my-key
      ^---------------^ ^----^
              1           2

Conclusion: `var_24h` is probably named `argc` in the C code.
Let's rename it in our graph:

    > afvn _argc var_24h

#### `var_10h`

It's first initialized with `0`:

    mov dword [var_10h], 0

It's then moved into `eax`, and compared to `var_ch`:

    mov eax, dword [var_10h]
    cmp eax, dword [var_ch]

If it holds a lower value, the execution jumps into a loop's body:

    jl 0x4011e8

BTW, we know there is a loop because:

   - `jl` is written in the node labeled `[oh]` in the graph
   - `jl` jumps to the node labeled `[og]` if the comparison is true
   - the only exit path out of `[og]` goes back to `[oh]`

IOW, `jl` is written inside a loop connecting `[oh]` and `[og]`.

Finally, inside the loop, it's incremented by 1 at the end of each iteration:

    add dword [var_10h], 1

Conclusion: `var_10h` is used in a test  to decide when a loop should break, and
is incremented in each iteration.  That looks like an iteration variable.
Let's rename it into `i` (for "i"teration):

    > afvn i var_10h

#### ?

    > afvn _argv var_30h
    > afvn key s
    > afvn keylen var_ch
    > afvn sum var_14h

TODO: finish this section

---

Explain how we inferred which C variable matched which assembly variable.

---

About this instruction:

    add rax, rdx

In pseudo-code, this would give:

    rax = rax + rdx

When it's run, `rax`  holds the *address* of `key` in our  C code (remember that
`key` is declared as a *pointer* to a character; not as a character directly).
And `rdx` holds the *value* of `i` in our C code.

If  you were  to  replace the  names  of  the assembly  variables  with their  C
counterparts, it would give this pseudo-code:

    rax = *key + i

Which doesn't  seem to make  sense, because  you can't add  a number (`i`)  to a
string (`key`).  Until you realize that:

   - `*key` is not a string, but an address referring to a string

   - adding the number `i` to the address `*key` gives you a new address whose
     first byte is the `i`-th character in `key`, because an ASCII character is
     stored in 1 byte and addresses refer to bytes (not bits)

For example, suppose that:

   - `"my-key"` is stored at `0x123`
   - `0x456` is stored at `0x123`
   - `key` holds `0x123`
   - `i` holds `0x4`

    0x456                   → 0x123                                       → "my-key"
    `s` in assembly code      `*key` (in C code) or `[s]` (in assembly code)    `key` (in C code)

Then:

        rax = [s] + i
    ⇔
        rax = 0x123 + 4
    ⇔
        rax = 0x127

Since `"my-key"` starts at `0x123`, we have:

   - `0x123` holds `"m"`
   - `0x124` holds `"y"`
   - `0x125` holds `"-"`
   - `0x126` holds `"k"`
   - `0x127` holds `"e"`
   - `0x128` holds `"y"`

Which means that:

        rax = 0x127
    ⇔
        rax = "e"

---

Here is the path which grants us the access:

                         ┌───────────────────────────────┐
                         │  0x40120a [oi]                │
                         │ cmp dword [var_14h], 0x394    │
                         │ jne 0x401221                  │
                         └───────────────────────────────┘
                                 f t
                                 │ │
                                 │ ...
        ┌────────────────────────┘
        │
    ┌─────────────────────────────────┐
    │  0x401213 [oj]                  │
    │ ; const char *s                 │
    │ ; 0x402027                      │
    │ ; "Access Granted!"             │
    │ lea rdi, str.Access_Granted_    │
    │ ; int puts(const char *s)       │
    │ call sym.imp.puts;[ob]          │
    │ jmp 0x40122d                    │
    └─────────────────────────────────┘

The access is granted only if the  test performed by `jne` is false (because the
path starts with an "f" like in false; not with a "t" like in true).
Which means that the  values used in the previous instruction  must be equal (if
they were different, `jne` would succeed):

    cmp dword [var_14h], 0x394

In turn,  this means that whatever  value is held  at the address pointed  to by
`var_14h`, it must be equal to 0x394 (916).

---

About `var_14h`, it's first referred to at the start of `main()`:

    var uint32_t var_14h @ rbp-0x14

It  seems  to  be allocated  some  space  at  the  address held  by  `rbp`  (the
BasePointer Register), at offset `-0x14`.

Then, after the program checks that the user provided a key, it's set to 0:

    mov dword [var_14h], 0

Finally, it's being added the value held by `eax` in each iteration of a loop:

    add dword [var_14h], eax

####
#### The new names are not used in the graph!

I *think* that's because the graph is cached, and the cache is not updated right
after renaming a variable.  You probably need to force radare2 to invalidate the
cache by re-computing the graph, for  example by pressing `@` twice. `@` toggles
the direction of the graph (vertical vs horizontal).

It might be a bug: <https://github.com/radareorg/radare2/issues/2285>
Not sure why the report was closen, since the issue can still be reproduced...

##
## now that you know what a valid key must look like, write an algorithm generating such keys (aka a keygen)
### in python

TODO

See `./keygen.py`.

### in C

TODO

See `./keygen.c`.
