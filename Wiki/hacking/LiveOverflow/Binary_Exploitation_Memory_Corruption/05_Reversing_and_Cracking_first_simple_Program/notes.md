<https://www.youtube.com/watch?v=VroEiMOJPm8>

Our goal is to crack a simple program which asks for a valid license key.
Cracking implies that we don't have access  to the source code; only the machine
code.  Here, we do have the source code, but we'll pretend that we don't.

# compile the source code into machine code

    $ cd LiveOverflow/Binary_Exploitation_Memory_Corruption/05_Reversing_and_Cracking_first_simple_Program/
    $ mkdir build
    $ gcc license_1.c -o build/license_1 -no-pie

# turn the machine code back into assembly code, because it's more readable

This can be achieved by executing `disassemble main` from GDB:

    $ gdb -ex='set disassembly-flavor intel' \
          -ex='disassemble main' \
          --batch \
          build/license_1 \
          | sed '1d; $d; s/^\s\+\|\s\+$//g' \
          >/tmp/asm.asm
    #              ^--^
    #              to get syntax highlighting in Vim

    $ vim /tmp/asm.asm

Here is the output:
```asm
0x0000000000401176 <+0>:	endbr64
0x000000000040117a <+4>:	push   rbp
0x000000000040117b <+5>:	mov    rbp,rsp
0x000000000040117e <+8>:	sub    rsp,0x10
0x0000000000401182 <+12>:	mov    DWORD PTR [rbp-0x4],edi
0x0000000000401185 <+15>:	mov    QWORD PTR [rbp-0x10],rsi
0x0000000000401189 <+19>:	cmp    DWORD PTR [rbp-0x4],0x2
0x000000000040118d <+23>:	je     0x4011a2 <main+44>
0x000000000040118f <+25>:	lea    rdi,[rip+0xe6e]        # 0x402004
0x0000000000401196 <+32>:	call   0x401060 <puts@plt>
0x000000000040119b <+37>:	mov    eax,0x1
0x00000000004011a0 <+42>:	jmp    0x4011fe <main+136>
0x00000000004011a2 <+44>:	mov    rax,QWORD PTR [rbp-0x10]
0x00000000004011a6 <+48>:	add    rax,0x8
0x00000000004011aa <+52>:	mov    rax,QWORD PTR [rax]
0x00000000004011ad <+55>:	mov    rsi,rax
0x00000000004011b0 <+58>:	lea    rdi,[rip+0xe5a]        # 0x402011
0x00000000004011b7 <+65>:	mov    eax,0x0
0x00000000004011bc <+70>:	call   0x401070 <printf@plt>
0x00000000004011c1 <+75>:	mov    rax,QWORD PTR [rbp-0x10]
0x00000000004011c5 <+79>:	add    rax,0x8
0x00000000004011c9 <+83>:	mov    rax,QWORD PTR [rax]
0x00000000004011cc <+86>:	lea    rsi,[rip+0xe54]        # 0x402027
0x00000000004011d3 <+93>:	mov    rdi,rax
0x00000000004011d6 <+96>:	call   0x401080 <strcmp@plt>
0x00000000004011db <+101>:	test   eax,eax
0x00000000004011dd <+103>:	jne    0x4011ed <main+119>
0x00000000004011df <+105>:	lea    rdi,[rip+0xe51]        # 0x402037
0x00000000004011e6 <+112>:	call   0x401060 <puts@plt>
0x00000000004011eb <+117>:	jmp    0x4011f9 <main+131>
0x00000000004011ed <+119>:	lea    rdi,[rip+0xe53]        # 0x402047
0x00000000004011f4 <+126>:	call   0x401060 <puts@plt>
0x00000000004011f9 <+131>:	mov    eax,0x0
0x00000000004011fe <+136>:	leave
0x00000000004011ff <+137>:	ret
```
---

Tip:  `set disassembly-flavor intel`  changes  the  syntax   of  the  printed
instructions from  the default AT&T to  intel.  To avoid having  to execute this
command every time you start GDB, write it in a GDB initialization script:

    $ echo 'set disassembly-flavor intel' >>~/.config/gdb/gdbearlyinit

For more info, see `man gdbinit`, as well as:
<https://sourceware.org/gdb/current/onlinedocs/gdb/Machine-Code.html#index-Intel-disassembly-flavor>

Also, add  `set startup-quietly on`  to suppress the introductory  and copyright
messages:

    $ echo 'set startup-quietly on' >>~/.config/gdb/gdbearlyinit

#
# note the most important instructions

Here, there  are only  a few  instructions which  dictate the  program's control
flow:

   - `call` (5)
   - `cmp` (1)
   - `je` (1)
   - `jmp` (2)
   - `jne` (1)
   - `ret` (1)
   - `test` (1)

Those are  the only instructions  which we need to  understand what the  code is
doing at a high level:

    0x0000000000401189 <+19>:	cmp    DWORD PTR [rbp-0x4],0x2
    0x000000000040118d <+23>:	je     0x4011a2 <main+44>
    0x0000000000401196 <+32>:	call   0x401060 <puts@plt>
    0x00000000004011a0 <+42>:	jmp    0x4011fe <main+136>
    0x00000000004011bc <+70>:	call   0x401070 <printf@plt>
    0x00000000004011d6 <+96>:	call   0x401080 <strcmp@plt>
    0x00000000004011db <+101>:	test   eax,eax
    0x00000000004011dd <+103>:	jne    0x4011ed <main+119>
    0x00000000004011e6 <+112>:	call   0x401060 <puts@plt>
    0x00000000004011eb <+117>:	jmp    0x4011f9 <main+131>
    0x00000000004011f4 <+126>:	call   0x401060 <puts@plt>
    0x00000000004011ff <+137>:	ret

There is  still some  noise in there.   We only  need the last  3 digits  of the
addresses in the first  column (which we will use as a label  to identify a code
location more  easily) and the  name of the instruction  in the 3rd  column.  We
also need some parts of the operands:

   - for `cmp`, the number value which is compared
   - for `jne`, the address of the jump
   - for `test`, the register name which is tested
   - for `call`, the name of the called function

Which gives:

    189  cmp   0x2
    18d  je    0x4011a2
    196  call  puts
    1a0  jmp   0x4011fe
    1bc  call  printf
    1d6  call  strcmp
    1db  test  eax,eax
    1dd  jne   0x4011ed
    1e6  call  puts
    1eb  jmp   0x4011f9
    1f4  call  puts
    1ff  ret

## What does this `test eax,eax` instruction do?

[`test`][1] performs a bitwise AND on its 2 operands: `operand1 & operand2`.
But the purpose of  `test` is not the result of this  computation; the latter is
discarded.  The purpose is to set some status flags; one of them being `ZF`.

So `test eax,eax` computes `eax & eax`.
For `ZF` to be set, the result must be 0.
For the result to be 0, all the bits  in `eax` must be 0; i.e. `eax` itself must
hold the value 0.

So these instructions:

    test   eax,eax
    jne    0x4011ed

check  whether `eax`  is 0  or not.   And if  it's not,  the execution  jumps to
another address.

Besides, since these lines follow a call to `strcmp()`, we can assume that `eax`
holds the return value of the latter.  IOW, these 3 lines:

    call  strcmp
    test  eax,eax
    jne   0x4011ed

test whether 2 strings are equal, and the execution jumps somewhere else if they
are not.

#
# draw a control-flow diagram around these instructions

    +---------------------+
    | 189  cmp   0x2      |
    | 18d  je    0x4011a2 |
    +---------------------+
              t(rue)      f(alse)
              |           | XXX (we don't know what it is yet)
              |           | is not equal to 2
    XXX       |           v
    is equal  |           +---------------------+
    to 2      |           | 18f                 |
              |           | 196  call  puts     | print some message (let's call it MSG1)
              |           | 1a0  jmp   0x4011fe | jump near the exit
              |           | 1ff  ret            | exit (return from main())
              |           +---------------------+
              v
    +---------------------+
    | 1a2                 |
    | 1bc  call  printf   | print some message (MSG2)
    | 1d6  call  strcmp   | compare 2 strings
    | 1db  test  eax      | if the strings are different
    | 1dd  jne   0x4011ed | jump to this bottom-right box
    +---------------------+
                     f    t
                     |     \
                     |      \ the strings are different
                     |       \
                     |        v
    the strings are  |      +-------------------+
    the same         |      | 1ed               |
                     |      | 1f4  call  puts   | print some message (MSG3)
                     |      | 1ff  ret          | exit
                     |      + ------------------+
                     v
    +---------------------+
    | 1df                 |
    | 1e6  call  puts     | print some message (MSG4)
    | 1eb  jmp   0x4011f9 | jump near the exit
    | 1ff  ret            | exit
    +---------------------+

Notice that at the top of most boxes, we've put some address without a following
instruction name.   Each of them  corresponds to  the first instruction  after a
jump.  They  will be helpful  later to follow  the execution during  a debugging
session; that is, when  the code branches into several paths,  they will help us
find out which path is taken by the execution.

#
# start a debugging session without providing a key

    $ gdb build/license_1

    # add breakpoint
    (gdb) break *main

    # run the program
    (gdb) run

    # step over the next instruction
    (gdb) ni
    # if you wanted to step inside a function call,
    # you would execute `si` instead of `ni`

Now,  keep pressing  `Enter` to  repeat  the last  `ni` command,  until you  see
something interesting.  After a few `Enter`,  you should notice that the program
prints a  usage message.  The  address of  the instruction responsible  for this
message is given right before, and  ends with `196`.  It matches the instruction
which we noted in our previous diagram:

    196  call  puts

And right before, we also noted that the program compares `XXX` to 2.
After printing the usage message, `main()` exits.
Something  went wrong.   But  what?  The  simplest answer  is  that the  program
expected a key, but we didn't provide one.

This means  that the purpose of  the `XXX ==  2` comparison is to  check whether
we've given a key.  If you wonder why the code compares `XXX` to 2 instead of 1,
remember that in C the first argument received by `main()` is always the name of
the  program itself,  exactly as  you invoked  it.  So,  if you  provide a  key,
`main()` receives 2 arguments: the name of the program (e.g. `build/license_1`),
and the key (e.g. `my-key`).

From what we've observed during this debugging session, we can infer that:

   - `XXX` is the number of arguments received by `main()` (by convention named `argc` in C code)
   - `MSG1` is `main()`'s usage message

There are  still a  few missing  info in  the diagram;  namely what  are `MSG2`,
`MSG3` and `MSG4`?  We'll need to start a new debugging session to find out.

## What was the purpose of the asterisk in `break *main`?

It  asks  GDB to  stop  the  execution right  before  the  first instruction  of
`main()`.  Without, it would stop right after its [prologue][2].

   > The difference is that b *main breaks  on the first instruction of main, while b
   > main breaks on the first instruction after the function prologue.

Source: <https://stackoverflow.com/questions/40960758/break-main-vs-break-main-in-gdb>

## How to read the C source code while stepping through the assembly code?

First, re-compile with debugging information:

    $ gcc license_1.c -o build/license_1 -no-pie -g
                                                 ^^

Next, inside GDB:

    (gdb) tui enable

#
# start a new debugging session; this time *do* provide a key

You don't need to quit GDB and start a new instance.
Stay inside GDB, and run `run my-key`:

    (gdb) run my-key
    # answer "y" at this prompt:
    #     The program being debugged has been started already.
    #     Start it from the beginning? (y or n) y
    (gdb) ni

After pressing `Enter`  a few times to  repeat `ni`, you should  notice that the
execution jumps from  `18d` to `1a2`.  This means that  this time, the execution
has followed the left path in the diagram, instead of the right one.

A few more `ni`, and you should get this message:

    Checking License: my-key

It's caused by the instruction at the address `1bc`.
We can infer that `MSG2` is this "Checking License" message.

A few more `ni`, and you should get this message:

    WRONG!

It's caused by the instruction at the address `1f4`.
We can infer that `MSG3` is this "WRONG!" message.

This happens right after  the jump from `1dd` to `1ed`,  which is performed when
the comparison between 2 strings fails.

We can  infer that the  compared strings  are the key  which we provided  on the
GDB's command-line, and the valid key hard-coded inside the compiled program.

#
# finally, crack the key

The path leading  to the "WRONG!" message (`MSG3` in  our diagram) is determined
by the result of the previous test which is:

    1db  test  eax

Let's put a breakpoint right before:

    (gdb) break *0x00000000004011db

To  type the  address of  the  `test` instruction  more easily,  you can  re-run
`disassemble main`, select the address with the mouse:

    0x00000000004011db <+82>:    test   eax,eax
    ^----------------^

and press the mouse wheel.
Alternatively  you could  use a  byte  offset (computed  from the  start of  the
function) as printed in the output of `disassemble main`:

    (gdb) break *main+101
                     ^--^

Next, re-start the program:

    (gdb) run my-key

The execution  might stop  at the  first breakpoint,  which is  at the  start of
`main()`.  We don't care about what happens when `main()` starts, so skip to the
next interesting breakpoint:

    (gdb) continue

The execution should stop at the breakpoint right before the `test`.
At that moment, inspect the values held by the registers:

    (gdb) info registers

In the output, there is no line for the `eax` register.
That's because `eax`  actually refers to the  first 32 bits of  the 64-bit `rax`
register.  So, look  for a line starting with `rax`.   You should find something
like this:

    rax            0x2c                44

We can see that its value is `2c` in hexadecimal, which can be converted to `44`
in decimal.  It's not equal to 0, which is why the next `jne` instruction causes
the execution to follow the path on the right to the "WRONG!" message (`MSG3` in
our diagram).

We don't want  that.  Let's try to  make the execution follow  another path; the
one on the left (that's the only other possible path in our diagram anyway).

To achieve this, we need to reverse the test result.
As of right now, the test is going to fail.
To make it pass, we need `rax` to hold the value 0:

    (gdb) set $rax = 0

Let's make sure we've reset `rax`:

    (gdb) info registers rax

If it worked, you should get:

    rax            0x0                 0

Finally, run `ni` a few more times.
You should notice  that this time, the  execution follows the path  on the left,
and you should get the message "Access Granted!".

## But I don't want to rely on GDB to bypass the check.  I just want the key!

Put a breakpoint  right before the call to `strcmp()`,  which is responsible for
checking the  validity of  the given  key, and  inspect the  values held  by the
registers at that time.  Hopefully, one of them is the valid key.

Delete all the breakpoints:

    (gdb) delete breakpoints

Find the address of the call to `strcmp()`:

    (gdb) disassemble main
    ...
    0x00000000004011d6 <+96>:    call   0x401080 <strcmp@plt>
    ^----------------^
    ...

Put a breakpoint on it:

    (gdb) break *0x00000000004011d6
    # alternative:
    #     break *main+96

(Re)Start the program and give it a key:

    (gdb) run my-key

At the breakpoint, inspect the registers:

    (gdb) info registers
    rax            0x7fffffffcdef      140737488342511
    rbx            0x401200            4198912
    rcx            0x0                 0
    rdx            0x0                 0
    rsi            0x402027            4202535
    rdi            0x7fffffffcdef      140737488342511
    rbp            0x7fffffffc6d0      0x7fffffffc6d0
    rsp            0x7fffffffc6c0      0x7fffffffc6c0
    r8             0x0                 0
    r9             0x19                25
    r10            0x402025            4202533
    r11            0x246               582
    r12            0x401090            4198544
    r13            0x7fffffffc7c0      140737488340928
    r14            0x0                 0
    r15            0x0                 0
    rip            0x4011d6            0x4011d6 <main+96>
    eflags         0x212               [ AF IF ]
    cs             0x33                51
    ss             0x2b                43
    ds             0x0                 0
    es             0x0                 0
    fs             0x0                 0
    gs             0x0                 0

You can ignore all the `0x0`  lines; they don't refer to anything (uninitialized
addresses?).   You can  also ignore  `rip` (instruction  pointer), and  `eflags`
(flags register).  The remaining registers are:

    rax            0x7fffffffcdef      140737488342511
    rbx            0x401200            4198912
    rsi            0x402027            4202535
    rdi            0x7fffffffcdef      140737488342511
    rbp            0x7fffffffc6d0      0x7fffffffc6d0
    rsp            0x7fffffffc6c0      0x7fffffffc6c0
    r9             0x19                25
    r10            0x402025            4202533
    r11            0x246               582
    r12            0x401090            4198544
    r13            0x7fffffffc7c0      140737488340928
    cs             0x33                51
    ss             0x2b                43

We can examine the value of any register with the `x` command.
And to print it as a string, we can use the `/s` format:

    (gdb) help x
    Examine memory: x/FMT ADDRESS.
    ADDRESS is an expression for the memory address to examine.
    FMT is a repeat count followed by a format letter and a size letter.
    Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),
      t(binary), f(float), a(address), i(instruction), c(char), s(string)
      and z(hex, zero padded on the left).
    ...

Let's use `x/s` to examine the value held by each of the remaining registers:

    (gdb) x/s $rax
    0x...: "my-key"

That's not the valid key.  Let's try the next register:

    (gdb) x/s $rbx
    0x... <__libc_csu_init>:     "\363\017\036\372AWL\215=\003,"

This doesn't look like a key which is meant to be typed interactively.
Let's try the next register:

    (gdb) x/s $rsi
    0x...: "AAAA-Z10N-42-OK"
            ^-------------^

That does look like a key.

Let's check whether it works:

    (gdb) quit
    $ build/license_1 AAAA-Z10N-42-OK
    Checking License: AAAA-Z10N-42-OK
    Access Granted!

It does.

---

To prevent you from reading the key in such a way, the program could compare the
hash of the keys, instead of the keys themselves.  The hash of a key is obtained
via a function (e.g. SHA-256), which should have a few properties:

   - it's easy to compute the hash of a key

   - it's practically impossible to reverse a key from its hash

   - it's unlikely to produce the same hash for 2 different keys
     (the collision risk is low)

So, for  example, instead of comparing  the given key to  "AAAA-Z10N-42-OK", the
program could compare the hash of the given key to:

    7e30795e58fe7c2e8a29e2b09d86ff07199c5b6458637eb13bee458ace40b128

Which can be easily computed:

    $ sha256sum <<<'AAAA-Z10N-42-OK'
    7e30795e58fe7c2e8a29e2b09d86ff07199c5b6458637eb13bee458ace40b128  -

But it's practically impossible to guess the key from this hash.

In  contrast, changing  a register  (like  we did  when  we've set  `rax` to  0)
circumvents any encryption.

#
# Useful links

To practice more, and crack other programs, visit: <https://crackmes.one/>

To install tools specialized to disassemble binaries, try one of these:

   - <https://github.com/NationalSecurityAgency/ghidra>
   - <https://github.com/radareorg/radare2>

Among other things, they can help you draw a diagram like the one before.

##
# Reference

[1]: https://en.wikipedia.org/wiki/TEST_(x86_instruction)
[2]: https://en.wikipedia.org/wiki/Function_prologue_and_epilogue
