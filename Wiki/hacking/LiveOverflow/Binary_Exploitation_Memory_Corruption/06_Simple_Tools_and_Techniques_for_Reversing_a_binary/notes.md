<https://www.youtube.com/watch?v=3NTXFUxcKPc>

# `objdump(1)`
## get info about the stack

    $ cd LiveOverflow/Binary_Exploitation_Memory_Corruption/05_Reversing_and_Cracking_first_simple_Program/
    $ objdump --all-headers build/license_1 | grep --after-context=1 STACK
    STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
          filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
                                                                     ^

This shows that the  stack is not executable, which will  be interesting once we
study classic buffer overflows.

## `.text` section

The `.text` section is where the program code lives in memory:

    $ objdump --all-headers build/license_1 | grep --after-context=1 '^Sections:\|^ \+[0-9]\+ \+\.text'
    Sections:
    Idx Name          Size      VMA               LMA               File off  Algn
    --
     14 .text         000001e5  0000000000401090  0000000000401090  00001090  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE

Here, our code starts at the address  `0x401090`; and its size is `0x1e5` bytes,
meaning it ends at `0x401275`.

If you  run the compiled  binary with  GDB, and execute  `disassemble main`, you
should find  that the assembly instructions  are stored in a  range of addresses
which is compatible with the previous output:

    0x401176 <+0>:     endbr64
    ....
    0x4011ff <+137>:   ret

Here,  the first  and  last  instructions of  `main()`  live  at `0x401176`  and
`0x401ff`, which are both between `0x40190` and `0x401275`.  This shows that all
of `main()` lives in the `.text` section.

## `.rodata` section

The `.rodata` section  (Read-Only DATA) is where the program  can find some data
to read at runtime:

    $ objdump --all-headers build/license_1 | grep --after-context=1 '^Sections:\|^ \+[0-9]\+ \+\.rodata'
    Sections:
    Idx Name          Size      VMA               LMA               File off  Algn
    --
     16 .rodata       0000004e  0000000000402000  0000000000402000  00002000  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, DATA

Here, the `.rodata` section starts at  `0x402000`; and its size is `0x4e` bytes,
meaning it ends at `0x40204e`.

If you run the  compiled binary with GDB, stop the execution  before the call to
`strcmp()`, and inspect  the contents of the registers, you  should see that one
of them lives at an address inside this `.rodata` section.

    (gdb) break *main+96
    (gdb) run my-key
    (gdb) info registers rsi
    rsi            0x402027            4202535

Here, the  `rsi` register lives  at `0x402027`  which is between  `0x402000` and
`0x40204e`; i.e.  inside the `.rodata`  section.  This is  a clue that  it might
contain our key; we can inspect its contents by executing `x/s $rsi`:

    (gdb) x/s $rsi
    0x...:       "AAAA-Z10N-42-OK"

Or `x/s 0x402027`:

    (gdb) x/s 0x402027
    0x...:       "AAAA-Z10N-42-OK"

##
# `radare2(1)`
## open the `license_1` binary

    $ radare2 build/license_1
    [0x00401090]>
     ^--------^

Notice that the address  in the prompt matches the start  of the `.text` section
given in the output of `objdump(1)`.

## analyze all referenced code

             vvv
    [0x...]> aaa
    [x] Analyze all flags starting with sym. and entry0 (aa)
    [x] Analyze all functions arguments/locals
    [x] Analyze function calls (aac)
    [x] Analyze len bytes of instructions for references (aar)
    [x] Finding and parsing C++ vtables (avrr)
    [x] Type matching analysis for all functions (aaft)
    [x] Propagate noreturn information (aanr)
    [x] Use -AA or aaaa to perform additional experimental analysis.

## list all found functions

             vvv
    [0x...]> afl
    0x...    1 46           entry0
    0x...    4 33   -> 31   sym.deregister_tm_clones
    0x...    4 49           sym.register_tm_clones
    0x...    3 33   -> 32   sym.__do_global_dtors_aux
    0x...    1 6            entry.init0
    0x...    1 5            sym.__libc_csu_fini
    0x...    1 13           sym._fini
    0x...    4 101          sym.__libc_csu_init
    0x...    1 5            sym._dl_relocate_static_pie
    0x...    7 138          main
    0x...    3 27           sym._init
    0x...    1 11           sym.imp.puts
    0x...    1 11           sym.imp.printf
    0x...    1 11           sym.imp.strcmp

Notice the `main()` function in the middle:

    0x...    7 138          main

## seek to the start of `main()`

                  v----v
    [0x00401090]> s main
    [0x00401176]>
     ^--------^

Notice that  the address  in the  prompt has  changed; it's  now located  at the
very  start  of  `main()` (and  matches  the  first  address  in the  output  of
`disassemble main` in GDB).

## print disassembly of main()

             vvv
    [0x...]> pdf
                ; DATA XREF from entry0 @ 0x4010b1(r)
    ┌ 138: int main (uint32_t argc, char **argv);
    │           ; arg uint32_t argc @ rdi
    │           ; arg char **argv @ rsi
    │           ; var uint32_t var_4h @ rbp-0x4
    │           ; var char **s1 @ rbp-0x10
    │           0x00401176      f30f1efa       endbr64
    │           0x0040117a      55             push rbp
    │           0x0040117b      4889e5         mov rbp, rsp
    │           0x0040117e      4883ec10       sub rsp, 0x10
    │           0x00401182      897dfc         mov dword [var_4h], edi     ; argc
    │           0x00401185      488975f0       mov qword [s1], rsi         ; argv
    │           0x00401189      837dfc02       cmp dword [var_4h], 2
    │       ┌─< 0x0040118d      7413           je 0x4011a2
    │       │   0x0040118f      488d3d6e0e00.  lea rdi, str.Usage:__key_   ; 0x402004 ; "Usage: <key>" ; const char *s
    │       │   0x00401196      e8c5feffff     call sym.imp.puts           ; int puts(const char *s)
    │       │   0x0040119b      b801000000     mov eax, 1
    │      ┌──< 0x004011a0      eb5c           jmp 0x4011fe
    │      ││   ; CODE XREF from main @ 0x40118d(x)
    │      │└─> 0x004011a2      488b45f0       mov rax, qword [s1]
    │      │    0x004011a6      4883c008       add rax, 8
    │      │    0x004011aa      488b00         mov rax, qword [rax]
    │      │    0x004011ad      4889c6         mov rsi, rax
    │      │    0x004011b0      488d3d5a0e00.  lea rdi, str.Checking_License:__s_n ; 0x402011 ; "Checking License: %s\n" ; const char *format
    │      │    0x004011b7      b800000000     mov eax, 0
    │      │    0x004011bc      e8affeffff     call sym.imp.printf         ; int printf(const char *format)
    │      │    0x004011c1      488b45f0       mov rax, qword [s1]
    │      │    0x004011c5      4883c008       add rax, 8
    │      │    0x004011c9      488b00         mov rax, qword [rax]
    │      │    0x004011cc      488d35540e00.  lea rsi, str.AAAA_Z10N_42_OK ; 0x402027 ; "AAAA-Z10N-42-OK" ; const char *s2
    │      │    0x004011d3      4889c7         mov rdi, rax                ; const char *s1
    │      │    0x004011d6      e8a5feffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)
    │      │    0x004011db      85c0           test eax, eax
    │      │┌─< 0x004011dd      750e           jne 0x4011ed
    │      ││   0x004011df      488d3d510e00.  lea rdi, str.Access_Granted_ ; 0x402037 ; "Access Granted!" ; const char *s
    │      ││   0x004011e6      e875feffff     call sym.imp.puts           ; int puts(const char *s)
    │     ┌───< 0x004011eb      eb0c           jmp 0x4011f9
    │     │││   ; CODE XREF from main @ 0x4011dd(x)
    │     ││└─> 0x004011ed      488d3d530e00.  lea rdi, str.WRONG_         ; 0x402047 ; "WRONG!" ; const char *s
    │     ││    0x004011f4      e867feffff     call sym.imp.puts           ; int puts(const char *s)
    │     ││    ; CODE XREF from main @ 0x4011eb(x)
    │     └───> 0x004011f9      b800000000     mov eax, 0
    │      │    ; CODE XREF from main @ 0x4011a0(x)
    │      └──> 0x004011fe      c9             leave
    └           0x004011ff      c3             ret

Notice the arrows which  tell you where branches go to, as  well as the comments
(starting with  a semicolon) which  include strings  that are referenced  in the
code.

## print a control-graph view of main()

    [0x...]> VV

`VV` makes you enter graph mode.
Press `?` to toggle a help window listing all the keys you can press to interact
with the graph (see also `Wiki/cheatkeys/radare2`).

---

To make the graph more readable, you might need to change the color theme.
Run:

   - `eco` to list the builtin themes
   - `eco <my theme>` to select one out of the previous list
   - `!echo 'eco <my theme>' >>~/.config/radare2/radare2rc` to make the setting
     persistent

##
## restart a new session in debug mode

    $ radare2 -d build/license_1
              ^^

## add a breakpoint on the first instruction inside `main()`

    [0x...]> s main

    [0x00401176]> db 0x00401176
     ^--------^      ^--------^
     copy the address from the prompt

## continue execution until breakpoint

             vv
    [0x...]> dc
    hit breakpoint at: 0x401176

## print a control-graph view of main()

    [0x00401176]> aaa
    [0x00401176]> VV

Note that – in graph mode – you can run any command (like the previous `dc`)
by pressing `:`, writing your command, then pressing Enter.
To  quit  the  command-line,  simply  press  Enter  a  second  time  (while  the
command-line is empty).

## step over the instructions by pressing `S`

`s` would  step into them, which  might not be what  you want (e.g. if  the next
instruction is a function call, you might not want to step into the instructions
that it executes).

Inside the boxes (aka nodes), look for this line:

    ;-- rip:

It  shows where  the instruction  pointer currently  points to  (i.e. where  the
execution is).

If you go too far, run `ood` to restart a new debugging session without quitting
`radare2(1)`.  The breakpoint will be preserved (no need to re-install it).

##
# Pitfalls
## What you wrote about `objdump(1)` and `ltrace(1)` doesn't work!

Make sure to compile the binary with `-no-pie`:

    $ gcc license_1.c -o build/license_1 -no-pie
                                         ^-----^

See here for more info:
- <https://stackoverflow.com/a/30426603>
- <https://stackoverflow.com/a/5030518>
