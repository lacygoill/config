vim9script

# Why using this file instead of `ftdetect/`?{{{
#
# Because it's sourced BEFORE `$VIMRUNTIME/filetype.vim`.
# Our  autocmds   will  match  first,   and  because  the  other   autocmds  use
# `:setfiletype`, they won't re-set 'filetype'.
#
# This way, we make sure that, for  the files whose path match the patterns used
# in the following autocmds, our 'filetype' value has priority, and the filetype
# will be set only once (not twice).
#
# For more info about the syntax of this file, see `:help ftdetect`.
#}}}
# If I wanted to use `ftdetect/`, how would I procede?{{{
#
# To change the detection of the filetype of a file, you could use:
#
#     ~/.vim/ftdetect
#
# In  this folder,  you  would have  to  create (by  convention?)  one file  per
# filetype / autocmd.
#
# Example:
#
#     $ vim ~/.vim/ftdetect/notes.vim
#       autocmd BufRead $HOME/{Wiki/,.wiki/}* setfiletype markdown
#
# No need for an augroup, Vim would wrap the autocmd automatically.
# No need to move the file in an `after/` subdirectory, Vim will look for
# files in `~/.vim/ftdetect` AFTER `$VIMRUNTIME/filetype.vim`.
#}}}

if exists('did_load_filetypes')
    finish
endif

augroup filetypedetect
    # TODO: Should we try to detect the filetype of the original file when running `sudoedit(8)`?
    #     autocmd! BufRead,BufNewFile /var/tmp/* {
    #         execute $'doautocmd filetypedetect BufReadPost {expand('<afile>:t')}'
    #     }

    # apparmor
    autocmd! BufNewFile,BufRead /etc/apparmor.d/*,/usr/share/apparmor/extra-profiles/* setfiletype apparmor

    # conf
    # Most files under `~/.config` should be `conf` files.
    autocmd! BufRead,BufNewFile $HOME/.config/* {
        # Ignore binary files.{{{
        #
        # You can find all of them with:
        #
        #     $ grep -rIL . ~/.config/
        #
        # `-L` changes the output.
        # Instead of  printing the  location of each  match, `grep(1)`  now only
        # prints the  names of files  which don't  match the pattern  (here `.`;
        # i.e. any character).
        # By itself,  it would cause  the names of all  the regular files  to be
        # printed.  But combined  with `-I`, the opposite happens:  the names of
        # all binary files are printed.
        #
        # ---
        #
        # Note that the output might contain a few false positives.
        # For example, if you have a text file with a NUL, it will be considered
        # as a binary file.
        #}}}
        # Also ignore a file with an extension.{{{
        #
        # If it  has an extension, its  filetype will probably be  correctly set
        # later by an autocmd.
        #
        # We especially don't want to set  the filetype of a markdown file (with
        # a `.md` extension) to `conf`; our indent plugin could then wrongly set
        # `'shiftwidth'`, which  would not be  fixed later when the  filetype is
        # reset to `markdown`.
        #}}}
        if search('\%x00') == 0 && expand('%:e') == ''
            # `FALLBACK` to let a more accurate detection reset the filetype later.
            setfiletype FALLBACK conf
        endif
    }

    # gitignore
    autocmd BufNewFile,BufRead $HOME/.cfg-info-exclude,$HOME/.cvsignore setfiletype gitignore

    # help
    # Useful when we read help files from an uninstalled Vim plugin.
    autocmd! BufRead,BufNewFile */*vim*/doc/*.txt setfiletype help

    # Some files are wrongly detected with some given filetype, even though we
    # don't know  what they  really contain.   Let's fix  that by  setting the
    # filetype to `text`, which is the most generic value I can think of.
    # .inc: included file {{{
    #
    # Most of the time, Vim sets the filetype of `.inc` files to `pov`.
    # I guess it considers them to have been generated by the POV-Ray software:
    # https://fileinfo.com/extension/pov
    #
    # I have 73 files at the moment with this extension:
    #
    #     $ vim $(locate --regex '\.inc(\.gz)?$')
    #     :silent argdo unsilent echomsg &filetype
    #
    # Most of them are detected as pov files.
    # 3 of them are detected as pascal files.
    # But in reality, none of them has a contents matching a pov or pascal file.
    # Sometimes, they just seem to contain some data; other times, some code.
    # But there is no consistency.
    #
    # An `.inc` file can contain anything:
    #
    #    > Text  file  containing declarations,  headers,  functions,  or other  data
    #    > referenced by  a program's source  code; can  be used with  C/C++, Pascal,
    #    > Java, PHP (Web pages), and other languages.
    #
    # Source: https://fileinfo.com/extension/inc
    #
    # So, there is no point in highlighting it in any particular way.
    #}}}
    # .lst: list of data {{{
    #
    # Most of the time, Vim assumes  that an `.lst` file contains assembly code,
    # and sets  the filetype  to `asm`.  ATM,  on my machine,  I have  37 `.lst`
    # files:
    #
    #     $ locate '*.lst' | wc --lines
    #     37
    #
    # Not one  of them  contains assembly  code.  They're  just random  lists of
    # data:
    #
    #    > A file with  an .lst extension is most likely a text  file that contains a
    #    > list  of data. LST  files are  used  by many  different programs,  including
    #    > Microsoft Visual Studio and various text editors.
    #
    # Source: https://fileinfo.com/extension/lst
    #}}}
    autocmd! BufRead,BufNewFile *.{inc,lst} setfiletype text

    # nfo (useful for `~/.vim/after/ftplugin/nfo.vim` to be sourced)
    autocmd! BufRead,BufNewFile *.nfo,*.NFO setfiletype nfo

    # `README` files{{{
    #
    # Useful, for example, to prevent this file from being wrongly detected as
    # a `diff` file: `/usr/share/doc/git/contrib/diff-highlight/README`.
    #}}}
    autocmd! BufRead,BufNewFile README setfiletype text

    # `man redshift /CONFIGURATION FILE`:{{{
    #
    #    > A configuration file with the  name  redshift.conf  can  optionally  be
    #    > placed in ~/.config/. The file has standard INI format.
    #}}}
    autocmd! BufRead,BufNewFile redshift.conf setfiletype toml

    # SSH `known_hosts` files
    # The `.known_hosts` file extension is not documented.{{{
    #
    # But  it might  still be  useful when  you generate  a `known_hosts`  via
    # `ssh-keyscan(1)`:
    #
    #     $ ssh-keyscan <host> >myserver.known_hosts
    #                                   ^----------^
    #}}}
    autocmd! BufNewFile,BufRead ~/.ssh/known_hosts{,.old},*.known_hosts setfiletype knownhosts
    autocmd! BufNewFile,BufRead /etc/ssh/ssh_known_hosts setfiletype knownhosts
    # SSH `authorized_keys` files
    # `*.pub` files usually store public keys; thus, they use a *subset* of the `authorized_keys` syntax.{{{
    #
    # For example:
    #
    #     # user authentication keys
    #     ~/.ssh/id_*.pub
    #     ~/.ssh/task-*.pub
    #
    #     # host keys
    #     /etc/ssh/*ssh_host_*.pub
    #              ^
    #              possible date
    #
    #     # list of trusted user certificate authorities on server machine
    #     /etc/ssh/user-ca-keys.pub
    #
    #     # host/user certificate authorities on CA machine
    #     /usr/local/sshca/hosts/host-ca-key.pub
    #     /usr/local/sshca/users/user-ca-key.pub
    #
    # The only  difference with  `authorized_keys` is  the absence  of options
    # like `restrict`, `command`, `from`, ... Most of those file locations are
    # not standardized/documented;  they're just useful  conventions.  Anyway,
    # it's useful to  detect `*.pub` files as `authorized_keys`  files, to get
    # syntax highlighting.
    #}}}
    autocmd! BufNewFile,BufRead ~/.ssh/authorized_keys,*.pub setfiletype authorizedkeys
    # Same thing for `/etc/ssh/revoked-{host,user}-keys`.
    # They are not standard documented files.{{{
    #
    # But we might use them to store lists of revoked host/user keys. `ssh(1)`
    # and `sshd(8)` pick them up via `RevokedHostKeys` and `RevokedKeys`.
    #}}}
    autocmd! BufNewFile,BufRead /etc/ssh/revoked-{host,user}-keys setfiletype authorizedkeys

    # Debian package changelog{{{
    #
    #     $ apt changelog transmission-daemon
    #     # press E to pipe `less(1)` buffer to Vim
    #
    # Note that  we don't  inspect the  contents of the  buffer (not  sure the
    # latter is sufficiently structured to be reliably detected).  Instead, we
    # look for an `apt(8)` process in the ancestor of the current Vim process;
    # and if we find one, we make  sure it was invoked with `changelog` as one
    # of its arguments.
    #}}}
    autocmd! StdinReadPost * timer_start(0, (_) => SetChangeLogFileType())
    def SetChangeLogFileType()
        silent var pstree: string = systemlist('pstree --long --show-parents --show-pids ' .. getpid())
            ->get(0, '')
        var apt_cmd: string = 'apt\%(-get\|itude\)\='

        if pstree !~ $'-{apt_cmd}(\d\+)-'
            return
        endif

        var apt_PID: string = pstree
            ->matchstr($'-{apt_cmd}(\zs\d\+\ze)-')
        var apt_cmdline: string = $'/proc/{apt_PID}/cmdline'
            ->readfile('', 1)
            ->get(0, '')
        if apt_cmdline->split()->index('changelog') >= 0
            setfiletype changelog
        endif
    enddef
augroup END
