vim9script

var RerunFixedCmd: func
var more_save: bool

export def Chain() #{{{1
    var cmdline: string = getcmdline()

    # The boolean flag controls the `'more'` option.
    var pat2cmd: dict<list<any>> = {
        '\%(g\|v\)\%[lobal]\>.*\%(#\@1<!#\|nu\%[mber]\)': ['', false],
        '\%(ls\|files\|buffers\)!\=': ['b ', false],
        'chi\%[story]': ["chi \<C-B>", true],
        'lhi\%[story]': ["lhi \<C-B>", true],
        'marks':        ['normal! `', true],
        'old\%[files]': ['edit #<', true],
        'undol\%[ist]': ['undo ', true],
        'changes':      ["normal! g;\<S-Left>", true],
        'ju\%[mps]':    ["normal! \<C-O>\<S-Left>", true],
    }

    for [pat: string, cmd: list<any>] in pat2cmd->items()
        var keys: string
        var nomore: bool
        [keys, nomore] = cmd
        if cmdline =~ '\C^' .. pat .. '$'
            # when I  execute `:[cl]chistory`,  don't populate the  command-line with
            # `:silent [cl]older` if the qf stack doesn't have at least two qf lists
            if pat == 'lhi\%[story]' && getloclist(0, {nr: '$'})->get('nr', 0) <= 1
            || pat == 'chi\%[story]' && getqflist({nr: '$'})->get('nr', 0) <= 1
                return
            endif
            var pfx: string
            if pat == 'chi\%[story]'
                pfx = 'c'
            elseif pat == 'lhi\%[story]'
                pfx = 'l'
            endif
            if pfx != ''
                if pfx == 'c' && getqflist({nr: '$'})->get('nr', 0) <= 1
                || pfx == 'l' && getloclist(0, {nr: '$'})->get('nr', 0) <= 1
                    return
                endif
            endif
            # Why disabling `'more'` for some commands?{{{
            #
            #    > The lists generated by :#, :ls, :ilist, :dlist, :clist, :llist, or
            #    > :marks  are  relatively  short  but  those  generated  by  :jumps,
            #    > :oldfiles,  or  :changes  can  be   100  lines  long  and  require
            #    > paging. This can be really cumbersome, especially considering that
            #    > the  most recent  items are  near the  end of  the list. For  this
            #    > reason,  I chose  to  temporarily  :set nomore  in  order to  jump
            #    > directly to the end  of the list.
            #
            # Source: https://gist.github.com/romainl/047aca21e338df7ccf771f96858edb86#generalizing
            #}}}
            if nomore
                more_save = &more
                # allow Vim's pager to display the full contents of any command,
                # even if it takes more than one screen; don't stop after the first
                # screen to display the message:    -- More --
                &more = false
                autocmd CmdlineLeave * ++once {
                    if more_save
                        &more = true
                    else
                        &more = false
                    endif
                }
            endif
            feedkeys(':' .. keys, 'in')
            return
        endif
    endfor

    if cmdline =~ '\C^\s*\%(dli\|il\)\%[ist]\s\+'
        feedkeys(':'
            .. cmdline->matchstr('\S') .. 'j  '
            .. cmdline->split(' ')[1] .. "\<S-Left>\<Left>", 'in')
    elseif cmdline =~ '\C^\s*\%(cli\|lli\)'
        feedkeys(':silent ' .. cmdline->matchstr('\S')->repeat(2) .. ' ', 'in')
    endif
enddef

export def FixTypo(label: string) #{{{1
    var cmdline: string = getcmdline()
    var keys: string = {
          cr: "\<BS>\<CR>",
          z: "\<BS>\<BS>()\<CR>",
        }[label]
    # We can't send the keys right now, because the command hasn't been executed yet.{{{
    #
    # From `:help CmdlineLeave`:
    #
    #    > Before leaving the command-line.
    #
    # But it seems we can't modify the command either.  Maybe it's locked.
    # So, we'll reexecute a new fixed command with a little later.
    #}}}
    RerunFixedCmd = () => feedkeys(':' .. cmdline .. keys, 'in')
    #                                     │{{{
    #                                     └ do *not* replace this with `getcmdline()`:
    #                                       when the callback will be processed,
    #                                       the old command-line will be lost
    #}}}
    autocmd SafeState * ++once RerunFixedCmd()
enddef

export def HitEnterPromptNoRecording() #{{{1
    # if we press `q`, just remove the mapping{{{
    #
    # No  need to  press sth  like  `Esc`; when  the mapping  is processed,  the
    # hit-enter prompt  has already been  closed automatically.  It's  closed no
    # matter which key you press.
    #}}}
    nnoremap q <ScriptCmd>silent! nunmap q<CR>
    # if we escape the prompt without pressing `q`, make sure the mapping is still removed
    autocmd SafeState * ++once silent! nunmap q
enddef

export def Vim9Abbrev(): string #{{{1
    if getcmdtype() != ':'
        return 'V'
    endif

    var cmdline: string = getcmdline()
    var pos: number = getcmdpos()
    var before_cursor: string = cmdline->matchstr('.*\%' .. pos .. 'c')
    # expand `V` into `vim9` at the start of a line
    if before_cursor == 'V'
            # and after a bar
            || before_cursor =~ '|\s*V$'
        return 'vim9'
    endif

    return 'V'
enddef
