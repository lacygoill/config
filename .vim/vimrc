vim9script noclear

if !has('vim_starting') | finish | endif

# Plugins {{{1

# We never use these plugins:{{{
#
#    - getscript
#    - logipat
#    - vimball
#
# The less code,  the fewer bugs.  Besides, they install  some custom commands
# which pollute tab completion on the command-line.
#}}}
g:loaded_getscriptPlugin = true
g:loaded_logiPat = true

# interface + autoload
g:loaded_vimballPlugin = true
g:loaded_vimball = true

# How to disable netrw?{{{
#
#     # no interface
#     g:loaded_netrwPlugin = true
#
#     # no autoload/
#     g:loaded_netrw = true
#
# See `:help netrw-noload`.
#}}}
#   Why would it be a bad idea?{{{
#
# Some third-party plugins might rely on netrw,  and I don't want to lose time
# debugging them.
#
# netrw also lets you edit a remote file located at an arbitrary url.
#
# For example, if you press `<C-w>f` on this url:
# https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-demo.txt
#
# It will open the `UTF-8-demo.txt` file in a new split.
#}}}

&packpath = $'{$HOME}/.vim,{$VIMRUNTIME}'

# third-party code = vendor
# https://softwareengineering.stackexchange.com/a/123320
export const VENDOR: list<string> =<< trim END
    matchit
    helptoc
    ultisnips
    undotree
    unicode.vim
    vim-sandwich
END
{
    for pack: string in VENDOR
        execute $'packadd! {pack}'
    endfor
}

# Do *not* append a trailing slash to a path added in the runtimepath.{{{
#
# First, it's not necessary.
#
# Second, it can cause a weird path to be printed in a message.
# For example,  if you execute  the normal `zg` command  on the word  "ebook" to
# include it in a list of good words, you might read this message:
#
#     Word 'ebook' added to ~/.vim//spell/en.utf-8.add
#                                 ^^
#                                 not a bug, but still confusing
#}}}

# some plugins might rely on `fzf#run()` and/or `fzf#wrap()` (e.g. vim-unicode)
set runtimepath^=~/.fzf
# Let's make sure `~/.vim` remains at the front.{{{
#
# This notably matters when executing the `zg` command.
#
#                                       v--v                                        vv
#     $ vim -Nu NONE +'set runtimepath^=/tmp | call setline(1, "ebook") | normal! zGzg'
#     Word 'ebook' added to /tmp/en.utf-8.add
#                           ^--^
#}}}
set runtimepath^=~/.vim

# TODO: Should we rename all our plugins to include the prefix `vim-`?
#
# Rationale: It would make  it easier to find  a file in one of  them (e.g. when
# pressing `C-g es`), especially when they have a very common name (e.g. `vim`).

# TODO: Read your Vim notes about packages.
# Look for the keyword `package`.
# Check whether we wrote sth wrong.
# Finish them.
# Use whatever info you learn to improve our setup.

# Warning: Don't put each plugin into its own package.{{{
#
# The more packages it has too look into, the slower `:packadd` gets.
# Right now, we put all our plugins into 2 packages:
#
#    - vendor
#    - mine
#
# The first is for third-party plugins.
# The second is for our own plugins.
#
# If we  moved every plugin  into its own  package, all the  `:packadd` commands
# would increase Vim's startup time by several dozens of milliseconds.
#}}}
# Warning: Don't put your plugins under `start/`.  Keep them optional.{{{
#
# Plugins under `start/` make Vim much harder to debug.
# There's no easy way to temporarily disable any of them.
# Besides, they're still loaded when you start Vim with `vim -Nu NORC`.
#
# In  contrast, you  *can*  temporarily  disable an  optional  plugin simply  by
# commenting out the matching `:packadd`.
#}}}

# libraries
packadd! lg-lib
packadd! repeat
packadd! submode

packadd! awk
packadd! bash
packadd! brackets
packadd! breakdown
packadd! bullet-list
packadd! capslock
packadd! cheatkeys
packadd! cmdline
packadd! column-object
# The underscore is necessary to avoid a conflict with `$VIMRUNTIME/pack/dist/opt/comment`.
packadd! _comment
packadd! completion
packadd! cwd
packadd! dbg
packadd! dirvish
packadd! doc
packadd! draw
packadd! easy-align
packadd! exchange
packadd! fex
packadd! fish-shell
packadd! fold
packadd! fz
packadd! git
packadd! goyo
packadd! grep
packadd! gx
packadd! help
packadd! iabbrev
packadd! interactive-lists
packadd! limelight
packadd! logevents
packadd! lua
packadd! man
packadd! markdown
packadd! math
packadd! mermaid
packadd! movesel
packadd! navi
packadd! par
packadd! python
packadd! qf
packadd! quickhl
packadd! readline
packadd! reorder
packadd! save
packadd! scriptease
packadd! search
packadd! seoul
packadd! session
packadd! sneak
packadd! snippets
packadd! source
packadd! stacktrace
packadd! statusline
packadd! switch
packadd! systemd
packadd! terminal
packadd! tmux
packadd! tradewinds
packadd! unichar
packadd! unix
packadd! vim
packadd! vim9-syntax
packadd! vim9asm
packadd! weechat
packadd! window

# Some functions installing an interface are  too slow to be called during Vim's
# startup.  We delay them.
def DelaySlowCall()
    autocmd! DelaySlowCall
    augroup! DelaySlowCall

    packadd toggleSettings
    packadd slowCall
enddef

var delay_slow_call_events: list<string> =<< trim END
    CursorHold
    InsertEnter
    WinEnter
    CmdWinEnter
    BufWritePost
    QuickFixCmdPost
    TextYankPost
    TextChanged
END
augroup DelaySlowCall
    autocmd!
    # Do *not* use a simple timer:{{{
    #
    #     autocmd VimEnter * timer_start(1'000, (_) =>
    #         \     execute(['packadd toggleSettings', 'packadd slowCall'])
    #         \ )
    #
    # It could cause issues, for example, if you enter insert mode quickly (i.e.
    # before  the  callback),  and  some  custom  code  of  yours  rely  on  the
    # lazy-loaded interface.
    #
    # If you  still have issues because  you execute some normal  command before
    # the lazy-loaded  interface has  been installed, maybe  try to  add another
    # event to the autocmd.
    #}}}
    # Before adding an event to the list, make sure it doesn't increase Vim's startup time.{{{
    #
    # In particular, avoid `SafeState`, `VimEnter`, `BufEnter`.
    #
    # ---
    #
    # When you check with `--startuptime`, don't make Vim execute `:quit` automatically:
    #
    #                                                  ✘
    #                                                v---v
    #     $ rm /tmp/log ; vim --startuptime /tmp/log +quit && vim /tmp/log
    #
    # It could give numbers which are much lower than what you'll experience.
    # It  depends on  the events  you  listen to;  e.g.  if you  only listen  to
    # `CursorMoved`,  the  numbers  are  much  lower  when  you  make  Vim  quit
    # automatically, compared to when you quit manually.
    #
    # So, make sure to quit manually:
    #
    #     $ rm /tmp/log ; vim --startuptime /tmp/log
    #     :quit
    #     $ vim /tmp/log
    #}}}
    execute $'autocmd {delay_slow_call_events->join(',')} * DelaySlowCall()'
    # Do *not* call the function when we enter debug mode.
    # It could give spurious errors when we debug Vim (`$ vim -D`).
    autocmd CmdlineEnter :,/,\?,@ DelaySlowCall()
augroup END

# Why this setting?{{{
#
# When we use the GUI, we don't want `$VIMRUNTIME/menu.vim` to be sourced.
# We won't use the menu.  It makes Vim start around 50ms slower.
#
# The default value is `aegimrLtT`.
# We could also let `'guioptions'` unchanged, and write this instead:
#
#     g:did_install_default_menus = 1
#     g:did_install_syntax_menu = 1
#
# In this case, we would keep the menu bar but avoid loading the default menus.
# For more info, see `:help menu.vim`.
#}}}
# Why here, and not with the other options?{{{
#
# From `:help 'go-M`:
#
#    > Note that  this flag  must be added  in the .vimrc  file, before  switching on
#    > syntax  or filetype  recognition (...;  the  `:syntax on`  and `:filetype  on`
#    > commands load the menu too). `:filetype on` and `:syntax on` source menu.vim.
#}}}
&guioptions = 'M'
# In the GUI, let us interrupt an external process by pressing `C-c`.{{{
#
# For more info, see:
# `:help go-!`
# https://github.com/vim/vim/issues/6565#issuecomment-665783322
#}}}
&guioptions ..= '!'

# Why setting these encoding options?{{{
#
# If for  some reason (shell environment),  `&encoding = latin1`, and  we use an
# exotic character in our vimrc, it will  give an error.  As an example, see the
# value we give to `'listchars'`.
# Note that  the real important option  to avoid an error  during startup, isn't
# `'termencoding'`, but `'encoding'`.
#}}}
#   OK, but why *before* `filetype on`?{{{
#
#    > But there's a real problem behind this:
#    > $VIMRUNTIME/filetype.vim may also source $VIMRUNTIME/menu.vim.
#    > And hence there comes surprising difference between putting :filetype on
#    > before :set encoding=xxx or after.
#
# Source: https://github.com/vim/vim/issues/8221#issuecomment-843497574
#
#    > As mentioned, if you change 'encoding' you need to do this very early,
#    > because it invalidates mappings and menus already defined.
#
# Source: https://github.com/vim/vim/issues/8221#issuecomment-843594001
#}}}

# Sets the character encoding used inside Vim.{{{
#
# It applies  to text in  the buffers,  registers, strings in  expressions, text
# stored in the viminfo file, etc.
# It sets the kind of characters which Vim can work with.
# It  also   automatically  enables   saner  encoding  detection   settings  for
# `'fileencodings'`: https://vi.stackexchange.com/a/17326/17449
#}}}
# To avoid errors, we could also write:{{{
#
#     scriptencoding utf-8
#
# This would tell Vim to convert the following lines in our vimrc to utf-8.
# But setting `'encoding'`  seems to have a broader scope,  and hence be better,
# as we  want every file sourced  after the vimrc  to be read using  the `utf-8`
# encoding (e.g.: filetype plugins).
#}}}
&encoding = 'utf-8'
# Encoding used for the terminal.  This specifies what character
# encoding the keyboard produces and the display will understand.
&termencoding = 'utf-8'

# Warning: Do *not* write any `:packadd!` after enabling the filetype detection!{{{
#
# If you load  a package with `:packadd!`  (notice the bang), and  if the latter
# contains  a `ftdetect/`  directory, its  autocmd(s) can  only be  installed by
# `:filetype on`.  From `:help :packadd /ftdetect`:
#
#    > Note that for ftdetect scripts to be loaded
#    > you will need to write `filetype plugin indent on`
#    > AFTER all `packadd!` commands.
#
# IOW, for  a custom filetype detection  to work, `:packadd!` must  have already
# updated the runtimepath when `:filetype on` is executed.  Afterward, it's too late.
#}}}
filetype plugin indent on
syntax on
#}}}1
# Imports {{{1

import 'lg.vim'
import 'lg/mapping.vim'
import 'lg/StyledComment.vim'

import autoload 'completion/filepath.vim'
import autoload 'repeat.vim' as Repeat
import autoload 'window/popup.vim'

# `silent!` to suppress annoying errors when we reduce the vimrc to find an MRE
silent! import autoload './autoload/myfuncs.vim'
silent! import autoload './autoload/vimhighlight.vim'

# Options {{{1
# Styled Comments {{{2

const STYLED_COMMENTS_FILETYPES: list<string> =<< trim END
    aptconf
    awk
    bash
    c
    cfg
    cheatkeys
    cmusrc
    conf
    confini
    css
    desktop
    dircolors
    dosini
    fish
    gdb
    gitconfig
    gitignore
    html
    kitty
    lua
    mailcap
    make
    navi
    netrc
    nroff
    puml
    python
    readline
    ruby
    rust
    sed
    sh
    snippets
    sshconfig
    sshdconfig
    sudoers
    sysctl
    systemd
    tex
    tmux
    toml
    vim
    weechat
    xdefaults
    xkb
    yaml
    zathurarc
END

# The position of this section is important.{{{
#
# It should be processed *after* the syntax mechanism has been enabled.
# That is, after `:syntax on` has been executed.
# Otherwise, the syntax elements it installs would be cleared.
#}}}
def StyledComments()
    augroup StyledComments
        autocmd!
        autocmd FileType * {
            if STYLED_COMMENTS_FILETYPES->index(expand('<amatch>')) >= 0
                StyledComment.Fold()
                StyledComment.UndoFtplugin()
            endif
        }
        autocmd Syntax * {
            if STYLED_COMMENTS_FILETYPES->index(expand('<amatch>')) >= 0
                StyledComment.Syntax()
            endif
        }
        # Purpose:{{{
        #
        # We (or  a plugin)  might temporarily  disable the  syntax highlighting
        # globally with `:syntax off`, then restore it with `:syntax on`.
        # In  that case,  the position  of the  autocmd which  installs the  default
        # syntax  groups is  moved *after*  our  custom autocmd  which installs  the
        # syntax groups related to comments.
        #
        # Because of this new order, the default autocmd undoes our custom one.
        # We need to re-install our custom autocmd *after* the default one.
        #}}}
        autocmd SourcePost $VIMRUNTIME/syntax/syntax.vim {
            StyledComments()
            for d: dict<any> in getwininfo()
                win_execute(d.winid, 'doautocmd StyledComments Syntax')
            endfor
        }
    augroup END
enddef
StyledComments()

# GUI {{{2

if has('gui_running')
    &guifont = 'DejaVu Sans Mono 20'
endif

# Environment {{{2

# TODO: We should probably remove this assignment.{{{
#
# To create *reliable* links inside a wiki, we should use tags:
# https://stackoverflow.com/q/25742396
#
# Indeed, with regular  links (filepaths), if we rename a  file, or change its
# location, we  need to refactor all  links toward the latter.   With tags, we
# would just need to re-generate the tags file.
#
# The goal would  be to have tags, like  in help files, on which  we can press
# `C-]` to automatically jump to an  arbitrary location inside the wiki.  This
# would  also let  us leverage  all built-in  commands/functions dedicated  to
# tags.
#
# See also:
#
# https://maximewack.com/post/tagbar/
# https://github.com/vimwiki/utils/blob/master/vwtags.py
# https://gist.github.com/MaximeWack/cdbdcd373d68d1fe5b3aca22e3dcfe46
# https://gist.github.com/MaximeWack/388c393b7db290dd732f0a2d403118c5
#
# https://github.com/majutsushi/tagbar
# https://github.com/majutsushi/tagbar/wiki#markdown
# https://github.com/jszakmeister/markdown2ctags
# https://github.com/lvht/tagbar-markdown
#
# http://docs.ctags.io/en/latest/extending.html
# https://gist.github.com/romainl/085b4db4a26a06ec7e16
# https://gist.github.com/romainl/27c1c29462a8c6c868f1a9bf244bc71d
# https://www.reddit.com/r/vim/comments/4d2fos/if_you_use_tags_whats_your_workflow_like/
# https://jdhao.github.io/2019/10/15/tagbar_markdown_setup/
#
# Edit: Try this:
#
#     $ tee ~/.config/ctags/markdown.ctags <<'EOF'
#     --langdef=markdown
#     --langmap=markdown:.md
#     --regex-markdown=/|(.*)|/\1/h,heading,headings/
#     EOF
#
#     $ cd ~/Wiki/vim/ && ctags --recurse .
#
# Source: https://stackoverflow.com/a/25742823/9780968
#
# Write `| foobar |` in one of your notes, and one line below write `foobar`.
# Press `C-]` on `foobar`: the cursor jumps onto `| foobar |`.
# But it doesn't work when `foobar` is above `| foobar |`, nor across files...
#
# Edit: It doesn't seem to work anymore.  `ctags(1)` complains with:
#
#     ctags: Language "markdown" already defined
#}}}
# Used in our notes when we create links between files, in a wiki on a topic.
setenv('MY_WIKI', $'{$HOME}/Wiki')

# If we start Vim from fish, we need to set `$_`.{{{
#
# In bash, `$_` has 2 meanings:
#
# When the shell starts up, it's set to the absolute pathname used to invoke the
# shell  or shell  script being  executed.  It's  then exported  in the  shell's
# environment.
#
# Later, it expands  to the last argument of the  previous executed command, and
# exported in the latter's environment.
#
# See: `man bash /PARAMETERS/;/Special Parameters`.
#
# We rely on the first semantics to  determine whether Vim has been started by
# `vipe(1)`.  Unfortunately,  fish does not  support `$_`. It *might*  have in
# the past:
#
#    > $_ is deprecated and will removed in the future (:issue:`813`). Use status current-command in a command substitution instead.
#
# Source: https://github.com/fish-shell/fish-shell/blob/master/CHANGELOG.rst#deprecations
# See also: https://github.com/fish-shell/fish-shell/issues/813
#
# To fix this, we manually set `$_` in Vim's environment.
#}}}
# One-liner alternative:{{{
#
#     :echo getpid()->printf('ps --pid $(ps --pid=%s --format=ppid=) --format=comm=')->system()->trim("\n", 2)
#                                     ^
#                                     no = here because `$(...)` starts with a space
#
# Don't use that though; we don't want to slow Vim down when it starts up.
# Spawning an external process would be too costly on startup.
#
# ---
#
# Broken down:
#
#    ┌──────────────────────────────────────────────┬───────────────────┐
#    │ :echo getpid()                               │ Vim's PID         │
#    ├──────────────────────────────────────────────┼───────────────────┤
#    │ $ ps --pid=<Vim's PID> --format=ppid=        │ Vim's parent PID  │
#    ├──────────────────────────────────────────────┼───────────────────┤
#    │ $ ps --pid=<Vim's parent PID> --format=comm= │ Vim's parent name │
#    └──────────────────────────────────────────────┴───────────────────┘
#}}}
def SetDollarUnderscore()
    var lines: list<string> = readfile($'/proc/{getpid()}/status')
    var lnum: number = lines->match('^PPid:')
    if lnum < 0
        return
    endif
    var ppid: string = lines[lnum]->matchstr('\d\+')
    var comm: string = $'/proc/{ppid}/comm'
        ->readfile('', 1)
        ->get(0, '')
    if comm == ''
        return
    endif
    comm->exepath()->setenv('_')
enddef
SetDollarUnderscore()

# backspace {{{2

# Allow BS, Del, C-w, C-u to delete:
#
#             ┌ whitespace (autoindent)
#             │      ┌ end of line (join line)
#             │      │   ┌ allow backspacing over the start of insert;
#             │      │   │  CTRL-W and CTRL-U do not stop at the start of insert
#             │      │   │
&backspace = 'indent,eol,nostop'

# binary {{{2

augroup SetBinary
    autocmd!
    # A file ending with `.bin` or `.dat` should be a binary file.
    # We should not edit  such a file with Vim, but if  that happen by accident,
    # at least let's try not to corrupt the binary.
    autocmd BufRead *.{bin,dat} &l:binary = true
augroup END

# buftype {{{2

# `M-c` lets us  load the contents of a  tmux pane in tmux popup  starting a new
# Vim instance.  We want  the Vim buffer to be recognized  as a terminal buffer;
# not just a regular one.  Because some features relies on this option to be set
# to work properly.   For example, when pressing  `SPC o`, we want to  get a Vim
# popup displaying a TOC whose entries are all the executed shell commands which
# were captured.
augroup SetBufType
    autocmd!
    autocmd VimEnter * {
        var shell_prompt: string = '^٪'
        if expand('%:p')->empty() && search(shell_prompt, 'n') > 0
            &buftype = 'terminal'
        endif
    }
augroup END

# clipboard {{{2
# Do *not* tweak this option!
#    Why could I be tempted to change the value of this option?{{{
#
# When you use a pasting command,  and you don't specify from which register you
# want the text to be pulled, Vim uses the `"` register.
# So, if you want to copy some text from a Vim buffer to Firefox, you'll need to
# explicitly mention the name of the `+` register:
#
#     "+yy
#
# Same thing if you want to paste in  a Vim buffer, some text you've just copied
# in Firefox:
#
#     "+p
#
# It would be convenient to just press `yy` and `p`, and Vim would automatically
# use the clipboard register, instead of the unnamed one.
# That's what 'clipboard' is for.
#}}}
#    How should I change it?{{{
#
#     set clipboard^=unnamedplus
#
# 'clipboard' contains a  comma-separated list of values.
# Each stands  for a register.
# `unnamedplus` stands for the clipboard register.
#
# Do *not* execute this:
#
#     set clipboard+=unnamedplus
#
# It would *ap*pend the value to the list; you want to *pre*pend it.
#}}}
#    Technically, what happens if I do it?{{{
#
# The clipboard register will now have  a similar behavior (although not exactly
# identical) than the one of the unnamed:
#
#    - it will contain the text of the last changed register (like `"`)
#
#    -  ... except  if  the  last changed  register  was  changed by  a  command
#      containing its explicit name:
#
#         "ayy
#
#      This  is different from `"`,  which always copy  the text of the  last changed
#      register.
#
# If  you  copy  some  text  in   Firefox,  it  goes  into  `+`  (regardless  of
# 'clipboard').   But  because  of  the  new  value  of  'clipboard',  `p`  will
# automatically paste `+` (last copied text in Firefox).
#
# If you copy some  text in a Vim buffer, it goes into  `0`.  The latter becomes
# the last modified register, and thus  `+` will duplicate its contents (because
# of `'clipboard'`).
#}}}
#    What pitfalls should I be aware of?{{{
#
# 1. It pollutes the clipboard selection after every yank, delete, change.
#
# 2. It alters the clipboard selection when inserting a character from select mode.
#
# 3. It might  break a plugin which forgets to  temporarily reset 'clipboard' to
#    its default value.
#
# 4. It forces you to temporarily reset  'clipboard' whenever you write a custom
#    operator which yanks some text. (because  a good operator should have as fewer
#    side-effects as possible)
#
# For `2.`, see: https://vi.stackexchange.com/a/22127/17449
#}}}

# TODO: It would be nice to set the option like this:{{{
#
#     &clipboard = 'autoselect,exclude:.*'
#                              ^--------^
#
# Because it would slightly reduce startup time.
# For more info, see: https://stackoverflow.com/a/17719528/9780968
# As well as `:help -X` and `:help 'clipboard'`.
#
# ---
#
# The issue  is that  it prevents us  from using  `--servername` (`v:servername`
# will be empty even if you start Vim with `--servername FOO`).
#
# And we can't send files remotely with `--remote` and friends.
# And we can't access the `"+` clipboard register.
#
# Edit: We could invoke  `remote_startserver()` to start a  server *after* the
# startup and  fix all of  these issues.  Is it  worth it though?   That would
# make for a complicated  setup; I can already feel all  sorts of weird issues
# incoming...
#}}}

# don't trigger  `TextYankPost` when we  press `Esc` after  visually selecting
# some text
set clipboard-=autoselect

# color scheme {{{2

# Be sure to enable `'termguicolors'` *before* sourcing the color scheme.
# We need to inspect the value of  the option to decide how to properly set some
# custom HGs.

# Let's make sure that the terminal supports true color.
# We inspect `$TERM` as a naive heuristic.
# Note that for gnome-terminal to have its TERM set to `gnome-256color`, you need to configure it like so:{{{
#
#     Edit
#     > Profile Preferences
#     > Command
#     > set "Run a custom command instead of my shell" checkbox
#     > inside the "Custom command" field, write "/usr/bin/env TERM=gnome-256color /usr/bin/bash"
#}}}
# Warning: We include `tmux` as a terminal type in which `'termguicolors'` can be set, but that's wrong.{{{
#
# We could be running tmux in a terminal which doesn't support true colors.
# To identify the type of the outer terminal, you could inspect:
#
#     :echo system('tmux display -p "#{client_termname}"')
#
# Unfortunately, `system()` would add too much time during startup.
#
# Anyway, in practice, I doubt this will be an issue.
# Most terminals support true colors; and even if we test one which doesn't from
# time to time, we won't be running tmux inside.
#}}}
if !has('gui_running')
        && ['gnome', 'konsole', 'st', 'tmux', 'xterm']
        ->map((_, term: string) => $'{term}-256color')
        ->index(&term) >= 0
        || &term == 'xterm-kitty'
    &termguicolors = true
    # If  `&term`   is  not   'xterm',  `'t_8f'`   and  `'t_8b'`   won't  be
    # automatically set; we need to do it manually.
    # See: `:help xterm-true-color`.
    &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif

var cursorlineopt_save: string
# We export the function to be able to import it from
# `autoload/toggleSettings.vim` where we implement the `]oL` and `[oL` mappings
# which toggle `'cursorline'`.
export def Cursorline(enable: bool)
    # Warning: Enabling `'cursorline'`  can be extremely cpu-consuming  when you
    # move horizontally (j, k, w, b, e, ...) and `'showcmd'` is enabled.

    # `'cursorline'` only in the active window and not in insert mode.
    if enable && !&l:cursorline
        &l:cursorline = true
        cursorlineopt_save = &l:cursorlineopt
        # What does this do?{{{
        #
        # When  the  cursor is  on  a  long  soft-wrapped  line, and  we  enable
        # `'cursorline'`,  we  want  only  the   current  *screen*  line  to  be
        # highlighted, not the whole *text* line.
        #}}}
        &l:cursorlineopt = 'screenline'
        augroup MyCursorline
            autocmd!
            # Why `BufWinEnter` and `BufWinLeave`?{{{
            #
            # If you load  another buffer in the current  window, `WinLeave` and
            # `WinEnter` are not fired.
            # It may happen, for example, when  you move in the quickfix list by
            # pressing `]q`.
            #}}}
            autocmd VimEnter,BufWinEnter,WinEnter * &l:cursorline = true  | &l:cursorlineopt = 'screenline'
            autocmd BufWinLeave,WinLeave          * &l:cursorline = false | &l:cursorlineopt = cursorlineopt_save
            autocmd InsertEnter                   * &l:cursorline = false | &l:cursorlineopt = cursorlineopt_save
            autocmd InsertLeave                   * &l:cursorline = true  | &l:cursorlineopt = 'screenline'
        augroup END

    elseif !enable && &l:cursorline
        # When is this guard necessary?{{{
        #
        #     :setlocal cursorline
        #     # press `]oL`
        #}}}
        if exists('#MyCursorline')
            autocmd! MyCursorline
            augroup! MyCursorline
        endif
        &l:cursorline = false
        &l:cursorlineopt = cursorlineopt_save ?? &l:cursorlineopt
    endif
enddef

# We delay our customizations to handle the case where we spam `]ol` to change the lightness level.{{{
#
# `OnColorScheme()` can  be costly;  mainly because  of `ReinstallClearedHG()`
# whose cost increases with the number of  open windows.  We don't want Vim to
# be stuck when we spam `]ol`.
#}}}
var on_colorscheme_timer_id: number
augroup MyColorScheme
    autocmd!
    autocmd ColorScheme * {
        if v:vim_did_enter
            timer_stop(on_colorscheme_timer_id)
            # `&timeoutlen`: maximum amount of time our custom submodes can last
            on_colorscheme_timer_id = timer_start(&timeoutlen, (_) => OnColorScheme())
        else
            OnColorScheme()
        endif
    }
augroup END

def OnColorScheme()
    # By default, when we  set a color scheme, we want to  see the cursor line
    # if, and  only if,  the background  is dark (because  it seems  harder to
    # find).
    Cursorline(&background == 'dark')

    # What's the issue fixed by `ReinstallClearedHG()`?{{{
    #
    #     $ tee /tmp/markdown.snippets <<'EOF'
    #     snippet foo ""
    #         text preceded by 4 leading spaces (!= 1 tab)
    #     endsnippet
    #     EOF
    #
    #     $ vim -g /tmp/markdown.snippets
    #     ]ol (change lightness)
    #
    # The leading spaces are not highlighted anymore (✘).
    #}}}
    # Where does the issue come from?{{{
    #
    # The  `snipLeadingSpaces` HG  is  cleared when  we  change the  color
    # scheme, because of `:highlight clear`:
    #
    #     ~/.vim/pack/mine/opt/seoul/colors/seoul.vim:145
    #
    # More  generally, any  HG whose  attributes are  defined in  a syntax
    # plugin is cleared.
    #
    # ---
    #
    # There is  one exception to  this issue;  linked HGs which  have been
    # defined with the `default` argument:
    #
    #                            v-----v
    #     $ vim --cmd 'highlight default link WillItSurvive ErrorMsg | highlight clear | highlight WillItSurvive | cquit'
    #     WillItSurvive  xxx links to ErrorMsg˜
    #
    #     $ vim --cmd 'highlight link WillItSurvive ErrorMsg | highlight clear | highlight WillItSurvive | cquit'
    #     WillItSurvive  xxx cleared˜
    #}}}
    ReinstallClearedHG()

    # Make sure the `cterm=` and  `gui=` attributes of the “preferred”
    # highlight groups are in sync.  Make sure `cterm=bold` is not used in
    # a terminal with a limited palette.
    FixPreferredHL()
enddef

def ReinstallClearedHG()
    # If we've entered goyo mode to  read code without syntax highlighting, we
    # don't want this function to restore it (via `:doautocmd Syntax`).
    if exists('#goyo')
        return
    endif

    # Why don't you simply run `:doautocmd Syntax`?{{{
    #
    # Suppose  you  have two  windows,  one  with  a  python buffer,  and  the
    # other  with  an  HTML  buffer.    You  change  the  color  scheme  while
    # in  the  python  buffer.   The  HGs  whose  attributes  are  defined  in
    # `$VIMRUNTIME/syntax/html.vim` will  be cleared.   But since you're  in a
    # python buffer, `:doautocmd Syntax` will reload the python syntax plugin,
    # while you need to reload the HTML syntax plugin.
    #}}}
    # Why don't you manually re-install every cleared HG?{{{
    #
    # It would create duplication.
    # Some HGs would be installed from a syntax plugin, and from this file.
    # If one day their definition is updated  in the syntax plugin, we would have an
    # inconsistency.
    #
    # Besides, we would be constantly chasing new cleared HGs, and even then, we
    # could miss some of them; it's not reliable.
    #}}}
    # Which alternative could I use?{{{
    #
    #     :doautoall syntax
    #
    # But it's too slow when we have a lot of buffers.
    #}}}

    # What does this code do?{{{
    #
    # It iterates over all visible windows.
    # For each  of them,  if it  has never  seen the  filetype of  the displayed
    # buffer, it reloads its syntax plugin.
    #}}}
    # If I have several buffers with the same filetype, don't I need to fire `Syntax` for each of them?{{{
    #
    # No.
    # To re-install the cleared HGs, you just need to reload the syntax plugin once.
    #}}}
    var seen: dict<bool>
    for info: dict<any> in getwininfo()
        var filetype: string = getbufvar(info.bufnr, '&filetype')

        if seen->has_key(filetype)
            continue
        endif
        seen[filetype] = true

        if filetype != ''
            try
                win_execute(info.winid, 'doautocmd Syntax')
            # E930: Cannot use :redir inside execute()
            # (happens in a netrw buffer)
            catch /^Vim\%((\a\+)\)\=:E930:/
            endtry
        endif
    endfor
enddef

# `:help group-name`
const PREFERRED_HL: list<string> =<< trim END
    Comment
    Constant
    Identifier
    Ignore
    PreProc
    Special
    Statement
    Type
    Underlined
END
def FixPreferredHL()
    var fixed_hl: list<dict<any>>
    for name: string in PREFERRED_HL
        var hl: dict<any> = hlget(name, true)->get(0, {})
        var gui: dict<bool> = hl->get('gui', {})
        var cterm: dict<bool> = hl->get('cterm', {})
        # We're going to copy the value of `gui` into `cterm`.
        # But we  don't want to  copy the bold  attribute in a  terminal without
        # `'termguicolors'`, because the terminal could interpret it as “bright”
        # or “bold and bright”:  https://askubuntu.com/a/875228
        if gui->get('bold') && !&termguicolors
            gui->remove('bold')
        endif
        # if `gui=` and `cterm=` are not in sync, sync them
        if gui != cterm
            fixed_hl->extend([hl->extend({cterm: gui})])
        endif
    endfor
    hlset(fixed_hl)
enddef

# We purposefully set the color scheme at the end of this section.{{{
#
# To make sure our `ColorScheme` autocmds have been installed.
# Otherwise, our customizations would only be applied when we *change* the color
# scheme; not when we set it the very first time.
#}}}
# Do *not* delay setting the color scheme until `VimEnter`.{{{
#
# We did that in  the past to preserve the lightness  level when restarting Vim,
# by leveraging the viminfo file.
#
# But it creates too many issues.
# First, `g:terminal_ansi_colors` (and `v:colornames`?) needs to be set earlier.
# Otherwise, the colors are wrong when we do `$ vim +term`.
#
# Second, it causes custom highlight groups to be unexpectedly cleared.
# This can  break the highlighting of  text properties if their  type is defined
# with  a highlight  group which  is defined  before `VimEnter`  (e.g. vimrc  or
# `StdinReadPost`  event).   This  pitfall  affects  our  `ParseAnsiEscapeCodes`
# autocmds.
#
# ---
#
# If nevertheless you decide to use a `VimEnter` autocmd, don't forget `++nested`:
#
#     autocmd VimEnter * ++nested colorscheme seoul
#
# So  that  when we  set  the  color scheme,  `ColorScheme`  is  fired, and  our
# customizations are sourced.
#}}}
# TODO: Seoul is too ugly in the console.  Make it nice.
if $TERM =~ '^linux'
    colorscheme default
else
    colorscheme seoul
endif

# cmd  mode  ruler{{{2

# When we  move the cursor  (hjkl wbe ...)  and Vim consumes a  lot of cpu  / is
# slow, it can be for 2 reasons:
#
#    - we're inside a deep nested fold:  solution → open folds (zR)
#    - `'showcmd'` is enabled:             solution → disable it

# Even  though it  can have  an impact  on performance,  we enable  `'showcmd'`,
# because sometimes it's useful  to see what we type.  Also,  it's useful to see
# the number of lines inside the visual selection.
&showcmd = true

# displaying the mode creates noise; and it can erase a message output by `:echo`
&showmode = false

# When  `'statusline'` is  empty, Vim  displays  the current  line address,  and
# column number, in  the statusline.  This region is called  the “ruler bar“
# (`:help ruler`).
#
# Even though we should never see it, disable it explicitly.
&ruler = false

# comments {{{2

# Make sure that the C comment leader is not wrongly inserted when we open a new
# line below a URL.
# https://github.com/vim/vim/issues/9426#issuecomment-1002668061
augroup FixCommentsOption
    autocmd!
    autocmd FileType * {
        if &l:commentstring !~ '^//' && &l:comments =~ '//'
            &l:comments = &l:comments
                ->split(',')
                ->filter((_, v: string): bool => v !~ '//')
                ->join(',')
        endif
    }
augroup END

# commentstring {{{2

&commentstring = ''

# cpoptions {{{2

# When  we type  `:read  some_file`  or `:'<,'>write  some_file`,  I don't  want
# `some_file` to become the alternate file of the current window.
set cpoptions-=aA

# Don't ignore escaped parentheses when using the text-object `ib`.{{{
#
# If we press `dib` while the cursor is on 'O' in the following text:
#
#     (hello \(fOo) world)
#
# We get:
#
#     () world)
#
# For the moment, we prefer that Vim doesn't ignore escaped parentheses:
#
# So instead we get:
#
#     (hello \() world)
#}}}
set cpoptions+=M

# the nr column  (`'number'`, `'relativenumber'`) will be taken  into account to
# decide when to wrap long lines
set cpoptions+=n

# allow us to redo a yank command with the dot command
set cpoptions+=y

# When appending to a register, put a line break before the appended text.
set cpoptions+=>

# cursor {{{2

# Variables {{{

#     Control Sequence
#     vv
const CS_BLOCK: string = "\<Esc>[2 q"
const CS_UNDERLINE: string = "\<Esc>[4 q"
const CS_LINE: string = "\<Esc>[6 q"

const CS_BLINKING_BLOCK: string = "\<Esc>[0 q"
const CS_BLINKING_UNDERLINE: string = "\<Esc>[3 q"
const CS_BLINKING_LINE: string = "\<Esc>[5 q"

const SHAPE_NORMAL: string = 'BLOCK' # █
const SHAPE_REPLACE: string = 'UNDERLINE' # _
const SHAPE_INSERT: string = 'LINE' # |
#}}}
def SetCursor() #{{{
    # Purpose: Change the cursor shape by sending some control sequences.

    # In console, no escape sequence we're going to use is supported (probably).{{{
    #
    # Worse, if you include `CSI 2 SP q` in `'t_te'`, and you start Vim inside tmux,
    # when you quit Vim, the sequence keeps being sent to the terminal regularly.
    # So, you get a phantom `q` printed here and there.
    #}}}
    # TODO: Try to support the linux console: https://unix.stackexchange.com/q/55423/289772
    if $DISPLAY == ''
        return
    endif

    # Write the gui case first.{{{
    #
    # We might start the GUI from tmux (e.g. `gf` in copy-mode).
    # When that happens, `&term` has the value `tmux-256color` inside the GUI.
    # With this value, if you write the `&term =~ ...` case before the gui case,
    # 'guicursor' would be wrongly handled by the former instead of the latter.
    #}}}
    if has('gui_running')
        # No blinking cursor in the GUI.
        # Where did you get this value?{{{
        #
        # It's  the  default  value;  we've just  included  `blinkon0`  in  each
        # argument-list, to disable the default blinking.
        #}}}
        &guicursor = 'n-v-c:block-Cursor/lCursor-blinkon0'
            .. ',ve:ver35-Cursor-blinkon0'
            .. ',o:hor50-Cursor-blinkon0'
            .. ',i-ci:ver25-Cursor/lCursor-blinkon0'
            .. ',r-cr:hor20-Cursor/lCursor-blinkon0'
            .. ',sm:block-Cursor-blinkon0'

    elseif &term =~ '^\%(st\|tmux\|xterm\)-256color$\|kitty'
        # For more info, see `:help termcap-cursor-shape`

        #  ┌ End Insert or replace mode
        #  │
        &t_EI = $'CS_{SHAPE_NORMAL}'->eval()
        #  ┌ Start Insert
        #  │
        &t_SI = $'CS_{SHAPE_INSERT}'->eval()
        #  ┌ Start Replace
        #  │
        &t_SR = $'CS_{SHAPE_REPLACE}'->eval()

        # Make sure the cursor has whatever shape we want right away:
        &t_ti = $'CS_{SHAPE_NORMAL}'->eval() .. &t_ti
        # Is it really necessary?{{{
        #
        # It depends.
        # We probably  have some plugins  which trigger  a leave insert  mode event,
        # which sends the sequence `&t_EI` to the terminal.  For this reason, atm we
        # don't need to set 't_ti'.
        #
        # But without any config, we need `&t_ti` to be correctly set.
        #}}}

        # We prepend a sequence to restore the shape of the cursor as a block.
        # Prepending instead of appending works better with tmux, according to the
        # original plugin author.
        &t_te = "\<Esc>[2 q" .. &t_te
    endif
enddef
#}}}

# Do *not* call this function from an autocmd listening to `VimEnter`.{{{
#
# It might be too late for some sequence stored in `&t_ti` to take effect.
# It's better to call it directly when this file is sourced.
#}}}
SetCursor()

# diffopt {{{2

# Do *not* ignore whitespace, with `iwhiteall`.{{{
#
# It would ignore significant differences.
# For example, in a shell script, this is wrong:
#
#     if [ $? -gt 0]; then
#                  ^
#                  there should be a space
#
# If we have 2 files, one with the error, the other without, we want to see this
# difference.
#
# ---
#
# Do not  ignore trailing whitespace with  `iwhite` either; if they  can somehow
# alter the behavior  of a program, and  we're comparing 2 versions  of the same
# program, one with trailing whitespace on some line, the other without trailing
# whitespace, we need to see this difference to understand what's happening.
#
# ---
#
# If you need to temporarily ignore whitespace differences, use our `co SPC` mapping.
#}}}

# the “patience” algorithm gives more readable diffs
# Why isn't patience the default?{{{
#
# The default algorithm is “myers”.
#
# 1. patience is slower:
#
#     https://marc.info/?l=git&m=133103975225142&w=2
#
# 2. besides:
#
#    > Myers has  been the universal  default diff  algorithm for so  long that
#    > enabling an alternative algorithm by default in a low-level component of
#    > our world (Git, Vim, etc.) could cause issues down the line.
#
# Source: https://www.reddit.com/r/vim/comments/a26phr/the_power_of_diff_vimways_124/eavzmke/
#}}}
set diffopt+=algorithm:patience

# only 3 lines of context above/below a changed line (instead of 6)
set diffopt+=context:3

# use only 1 column for the foldcolumn, instead of 2 (vertical space is precious)
set diffopt+=foldcolumn:1

# follow the 'wrap' option and leave as it is
set diffopt+=followwrap

# turn off diff mode automatically for a buffer which becomes hidden
set diffopt+=hiddenoff

# Use the indent heuristic for the  internal diff library, because it gives more
# readable diffs.
set diffopt+=indent-heuristic
# For more info, see:
# https://vimways.org/2018/the-power-of-diff/

# start diff mode with vertical splits (unless explicitly specified otherwise)
set diffopt+=vertical

# display {{{2

# When the last  line of the window  doesn't fit on the screen,  Vim replaces it
# with some  character highlighted with  `NonText` (`@`  by default, but  can be
# changed with the "lastline" item of `'fillchars'`).  We want Vim to show us as
# much text as possible from the last line and, only when there is no more room,
# replace the remaining text.
set display+=lastline

# errorformat {{{2

# Why do you set `'errorformat'`?{{{
#
#     silent help
#     vimgrep /./j %
#     copen
#     setlocal modifiable | :1 delete _ | setlocal nomodifiable
#     cgetbuffer
#
# The new quickfix window is not interactive.
#
# This is  because `:cgetbuffer` uses  `'errorformat'` to parse the  contents of
# the current buffer, but by default it  does not contain any format designed to
# parse the contents of a quickfix buffer.
# It does contain a few formats to  parse the output of some shell commands; but
# that's not what we want to parse here.
#}}}
#   Could I use a simpler value?{{{
#
# Yes:
#
#     &errorformat = '%f\|%l col %c\| %m'
#
# But, in `vim-qf`,  we set the `'quickfixtextfunc'` option to  align the fields
# in the  quickfix buffer.  This  alignment might  add extra whitespace;  so our
# `'errorformat'` value needs to take those into account.
#}}}
#   Why not using `:set`?{{{
#
# It would make the value less readable; we would need to escape any:
#
#    - backslash
#
#    - bar
#
#      here we still escape a bar, but it's only for the regex engine
#      `:set` would need an additional backslash
#
#    - comma
#
#      We need to escape a comma even  without `:set`, because a comma has a
#      special meaning for `'errorformat'`: separation between 2 formats.
#
#      But with `:set` we would need a double backslash, because a comma has
#      also a special meaning for `:set`: separation between 2 option values.
#
#    - double quote
#
#    - space
#}}}

&errorformat ..= ',%f\|%\s%#%l col%\s%#%c%\s%#\| %m'
#                       │
#                       └ all meta symbols (e.g.: \ . [), including the backslash,
#                         have to be written with a leading '%' (see :help `efm-ignore`)

# emoji {{{2

# Might fix various issues when editing a line containing some emojis.{{{
#
# If you still have issues in tmux,  you might need to recompile the latter with
# `--enable-utf8proc`.
#}}}
&emoji = false

# fillchars {{{2

# Replace ugly  separators (`|`)  used for vertical  splits, with  prettier utf8
# characters, to get a continuous line.
&fillchars = 'vert:┃'
    # pad end of title lines with spaces instead of hyphens
    .. ',fold: '
    # don't print a tilde at the start of the lines after the last buffer line
    .. ',eob: '
    # When Vim needs  to truncate the last  line in the window  because it's too
    # long, use `>` instead of the default `@` as a truncation indicator.
    # It makes more sense than `@`, and  is consistent with `<<<` which might be
    # displayed at the start of the first line of the window if `'smoothscroll'`
    # is enabled.
    .. ',lastline:>'

# formatlistpat {{{2

#                          recognize numbered lists
#                          v------v
&g:formatlistpat = '^\s*\%(\d\+[.)]\|[-*+]\)\s\+'
#                                    ^---^
#                                    recognize unordered lists

augroup MyDefaultFormatListPat
    autocmd!
    # We've configured the global value of 'formatlistpat'.
    # Do the same for its local value in *any* filetype.
    autocmd FileType * SetFormatListPat()
augroup END

def SetFormatListPat()
    # We'll never write a list inside code; only in prose.
    # And prose can  only be commented, so our regex  must take into account
    # the comment leader.
    var cml: string = &l:commentstring->matchstr('\S*\ze\s*%s')
    &l:formatlistpat = &g:formatlistpat
        ->substitute('\V^\\s*\m\zs\ze.*', $'\\%(\\V{cml->escape('\')}\\m\\)\\=\\s*', '')
    #                                                                      ^^^
    # We  need to  make it  optional, so  that our  `gq` mapping  uses the  same
    # indentation for hard-wrapped  lines inside a list item, as  the very first
    # line  of  the item.   This  also  assumes that  we  put  the `n`  flag  in
    # `'formatoptions'` (don't worry, we do; in `vim-par`).
enddef

# Is 'formatlistpat' used automatically? {{{
#
# No, you also need to include the `n` flag inside 'formatoptions' (we did in `vim-par`).
# This tells Vim to use 'formatlistpat' to recognize lists when we use `gw`.
#}}}
# What's the effect?{{{
#
# Some text:
#
#     1. some very long line some very long line some very long line some very long line
#     2. another very long line another very long line another very long line another line
#
# Press `gwip` *without* `n` inside 'formatoptions':
#
#         1. some very long line some very long line some very long line some very
#     long line 2. another very long line another very long line another very long
#     line another line
#
# Press `gwip` *with* `n` inside 'formatoptions', and the right pattern in 'formatlistpat':
#
#     1. some very long line some very long line some very long line some very
#        long line
#     2. another very long line another very long line another very long line
#        another line
# }}}
# Why use `&g:` instead of `setglobal`? {{{
#
# With `:setglobal`,  you have to  double the  backslashes because the  value is
# wrapped inside a non-literal string.
#
# Also,  you have  to  add an  extra backslash  for  every bar  (alternation),
# because  one is  removed  by  Vim to  toggle  its  special meaning  (command
# separator).
#
# So:    2 backslashes for metacharacters (atoms, quantifiers, ...)
#        3 backslashes for bars
# }}}
# After pressing `gwip` in a list, how are the lines indented?{{{
#
# The indent of the text after the list header is used for the next line.
#}}}
# Don't conflate the `n` flag in 'formatoptions' with the one in 'comments'. {{{
#
# There's zero link between the two.  This could confuse you:
#
#     &l:comments = 'f:-'
#     &l:formatlistpat = ''
#
#             - some very long line some very long line some very long line some very long line
#             - another very long line another very long line another very long line another line
#
#     gwip
#             - some very long line some very long line some very long line some
#               very long line
#             - another very long line another very long line another very long
#               line another line
#
# It worked.  Vim  formatted the list as  we wanted.  But it's a  side effect of
# `-` being recognized as a comment leader, and using the `f` flag.
# For a numbered  list, you have to  add the `n` flag  in `'formatoptions'`, and
# include the right pattern in `'formatlistpat'`.  Why?
# Because you can't use a pattern inside `'comments'`, only literal strings.
# }}}

# folding {{{2

# When starting  to edit another buffer  in a window, always  start editing with
# all  folds closed.   Technically, this  global option  sets the  initial local
# value of `'foldlevel'` in any window.
&foldlevelstart = 0

# Keeping the default value to 1 might cause issues.{{{
#
# For example, in markdown  files, I want the option to be set  to 0.  I could
# keep  the global  value to  1, and  just set  its local  value to  0 in  the
# markdown filetype  plugin.  But if  I do  that, for some  reason, sometimes,
# some  lines are  actually not  folded  (the issue  is specific  to lines  in
# one-line  folds).  And  yet, the  local value  and global  value are  always
# correctly set  to 0  and 1.   Maybe the  issue is  caused by  our `lazy.vim`
# script.  Anyway, I think I prefer 0  in the general case (e.g. I also want 0
# in man buffers).
#}}}
&foldminlines = 0

# do *not* open folds when jumping with `(`, `{`, `[[`, `[{`, etc.
set foldopen-=block

# ft_ignore_pat {{{2

# What's this?{{{
#
# A global variable which Vim inspects – at various locations – to determine
# whether filetype detection should be skipped for certain files.
# See `:help filetype-ignore`.
#}}}
# Let's use it to skip filetype detection for pseudo-files under `/proc/`.{{{
#
# For example:
#
#     $ vim <(printf "line 1\n# line 2\nline3")
#
# We don't want this pseudo-file to be  highlighted as a conf file, just because
# one of its first lines start with a `#`.
#}}}
g:ft_ignore_pat = '\.\%(Z\|gz\|bz2\|zip\|tgz\)$\|^/proc/'
#                                                ^-----^
# Do not ignore `.log` files.{{{
#
# Sometimes, we  have a  `strace(1)` log  file.  We want  those to  be correctly
# highlighted.
#}}}

# `:grep` {{{2

# Which program to call when executing `:[l]grep[add]`.
# No need to write `2>/dev/null`.{{{
#
# `grepc` runs  `grep(1)` with `--no-messages` which  already suppresses error
# messages about nonexistent or unreadable files.
#}}}
#   Besides, it wouldn't work, because of the value we give to `'shellpipe'`:{{{
#
#     &shellpipe = '>%s 2>&1'
#                       ^--^
#
# The errors would be still parsed as invalid entries in your quickfix list.
#}}}
#     But in the general case, `2>/dev/null` does work for `system()`, `systemlist()`, `:!`.{{{
#
# Because those don't run a shell command in the same way:
#
#     # system()
#     (grep pat /etc) >/tmp/... 2>&1
#
#     # 'grepprg'
#     :! grep pat /etc >/tmp/... 2>&1
#
# In the first case, `2>/dev/null` is useful:
#
#     (grep 2>/dev/null pat /etc) >/tmp/... 2>&1
#           ^---------^
#
# It prevents errors from being written in the temporary file.
#
# In the second case, `2>/dev/null` is useless:
#
#     :! grep 2>/dev/null pat /etc >/tmp/... 2>&1
#             ^---------^
#
# Because,  it's overridden  by  `2>&1` which  comes  from `'shellpipe'`.   In
# contrast, `system()` uses `'shellredir'`, which also includes `2>&1`, but it
# doesn't have the same  effect, because the command is run  in a subshell via
# braces:
#
#     (grep 2>/dev/null pat /etc)>/tmp/... 2>&1
#     ^                         ^
#
# From `:help system() /braces`:
#
#    > For Unix, braces are put around {expr} to allow for
#    > concatenated commands.
#}}}
&grepprg = 'grepc'
# Warning: Prefer `:cexpr` or `getqflist({lines: ..., efm: ...})` + `setqflist()` over `:grep`.{{{
#
# `:grep` has too many pitfalls:
#
#    - you need to append a bang to prevent Vim from automatically jumping to
#      the first entry
#
#    - you need to remove `tee(1)` from the default value of `'shellpipe'` to
#      prevent Vim from writing the output of `&grepprg` on the terminal
#
#    - you need `:silent` to bypass a hit-enter prompt, and then `:redraw!` to
#      redraw the screen after switching back from the terminal back to Vim's
#      UI; but that causes the screen to flicker
#
#    - you need to escape characters which are special on Vim's command-line,
#      because `:grep` actually executes `:!`.  From `:help :grep`:
#
#     > Just like ":make", [...]
#
#      And from `:help :make`:
#
#     > This works almost like typing
#     >
#     >       ":!{makeprg} [arguments] {shellpipe} {errorfile}".
#
#      If you use `shellescape()` to protect the arguments passed to `:grep`,
#      you need the 2nd optional argument:
#
#         $ vim
#         :execute 'grep! ' .. shellescape('==#') .. ' $VIMRUNTIME'
#         E194: No alternate file name to substitute for '#': grepc '==#' $VIMRUNTIME
#         ✘
#
#                                                 v----v
#         :execute 'grep! ' .. shellescape('==#', v:true) .. ' $VIMRUNTIME'
#         ✔
#}}}
# BTW, same recommendation for `:make`.

# How to parse the output of `&grepprg`.
# Default value: `%f:%l:%m,%f:%l%m,%f  %l%m`
&grepformat = '%f:%l:%c:%m,%f:%l:%m'

# hidden {{{2

# hide a buffer when it's abandoned (instead of unloading it)
&hidden = true

# history {{{2

# Remember up to 1000 past commands / search patterns.
&history = 1'000

# includeexpr (gf) {{{2

&includeexpr = 'IncludeExpr()'

const BOX_DRAWING: string = '[─│└├]'
def IncludeExpr(): string
    var line: string = getline('.')

    if &filetype == 'c'
            && line =~ '^#include '
        var file = '/usr/include/' ..  line->matchstr('<\zs.*\ze>')
        if file->filereadable()
            return file
        endif
        return v:fname
    endif

    # We're on a line in the middle of the output of a `tree(1)` command.
    if line =~ $'^\s*{BOX_DRAWING}'
        return line->ReconstructPathFromTree()
    endif

    # If you change the code, make sure it still works against these lines:{{{
    #
    #     alias info='info --vi-keys --init-file=$HOME/.config/infokey'
    #                                            ^-------------------^
    #
    #
    #     #     ${HOME}/bin/README.md
    #           ^-------------------^
    #
    #     set packpath=~/.vim,$VIMRUNTIME,~/.vim/after runtimepath=/tmp
    #                  ^----^ ^---------^ ^----------^             ^--^
    #
    # The `^---^` characters represent all  the cursor positions from which we
    # want to be able  to jump to the file.  In particular,  make sure you can
    # still jump from `$`, `{`, and `}` around an environment variable.
    #}}}
    var curcol: number = charcol('.') - 1
    var startcol: number = curcol
    while startcol > 0
        if (line[startcol] !~ '\f' || line[startcol] =~ '[=,"'']')
                # `\f` does not match curly brackets,  but we still want to accept them,
                # because they might be used around an environment variable:
                #     ${HOME}/bin/README.md
                #      ^    ^
                && line[startcol] !~ '[{}]'
            ++startcol
            break
        endif
        --startcol
    endwhile
    var endcol: number = curcol
    while endcol >= 0
        if (line[endcol] !~ '\f' || line[endcol] =~ '[=,"'']')
                && line[endcol] !~ '[{}]'
            --endcol
            break
        endif
        ++endcol
    endwhile
    if startcol > endcol
        return v:fname
    endif

    var fpath: string = line[startcol : endcol]

    if &filetype == 'systemd'
        var specifiers: dict<string> = {
            C: $'{$HOME}/.cache',
            E: $'{$HOME}/.config',
            T: '/tmp',
            U: $UID,
            h: $HOME,
        }
        var pat: string = $'%\@1<!%\([{specifiers->keys()->join('')}]\)'
        var Rep: func = (m: list<string>) => specifiers[m[1]]
        fpath = fpath
            ->substitute(pat, Rep, 'g')
    endif

    var envvar: string = '\${\=\(\h\w*\)}\='
    return fpath
        ->substitute(envvar, () => submatch(1)->getenv() ?? submatch(0), 'g')
        ->substitute('.*{', '', '')
        ->substitute('}.*', '', '')
enddef

def ReconstructPathFromTree(aline: string): string
    # `line` will iterate over the lines containing path components for the current file
    var line: string = aline->tr("\u00a0", ' ')
    var lnum: number = line('$') + 1
    # anything after the last box drawing character
    var path_component: string = $'.*{BOX_DRAWING}\s*\zs.*'
    var fullpath: string = line->matchstr(path_component)
    # Walk back  the tree  to reconstruct  the path to  the filename  on the
    # current line.
    while true
        # index of the cell where the last box drawing character is on `line`
        var vcol: number = line
            ->matchstr($'.*{BOX_DRAWING}')
            ->strdisplaywidth()
        # Address of the line where the previous path component is written.{{{
        #
        # That should be the line where – in the same cell position – there is:
        #
        #    - a non-whitespace
        #    - not a drawing box character
        #    - not a no-break space (for some reason `tree(1)` uses some of them)
        #}}}
        var format: string = '\%%<%dl\%%%dv[^%s \xa0]'
            .. '\|'
            # Special Case: the line of the previous path component is short.{{{
            #
            # Too short for a character of the path component to be displayed in the
            # cell column  saved in `vcol`.   Without this  branch, we might  end up
            # going too far back, on an irrelevant line.
            #}}}
            .. '\%%<%dv.$'
        lnum = printf(format, lnum, vcol, BOX_DRAWING->trim('[]'), vcol)
            ->search('bnW')
        line = getline(lnum)
        if line =~ BOX_DRAWING
            fullpath = $'{line->matchstr(path_component)}/{fullpath}'
        else
            fullpath = $'{line}/{fullpath}'
            break
        endif
    endwhile
    return fullpath
enddef

# indentation {{{2

&autoindent = true
&expandtab = true
# Why don't you set 'tabstop'?{{{
#
# It would mess the alignment in help files, where tabs are used with a width of
# 8 cells.  Besides, `'tabstop'` is *not* used when `'expandtab'` is set.
#}}}

# What's the effect of 'shiftround'?{{{
#
# When you press:
#
#    - `{count}>>`
#    - `{count}<<`
#    - `>{motion}`
#    - `<{motion}`
#
# ...  on  indented lines,  if  `'shiftround'`  is  enabled,  the new  level  of
# indentation will be a multiple of `&shiftwidth`.
#}}}
#   Do *not* set it by default!{{{
#
# It might cause  an unexpected result when we indent  a paragraph (`>ip`), some
# lines of which have an indentation level which is not a multiple of `&shiftwidth`.
#
#     set shiftround shiftwidth=4
#     ['foo', '  bar', 'baz']->setline(1)
#     # press:  >ip
#
#     # expected:
#
#         foo˜
#           bar˜
#         baz˜
#
#     # actual:
#
#         foo˜
#         bar˜
#         baz˜
#
# The relative indentation between them has been lost.
# They now all have the same  indentation level, while before `bar` had a bigger
# indentation level.
#}}}

# What's the effect of 'shiftwidth'?{{{
#
# It controls the number of spaces added/removed when you press:
#
#    - `{count}>>`
#    - `{count}<<`
#    - `>{motion}`
#    - `<{motion}`
#}}}
&shiftwidth = 4

# When  we  press `Tab`  or  `BS`  in front  of  a  line, we  want  'shiftwidth'
# to  determine  how  many  spaces  are  added/removed  (and  not  'tabstop'  or
# 'softtabstop').
# Also, this  option *needs* to be  set for us to  be able to configure  how Vim
# handles indentation, and *only* indentation.  If it was reset, all we could do
&smarttab = true

# When  we   press  `Tab`  or  `BS`   in  other  locations  (i.e.   after  first
# non-whitespace), we don't want 'softtabstop'  to determine how many spaces are
# added/removed (nor 'tabstop', hence why we don't set 'softtabstop' to zero).
&softtabstop = -1

# The way  we've configured  'smarttab' and 'softtabstop',  we can  now entirely
# configure  how Vim  handles  tabs,  in all  contexts,  with  a single  option:
# 'shiftwidth'.

# is_bash {{{2

# By default, Vim uses the Bourne shell syntax.
# We prefer to use `bash`.
#
# Indeed, most  of the time,  we'll use `bash`,  and some bash  constructs don't
# exist in Bourne shell, like commands substitutions (`$(...)`).
# These bashisms are considered as errors if `b:current_syntax` is `sh`.
#
# For more info, read `:help sh.vim`.
g:is_bash = 1

# It's not needed when a shell script has a shebang containing `bash`.
# But it's  useful when we've just  created a shell file,  because initially Vim
# might not  be able to  infer the right shelltype  (no typical filename  and no
# shebang yet).


# For more info, see this:
# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=848663

# invisible characters {{{2

# We define which glyph Vim must use to display certain special characters.

# tabs: > or <> or <=> or <==> or ...
&listchars = 'tab:<=>'
    # end of line
    .. ',eol:¬'
    # scroll unwrapped lines
    .. ',precedes:«,extends:»'
    # no-break space
    .. ',nbsp:∅'
    # leading space
    .. ',lead:│'
    # show ten consecutive spaces as:
    #     ▫▫▫▪▫▫▫▪▫▫
    .. ',multispace:▫▫▫▪'
# if you find these characters too small, try these ones instead:
#     .. ',multispace:◻◻◻◼'
# if  you only  want  to  customize spaces  used  for  indentation, use  the
# `leadmultispace` item (which overrides the `lead` one):
#     .. ',leadmultispace:---+'

# jumpoptions {{{2

# Make jumplist behave like a stack.  If  we jump back to an old position, and
# then from there jump  to a new position, we want all  later positions in the
# jumplist to be discarded.
&jumpoptions = 'stack'

# lazyredraw {{{2
# What does it do?{{{
#
# Prevent the screen  from being redrawn while executing  commands which haven't
# been typed (e.g.: macros, registers).
# Also, postpone the update of the window title.
#}}}
# Why do you set it?{{{
#
# - Because of the previous description.
#
# - Setting this option prevents the screen from flickering when we use a custom
#   mapping which makes the cursor move far from its initial position, then
#   come back (e.g. `*`).
#}}}
# Is there any pitfall?{{{
#
# Yes.
# Because of  this option, sometimes,  we might need  to execute `:redraw`  in a
# (function called by a) mapping.
#}}}
&lazyredraw = true

# shellpipe {{{2

# Don't print the output of `&grepprg`/`&makeprg` on the terminal.{{{
#
# The default value is:
#
#     &shellpipe = '2>&1| tee'
#                         ^^^
#
# And `tee(1)`  writes whatever it  reads from its  STDIN on the  terminal (in
# addition  to the  implicit next  temporary file).   We don't  want that;  it
# creates visual clutter in the terminal after we've quit Vim.
#}}}
&shellpipe = '>%s 2>&1'

# showmatch {{{2

# don't show matching brackets;
# it makes the cursor jumps unexpectedly which is too distracting
&showmatch = false
# Note that if you set the option in the future, you might face an issue (github #4867).{{{
#
# You might fix it if you:
#
#    - reset `'showcmd'`
#    - reset `'showmatch'`
#    - set `'matchtime'` to 0
#    - empty `'indentexpr'`
#    - replace `normal! ^` with sth like:
#
#         if getline('.') =~ '^\s*$'
#             call cursor(0, col('$'))
#         else
#             call search('^\s*\zs\S', 'bc', line('.'))
#         endif
#
#      in `$VIMRUNTIME/indent/html.vim` (function `HtmlIndent()`)
#
# Or you could install this autocmd which resets `'showmatch'` in html buffers:
#
#     augroup DisableShowmatchInHtmlFiles
#         autocmd!
#         autocmd BufEnter,WinEnter * &showmatch = &filetype != 'html'
#     augroup END
#}}}

# matchparen {{{2

g:matchparen_config = {
    # With `20`, in the Vim indent script, when we move on the opening bracket
    # at  the  end of  this  line,  *sometimes*  the  closing bracket  is  not
    # highlighted:
    #
    #     const BLOCKS: list<list<string>> = [
    timeout: 30,
    # TODO: set `timeout_insert` too (I think the default value is too high)
    on_startup: true,
    # compatible: false,
}

# matchpairs {{{2

augroup MyMatchpairs
    autocmd!
    autocmd FileType * SetMatchpairs()
augroup END

def SetMatchpairs()
    setlocal matchpairs+=<:>,“:”,‘:’
    # We  want the  keywords to  be searched  exactly as  we've written  them in
    # `b:match_words`, no matter the value of `&ignorecase`.
    b:match_ignorecase = 0
    # I don't want matchit/matchparen to consider fold markers as pairs!{{{
    #
    # Then remove  `{:}` from `'matchpairs'`, and  include a pair of  regexes in
    # `b:match_words`, using negative  lookarounds to prevent a match  in a fold
    # marker:
    #
    #     if exists('b:match_words')
    #         b:match_words ..= ',{\@1<!{{\@!:}\@1<!}}\@!'
    #         #                              ^
    #         #                              delimiter
    #     endif
    #}}}
    # Why don't you set `b:undo_ftplugin`?{{{
    #
    # So, you're thinking about sth like this:
    #
    #     b:undo_ftplugin = get(b:, 'undo_ftplugin', 'execute')
    #         .. '| set matchpairs< | unlet! b:match_ignorecase b:match_words'
    #
    # It would make sense  if we set them for *some* filetypes  only; but we set
    # them for *all* filetypes, so setting `b:undo_ftplugin` is useless.
    #}}}
enddef

# modelines {{{2

# If 'modeline' is set, and the value of 'modelines' is greater than 0, then Vim
# will search inside the first/last `&modelines` lines of the buffer and execute
# any `:set` commands it finds.

# This allows easy file-specific configuration.
# But we don't like that, for security reasons.

&modeline = false
&modelines = 0

# mouse {{{2

# enable mouse usage (all modes)
&mouse = 'a'

# nrformats {{{2

# when using the `C-a` and `C-x` commands, don't treat the numbers as octal
# E.g.:
#     `C-a` on 007
#     010  ✘˜
#     `C-a` on 007
#     008  ✔˜
set nrformats-=octal

# ignore a negative sign; makes the commands more intuitive when dealing with dates/zipcodes/...
set nrformats+=unsigned

# path {{{2

# Controls where these commands find {{{
#   files to jump to:{{{
#
#    - `gf`, `<C-W>f`, `<C-W>gf` (using name under the cursor)
#    - `gF`, `<C-W>F`, `<C-W>gF` (like above but take into account possible line address)
#    - `:find`, `:sfind`, `:tabfind` (using specified name)
#}}}
#   lines to display:{{{
#
#    - `[i`: first line in current file (or included file) containing the keyword under the cursor
#    - `]i`: like above, but start searching after the cursor
#    - `:isearch`: like above, but giving your own line range and search pattern
#    - `[I`, `]I`, `:ilist`: like above, but display all matches
#
# `[d`, `]d`, `:dsearch`, `:dlist`, `[D`, `]D` do the same thing but for macro definitions.
#}}}
#   lines in files to jump to:{{{
#
#    - `[<C-I>`, `]<C-I>`, `:ijump`: like `[i`, `]i`, `:isearch`
#    - `<C-W>i`, `:isplit`: like `[<C-I>`, `:ijump`, but in a new split window
#    - `:psearch`: like `:ijump`, but in the preview window
#
# `[<C-D>`, `]<C-D>`, `:djump`, `<C-W>d`, `:dsplit` do the same thing but for macro definitions.
#}}}
#   words to complete:{{{
#
#    - `<C-X><C-I>`: first keyword from current and included files starting with characters before cursor
#    - `<C-X><C-D>`: like above, but look for first definition name
#
# Note that  `<C-N>` and  `<C-P>` can  perform the same  kind of  completions as
# `<C-X><C-I>`, if `'complete'` contains the `i`  item.  In which case, they are
# also affected by `'path'`.
#}}}
#}}}
# Controls where these functions find files/directories:{{{
#
#    - `findfile()` and `finddir()`: only if they're not passed `{path}`
#    - `getcompletion()`: only for the `file_in_path` type
#}}}
&path = '.,,'
#        │ │
#        │ └ empty value = Vim's working directory
#        └ look in the directory of the current buffer, non-recursively

# Don't use a wildcard like `**`.{{{
#
# It could make one of the many previous commands (like `gf`) too slow.
# If for some reason, you really need `**`, at least limit the recursion:
#
#     &path = '**5'
#                ^
#                don't expand this into more than 5 subdirectories
#
# For more info, see `:help starstar`:
#
#    > - The maximum number of levels matched can be given by appending a number to '**'.
#}}}

# open folds if one these commands jump to some folded location
{
    var nice_view: string = 'zMzvzz'
    for cmd: string in ['[<C-I>', ']<C-I>', '<C-W>i']
        var dcmd: string = cmd->substitute('[iI]', () => submatch(0) == 'i' ? 'd' : 'D', '')
        execute $'nnoremap {cmd} {cmd}{nice_view}'
        execute $'nnoremap {dcmd} {dcmd}{nice_view}'
    endfor
}

# scroll {{{2

# display at least 3 lines above/below the cursor
&scrolloff = 3

# display at least 3 columns before/after the cursor
# when scrolling horizontally an unwrapped long line
&sidescrolloff = 3

# minimum nr of columns to scroll horizontally
&sidescroll = 5

# if we  scroll horizontally  on a very  long line while  we have  several bound
# windows, replicate the scroll across all of them
set scrollopt+=hor

# shortmess {{{2

# What does it do?{{{
#
# Prevent Vim  from printing the  “ATTENTION” message when an  existing swap
# file is found.
#}}}
# If I edit a file in a second Vim instance, will the change be reflected in the first?{{{
#
# Yes, it should whenever `CursorHold` is fired.
# Because, in `vim-xterm`, we have:
#
#    - a custom autocmd executing `:checktime`
#
#        it will check whether the file has been changed
#        outside the current Vim instance
#
#    - set 'autoread'
#
#        it will automatically reload the file if the file has been changed
#        outside the current Vim instance
#}}}
# What happens if I edit a file in a 2nd Vim instance, get back to the 1st, and change it before `CursorHold`?{{{
#
# In theory, Vim should warn you:
#
#     WARNING: The file has been changed since reading it!!!
#     Do you really want to write to it (y/n)?
#
# If you  don't want to lose the  changes from the 2nd Vim  instance, you should
# answer no.
# Then, wait for CursorHold, or execute `:checktime`.
#
# In practice, there  should be no such message, because,  in vim-xterm, we have
# an autocmd listening  to `FocusGained` and `FocusLost` which  reloads the file
# if it has been changed outside the current Vim instance.
#}}}
# Why don't you enable the flag anymore?{{{
#
# We deal with the “ATTENTION” message with an autocmd listening to `SwapExists`.
#}}}
#     &shortmess ..= 'A'

# enable all sort of abbreviations
&shortmess ..= 'a'
    # Don't print |ins-completion-menu| messages.  For example:{{{
    #
    #    - “-- XXX completion (YYY)”
    #    - “match 1 of 2”
    #    - “The only match”
    #    - “Pattern not found”
    #    - “Back at original”
    #}}}
    .. 'c'
    # don't print “search hit BOTTOM, continuing at TOP”
    .. 's'
    # C	don't give messages while scanning for ins-completion items,
    # for instance "scanning tags"
    .. 'C'
    # don't print the file info when editing a file, as if `:silent` was used
    .. 'F'
    # When starting  Vim without any argument,  we enter into an  unnamed buffer
    # displaying a long message; hide this message.
    .. 'I'
    # don't print “written” or “[w]” when writing a file
    .. 'W'

# signcolumn {{{2

# We want a margin between the left of the screen and the text.

# Why an autocmd?{{{
#
# Suppose you preview a file in a popup.
# In that  popup, `'signcolumn'` – like  all window-local options –  will be
# reset to its default value, which is `auto`.
#
# Now, at the same time, you start editing the same file in a regular window.
# In the latter, the value will *also* be set to `auto`, which means that if
# your buffer doesn't contain any sign, the sign column won't be visible; we
# want it to be *always* visible.
#}}}
augroup SetSigncolumn
    autocmd!
    autocmd BufWinEnter * if win_gettype() == 'popup' | &l:signcolumn = 'yes' | endif
    # We don't want `'signcolumn'` to be enabled in a terminal buffer.{{{
    #
    # Otherwise, it's disabled when we're in terminal-job mode, and enabled when
    # we enter terminal-normal mode.  This makes all the text move one character
    # forward/backward, which is distracting.
    #}}}
    autocmd TerminalWinOpen * &l:signcolumn = 'no'
augroup END

# Isn't the autocmd enough?{{{
#
# `BufWinEnter` is not always fired; e.g.  it's not fired when you display a
# dirvish buffer  in a  window.  In  such a case,  it's good  to have  set a
# global value which all windows should inherit.
#}}}
&signcolumn = 'yes'

# shell {{{2

# How is this option set by default?{{{
#
# With `$SHELL`, if the latter is set.
# With `sh` otherwise.
#}}}
#   What does it control?{{{
#
# For some commands/functions, Vim needs to start a shell:
#
#    - `!`
#    - `:!`
#    - `:terminal`
#    - `system()`
#    ...
#
# `'shell'` tells Vim which one should be started.
#}}}

# `bash` is more reliable than whatever we happen to be using for an interactive shell. {{{
#
# Using a non-typical and/or complex shell  increases the chances that we find
# weird bugs that few people can reproduce.
#
# Example: https://github.com/vim/vim/issues/8951#issuecomment-934442496
#
# It's not  worth losing  time debugging  these issues.   We don't  care which
# shell  Vim starts  for  `!`, `:!`,  `system()`...  We  just  want these  Vim
# commands/functions to run some shell commands; how they do it is irrelevant.
#}}}
# Don't use `sh`.{{{
#
# It doesn't support some bashisms syntaxes which we sometimes use, like `<<<`.
#}}}
if $SHELL !~ '/bash$'
    # Using a full path is more efficient.{{{
    #
    # You could simply assign `sh`:
    #
    #     &shell = 'sh'
    #               ^^
    #               ✘
    #
    # But Vim  would execute several  `execve(2)` system calls  before finding
    # the right location.  You can check this yourself with `strace(1)`:
    #
    #     $ strace --output=$TMPDIR/vim/trace.log --trace=execve -f vim -Nu NONE +'set shell=bash | silent !' +quitall
    #     $ less $TMPDIR/vim/trace.log
    #     ... execve("/home/lgc/bin/bash", ["bash", "-c", ""], ...) = -1 ENOENT ...
    #     ... execve("/home/lgc/.local/bin/bash", ["bash", "-c", ""], ...) = -1 ENOENT ...
    #     ...
    #     ... execve("/usr/bin/bash", ["bash", "-c", ""], ...) = 0
    #}}}
    &shell = '/usr/bin/bash'
endif

# What if I want to start an interactive terminal with `:terminal`?{{{
#
# If you want to get your usual interactive shell, and it's not bash, you can no
# longer simply execute `:terminal`.  Instead, try this:
#
#     :execute $'terminal ++close {$INTERACTIVE_SHELL ?? &shell}'
#
# This assumes that you set `$INTERACTIVE_SHELL` to the path to your interactive
# shell in one of your shell init files.
#
# The fact that it's longer to type is not an issue: just install a mapping or a
# user-defined command.
#}}}
#   What about `term_start()`?{{{
#
# Same deal.  You can no longer refer to the shell via `&shell`:
#
#     term_start(&shell, ...)
#                ^----^
#                  ✘
#
# Instead:
#
#     term_start($INTERACTIVE_SHELL ?? &shell, ...)
#                ^--------------------------^
#                             ✔
#}}}

# smoothscroll {{{2

# TODO: Commented out until this issue is fixed:
# https://github.com/vim/vim/issues/12970
#
#     &smoothscroll = true

# spell* {{{2

# To prevent `E764: Option 'spellfile' is not set`.{{{
#
# That can happen when  we press `zG` (custom mapping) which executes `normal! zg`.
#}}}
# According to `:help 'spellfile'`, that should be done automatically:{{{
#
#    > When a word is added while this option is empty Vim will set it for
#    > you: Using the first directory in 'runtimepath' that is writable.
#
# But for some reason, that's not always the case:
#
#     $ vim -Nu NONE +'call setline(1, "typoX")' +'normal! zg'
#     E764: Option 'spellfile' is not set
#
# It *can* be set automatically, but only after `zG` has been executed:
#
#     $ vim -Nu NONE +'call setline(1, "typoX")' +'normal! zG' +'normal! zg'
#     Word 'text' added to ~/.vim/spell/en.utf-8.add
#}}}
&spellfile = $'{$HOME}/.vim/spell/en.utf-8.add'

#     set spelloptions= | echo spellbadword('TheCamelWord')
#     ['TheCamelWord', 'bad']˜
#
#     set spelloptions=camel | echo spellbadword('TheCamelWord')
#     ['', '']˜
#
#                                                         typo
#                                                         v
#     set spelloptions=camel | echo spellbadword('TheCamelzWord')
#     ['Camelz', 'bad']˜
&spelloptions = 'camel'

# startofline {{{2

# Some commands move the cursor to the first non-blank of the line:
#
#     C-d, C-u, C-b, C-f, G, H, M, L, gg, :123, :+    (motions)
#     dd, <<, >>                                      (operators)
#     C-^, :bnext, :bprevious
#
# We prefer the cursor to stay on the same column as before.
&startofline = false

# switchbuf {{{2
#         How to configure 'switchbuf'?{{{

# You give it a list of values.  Example:
#
#     &switchbuf = 'useopen,usetab'
#}}}
#         What does it do?{{{

# If you  try to open a  split to display  a loaded buffer with  `:sbuffer`, Vim
# will first check  whether the buffer is  already displayed in a  window of the
# current tab page (`useopen`), or in another tab page (`usetab`).
# And if  it finds one,  instead of  creating a split,  it will simply  give the
# focus to this window.
#}}}
#         Which commands honor 'switchbuf'?{{{

# Quickfix commands, when jumping to errors (`:cc`, `:cn`, `cp`, etc.).
# All buffer related split commands: `:sbuffer`, `:sbnext`, `:sbrewind`...
#}}}
#         Which pitfalls can it create?{{{

# When you move in the qf list quickly,  the focus can change from a window to
# another and it's  distracting.  Besides, once the focus has  changed, if you
# advance further in  the qf list, it  can make you lose the  buffer which was
# opened in the window.
#}}}
#         Why don't you set it?{{{
#
#    - too many issues
#    - we don't need it ATM
#    - to give the focus to an already displayed buffer, there are alternatives:
#
#         :FzWindows  (<Space>fw)
#         :drop       (:drop ~/**/*some_file + Tab)
#}}}
#}}}2
# synmaxcol {{{2

# don't syntax highlight long lines
&synmaxcol = 250
#            ^^^
#            weight in bytes;
#            any character prefixed by a string heavier than that will *not* be syntax highlighted
# }}}2

# t_ {{{2
if !has('gui_running')
# <S-Tab> {{{3

if &term =~ '^st\%(-256color\)$'
    # `<S-Tab>` might not work in st, because Vim might not set `t_kB`.{{{
    #
    # Right now, for st, we use the terminfo description from the ncurses developer.
    # It turns out that it cancels the `kcbt` capability:
    #
    #     st-256color|stterm-256color|simpleterm with 256 colors,
    #             ccc@,
    #             initc@, oc@, use=xterm+256color, use=st,
    #                                              ^----^
    #     st|stterm| simpleterm,
    #             use=st-0.7,
    #             ^--------^
    #     st-0.7|simpleterm 0.7,
    #             ccc,
    #             dim=\E[2m,
    #             initc=\E]4;%p1%d;rgb\:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*
    #                   %{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\E\\,
    #             kcbt@, kent@, oc=\E]104\007,
    #             ^---^
    #
    # As a result, Vim does not set `t_kB` when `&term` is `st`.
    #}}}
    &t_kB = "\<Esc>[Z"
endif

# clearing {{{3

# `ut`/`bce` is a misfeature.  Don't use it no matter what.{{{
#
#    > bce is a truly problematic (mis)feature, whoever designed it must have been out of their minds.
#
# Source: https://github.com/kovidgoyal/kitty/issues/160#issuecomment-346470545
#
# ---
#
# If `'t_ut'` has the  value `y`, Vim uses the background  color of the terminal
# to clear empty screen cells.
#
# From `:help 't_ut'`:
#
#    > t_ut    clearing uses the current background color      *t_ut* *'t_ut'*
#
# From `man terminfo /bce`:
#
#    > Some terminals (including many PC  terminal emulators) erase screen areas with
#    > the  current background  color rather  than the  power-up default  background;
#    > these should have the boolean capability bce.
#
# We don't want that.
# First, in kitty, it  would cause the background of the  terminal to bleed into
# the color scheme background.
#
# Second, it can cause some flickering.
# For example,  if we  execute the  normal command  `C-L` (interactively  or via
# `:normal!`), the  status line (and even  the whole screen) might  flicker.  To
# avoid this issue,  we clear the option;  it means that Vim should  now use the
# background color of the highlight group `Normal`.
# }}}
&t_ut = ''

# focus events {{{3

# Let's make sure that `FocusGained` and `FocusLost` work in (xterm/st)+tmux.
# See: `:help xterm-focus-event`.
if &t_fe == ''
    &t_fe = "\<Esc>[?1004h"
    &t_fd = "\<Esc>[?1004l"
    execute "set <FocusGained>=\<Esc>[I"
    execute "set <FocusLost>=\<Esc>[O"
endif

# modified keys {{{3

# How to make sure that a function key (`<F1>`, `<Up>`, `<Home>`, ...) works correctly with and without modifiers?{{{
#
# Let's take `<Home>` as an example.
#
# First, write somewhere  all the raw input sequences generated  by the terminal
# when you press `<Home>` with and without modifiers.
#
# Now, all  you have to  do is to  make sure that  each of these  sequences is
# assigned to *any* relevant entry in Vim's internal termcap database; that is
# `<Home>`, `<xHome>`, or `<zHome>`.  But  not `<kHome>`; for Vim, this keysym
# represents  a different  physical key  (contrary to  `<xHome>` or  `<zHome>`
# which seem to be mere synonyms of `<Home>`).
#
# For  example,  in xterm,  `<Home>`  generates  `^[OH`,  while a  modified  one
# generates `^[[1;XH` (where X is a  digit encoding the modifier).  So, to fully
# support `<Home>`, you could write:
#
#     execute "set <Home>=\<Esc>[1;*H"
#     execute "set <xHome>=\<Esc>OH"
#
# Or you could use the same settings, but reverse the values:
#
#     execute "set <Home>=\<Esc>OH"
#     execute "set <xHome>=\<Esc>[1;*H"
#
# Or you could  use the same settings, but replace  `<Home>` with `<xHome>`, and
# `<xHome>` with `<zHome>`:
#
#     execute "set <xHome>=\<Esc>[1;*H"
#     execute "set <zHome>=\<Esc>OH"
#}}}
# Which digit is used to encode which modifier?{{{
#
#     ┌────────────────┬───┐
#     │ shift          │ 2 │
#     ├────────────────┼───┤
#     │       alt      │ 3 │
#     ├────────────────┼───┤
#     │           ctrl │ 5 │
#     ├────────────────┼───┤
#     │ shift+alt      │ 4 │
#     ├────────────────┼───┤
#     │ shift    +ctrl │ 6 │
#     ├────────────────┼───┤
#     │       alt+ctrl │ 7 │
#     ├────────────────┼───┤
#     │ shift+alt+ctrl │ 8 │
#     └────────────────┴───┘
#}}}
# Does `TERM` influence the raw sequence generated by a keypress?{{{
#
# No.  Take `<Home>`  as an example, it generates  different sequences depending
# on whether you're in xterm or xterm+tmux:
#
#     xterm:      ^[OH
#     xterm+tmux: ^[[1~
#
# Now, if  you start  Vim *outside*  tmux, but  with `TERM=tmux`,  `<Home>` will
# still generate  the same sequence  as if you  had left `TERM`  unchanged (i.e.
# `^[OH`).
#
# IOW, xterm sends its own sequence  regardless of how `TERM` is set (probably
# hard-coded).   Same thing  for tmux;  although, if  the latter  receives the
# sequence from  xterm (does  it?), then  it must  probably translate  it into
# another.
#}}}
# Some chords using the `Alt` or `Ctrl` modifier generate an unexpected `^[[O` sequence!{{{
#
# That's `<FocusLost>`; ignore it.
#
# I think that  happens when the chord is intercepted  by another program before
# Vim (OS,  window manager, ...);  Vim temporarily  loses the focus  for another
# program, and  `<FocusLost>` is automatically  emitted when Vim gets  the focus
# back.
#
# If you want to know the real sequence,  find a way to – at least temporarily
# – remove the offending key binding.
#
# At the moment, that happens for example with `<A-Del>`, `<A-F1>` and `<C-F1>`.
#}}}
# Why don't you enable keys on the keypad too?{{{
#
# So you mean any keysym starting with a `k` prefix, like:
#
#     <k1>
#     <k2>
#     <k3>
#     <k4>
#     <k5>
#     <k6>
#     <k7>
#     <k8>
#     <k9>
#
#     <kHome>
#     <kEnd>
#
#     <kPageUp>
#     <kPageDown>
#
#     <kPlus>
#     <kMinus>
#     <kMultiply>
#     <kDivide>
#
#     <kDel>
#     <kEnter>
#     <kPoint>
#
# Well, first we don't really use any of them.
#
# But also, the keys on the keypad might be in 2 states depending on whether the
# numlock led is on  or off.  It seems that `<k...>` keysyms  only work when the
# led is off.
#
# Besides, it  seems that  these keysyms  don't even  work with  Vim's default
# termcap database.   Not sure whether  it should be  fixed in Vim  itself, or
# whether we should only suggest a fix via  a new help tag (to not break a Vim
# installed  on an  old  system  where the  old  termcap  entries have  always
# worked).
#
# Finally, it  seems that for  a given key on  the keypad, when  it's combined
# with modifiers, the  terminal might generate very  different sequences which
# can't be matched with a single entry in Vim's termcap database.  But we only
# have one entry.   I guess we could settle on  only supporting the unmodified
# keys...
#}}}

# Support `<Del>`, and `<F1>` to `<F4>` *with* modifiers.
# The default values only support these keysyms without modifiers.
execute "set <Del>=\<Esc>[3;*~"

execute "set <F1>=\<Esc>O*P"
execute "set <F2>=\<Esc>O*Q"
execute "set <F3>=\<Esc>O*R"
execute "set <F4>=\<Esc>O*S"

execute "set <xF1>=\<Esc>[1;*P"
execute "set <xF2>=\<Esc>[1;*Q"
execute "set <xF3>=\<Esc>[1;*R"
execute "set <xF4>=\<Esc>[1;*S"

# necessary for tmux
if &term !~ 'xterm'
    # support modified arrow keys, see:  `:help xterm-modifier-keys`
    execute "set <xUp>=\<Esc>[@;*A"
    execute "set <xDown>=\<Esc>[@;*B"
    execute "set <xRight>=\<Esc>[@;*C"
    execute "set <xLeft>=\<Esc>[@;*D"

    # Support modified Home, End.
    # See  `:help xterm-function-keys`
    execute "set <xHome>=\<Esc>[1;*H"
    execute "set <xEnd>=\<Esc>[1;*F"

    # support modified PageUp, PageDown
    execute "set <PageUp>=\<Esc>[5;*~"
    execute "set <PageDown>=\<Esc>[6;*~"
    # We need to clear those for `<PageUp>` and `<PageDown>` to work in some terminals.{{{
    #
    # For example, in st, `<kPageUp>` is set with `^[[5~`.
    # Because of this, when we press `<PageUp>`, Vim translates the raw sequence
    # into `<kPageUp>`.   We don't want that.   If we press `<PageUp>`,  we want
    # the guarantee that Vim will translate it into `<PageUp>`.
    #}}}
    set <kPageUp>=
    set <kPageDown>=

    # support F5 to F12 function keys
    execute "set <F5>=\<Esc>[15;*~"
    execute "set <F6>=\<Esc>[17;*~"
    execute "set <F7>=\<Esc>[18;*~"
    execute "set <F8>=\<Esc>[19;*~"
    execute "set <F9>=\<Esc>[20;*~"
    execute "set <F10>=\<Esc>[21;*~"
    execute "set <F11>=\<Esc>[23;*~"
    execute "set <F12>=\<Esc>[24;*~"
endif
#}}}3
# paste {{{3

# What's the bracketed paste mode?{{{
#
# A  special  mode in  which  the  terminal surrounds  a  pasted  text with  the
# sequences `Esc [ 200 ~` and `Esc [ 201 ~`.
#}}}
#   How is it useful?{{{
#
# Thanks to these sequences, the application  which receives the text knows that
# it was  not typed  by the  user, but pasted,  and that  it should  disable the
# interpretation of what it considers to be special characters.
#
# MRE:
#
#     let @+ = "clipboard\<Esc>:echomsg \"malicious code injected\"\<CR>i"
#     startinsert
#     # press: C-S-v
#     # press: Esc
#     :messages
#     malicious code injected˜
#
# In this  example, the escape,  colon and  carriage return were  interpreted as
# “enter normal mode”, “enter command-line mode”, and “run command”.
#
# As you can see,  this can be dangerous, because if you  don't pay attention to
# what you've copied, Vim might run an unexpected command.
#
# Other MRE:
#
#     let @+ = "Level 1\n    Level 2\n    Level 2\nLevel 1"
#     setlocal autoindent
#     startinsert
#     # press: C-S-v
#     Level 1˜
#         Level 2˜
#             Level 2˜
#             Level 1˜
#
# Notice how the indentation of some lines is increasingly wrong.
# This is  because when  you enter  a new  line, if  `'autoindent'` is  set, Vim
# automatically autoindents the new line.
#}}}
#   Is it 100% reliable?{{{
#
# No, unfortunately.
#
# The protection  offered by  the bracketed  paste mode can  be bypassed  if the
# pasted text contains `\<Esc>[201~`; the latter will end the bracketed mode prematurely.
# This works  because, before sending the  text to the application,  some (all?)
# terminals do not properly filter escape sequences before adding their own.
#
# See the second example on this page:
# https://thejh.net/misc/website-terminal-copy-paste
#
# ---
#
# Also, the  bracketed paste mode does  not prevent Vim from  auto-indenting the
# text when inserting the contents of a register with `C-r`.
#
# MRE:
#
#     set autoindent
#     let @a = "Level 1\n    Level 2\n    Level 2\nLevel 1"
#     # press: i C-r a
#
# If `'paste'` is reset, you'll get:
#
#     Level 1˜
#         Level 2˜
#             Level 2˜
#             Level 1˜
#
# If `'paste'` is set, you'll get:
#
#     Level 1˜
#         Level 2˜
#         Level 2˜
#     Level 1˜
#
# You can avoid the issue by pasting from normal mode (`"ap`), or inserting with
# `C-r C-o` or `C-r C-p`.
#}}}
#   How many software layers need to support this mode for it to work properly?{{{
#
# The terminal and the application which is running in the foreground.
#
# You probably don't need to configure the  terminal; it just needs to be recent
# enough.   Except  for  tmux, which  is  a  special  case.   When you  use  the
# `paste-buffer` command, you must pass it the `-p` option.
#
# And  note that  whether the  foreground  application needs  to be  configured,
# depends on its default configuration.
# For example, zsh automatically sets the parameter `zle_bracketed_paste`:
#
#    > This two-element array  contains the terminal escape  sequences for enabling
#    > and  disabling  the  feature. These  escape sequences  are  used  to  enable
#    > bracketed paste when ZLE is active and disable it at other times.  Unsetting
#    > the  parameter has  the  effect  of ensuring  that  bracketed paste  remains
#    > disabled.
#
# Which enables the bracketed paste mode.
# But if you unset the parameter, you disable the mode.
# So, it's just a choice from the devs to enable the mode by default.
# Note that you can see the current value of the parameter by running:
#
#     $ typeset zle_bracketed_paste
#
# See: `man zshparam /zle_bracketed_paste`
#
# OTOH, for bash, you need to set the readline variable `enable-bracketed-paste`.
# It is not set by default.
#}}}

#   How to make the terminal enter/leave this mode while Vim is running?{{{
#
# Set the options `'t_BE'` and `'t_BD'`, with the values `CSI ? 2004 h`
# and `CSI ? 2004 l`.
# These sequences are documented at `CSI ? Pm h/;/Ps = 2 0 0 4`
# and `CSI ? Pm l/;/Ps = 2 0 0 4`.
#
# When the terminal enters raw mode,  Vim sends to it `&t_BE` (Bracketed paste Enable).
# And when the terminal leaves raw mode, Vim sends `&t_BD`.
# So,  if  these options  are  properly  set,  the terminal  will  automatically
# enable/disable the bracketed paste mode whenever it enters/leaves raw mode.
# IOW, the raw and bracketed paste modes will be synchronized.
#
# You also need  to set the options  `'t_PS'` and `'t_PE'` with  the values
# `CSI 200 ~` and `CSI 201 ~`. Probably  to let Vim know which sequences it must
# interpret as the beginning/end of a pasted text.
#
# For more info, see `:help xterm-bracketed-paste`.
#
#    > When the 't_BE' option is set then  't_BE' will be sent to the terminal when
#    > entering "raw"  mode and 't_BD'  when leaving  "raw" mode.  The  terminal is
#    > then  expected to  put 't_PS'  before pasted  text and  't_PE' after  pasted
#    > text.  This  way Vim can separate  text that is pasted  from characters that
#    > are typed.  The pasted text is handled  like when the middle mouse button is
#    > used, it is inserted literally and not interpreted as commands.
#}}}
#     Now you're talking about yet another mode!  What's this raw mode?{{{
#
# A mode in which the terminal driver doesn't interpret the characters it receives.
#
#    > The  terminal can  be placed  into  "raw" mode  where the  characters are  not
#    > processed by the terminal driver, but are sent straight through (it can be set
#    > that INTR and QUIT characters  are still processed). This allows programs like
#    > emacs and vi to use the entire screen more easily.
#
# Source: https://unix.stackexchange.com/a/21760/289772
#
# See also `:help raw-terminal-mode`.
#}}}
#       When Vim is running, is the terminal in raw mode?{{{
#
# I think it depends.
#
# Most of the time, it must be, so  that Vim can receive all the keys pressed by
# the user, and interpret them however it wants.
# Among other things, this allows the user to remap `C-c`, `C-u`, `C-d`, ...
# which otherwise would be interpreted by the line discipline of the terminal:
#
#     $ stty -a | grep 'intr\|kill'
#     intr = ^C; quit = <undef>; erase = ^?; kill = ^U; eof = ^D; eol = <undef>;˜
#            ^^                                     ^^        ^^
#
# However, sometimes, Vim temporarily switches to cooked mode.
# This allows  the user to end  an external process started  with `system()`, by
# pressing `C-c`.
#}}}
#       What's the relationship between raw mode and bracketed paste mode?{{{
#
# I don't think there's one.
# I  think  they  are  orthogonal,  i.e. the  terminal  can  enable/disable  one
# independently of the other's state.
#}}}

# Why can't we enable the bracketed paste mode for the whole Vim session?{{{
#
# Why this dance: enter raw mode → enable bracketed paste
#                 leave raw mode → disable bracketed paste
#
# Instead of:     enter Vim → enable bracketed paste
#                 leave Vim → restore bracketed paste as it was before Vim was started
#
# Theory: Remember that you  can start an external process from  Vim (e.g. via
# `system()`).  While Vim is running, the foreground process might not be Vim,
# and  it might  or might  not  want the  terminal  to be  in bracketed  paste
# mode.  I think that's why Vim disables the bracketed paste mode when leaving
# raw mode; so that the foreground process does not receive sequences which it
# doesn't understand.
#
# See: https://github.com/vim/vim/issues/1638
#}}}

# Why `&t_BE == ''`?{{{
#
# Because Vim already sets these options  for some terminals (e.g. xterm), but
# not all.  In particular,  it fails to set them for st,  and for any terminal
# in  tmux.   Presumably because  it  only  recognizes  a few  terminals  (via
# `&term`) which it knows how to configure.
#}}}
if &t_BE == ''
    &t_BE = "\<Esc>[?2004h"
    &t_BD = "\<Esc>[?2004l"
    &t_PS = "\<Esc>[200~"
    &t_PE = "\<Esc>[201~"
endif

# strikethrough {{{3

# Necessary when `&term` is not `xterm` to be able to apply the strikethrough attribute to text:{{{
#
#     :highlight MyStrikeThrough cterm=strikethrough
#     :highlight MyStrikeThrough
#     MyStrikeThrough xxx cterm=strikethrough
#                     ^^^
#}}}
&t_Ts = "\<Esc>[9m"
&t_Te = "\<Esc>[29m"

# undercurl/underlines {{{3

# undercurl
#     :highlight MyUndercurl cterm=undercurl
#     :highlight MyUndercurl
#     MyUndercurl xxx cterm=undercurl
#                 ^^^
&t_Cs = "\<Esc>[4:3m"

# double underline
#     :highlight MyDoubleUnderline cterm=underdouble
#     :highlight MyDoubleUnderline
#     MyDoubleUnderline xxx cterm=underdouble
#                       ^^^
&t_Us = "\<Esc>[4:2m"

# dotted underline
#     :highlight MyDottedUnderline cterm=underdotted
#     :highlight MyDottedUnderline
#     MyDottedUnderline xxx cterm=underdotted
#                       ^^^
&t_ds = "\<Esc>[4:4m"

# dashed underline
#     :highlight MyDashedUnderline cterm=underdashed
#     :highlight MyDashedUnderline
#     MyDashedUnderline xxx cterm=underdashed
#                       ^^^
&t_Ds = "\<Esc>[4:5m"

#     :highlight MyColoredUnderline cterm=underline guisp=Red guifg=Green
#     :highlight MyColoredUnderline
&t_8u = "\<Esc>[58;2;%lu;%lu;%lum"
# only necessary to set the color of the text above the underline
&t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
# It doesn't work!{{{
#
# Make sure the terminal supports the feature with one of these commands:
#
#     $	printf '\e[4m\e[58;5;196mColored Underline\e[m\n'
#     $	printf '\e[4m\e[58;2;255;0;0mColored Underline\e[m\n'
#
# The printed text should be underlined in  red.  The first command uses a color
# from the terminal 256-color palette.  The second one uses a 24-bit truecolor.
#
# If you use a terminal multiplexer like tmux, you might also need some extra setting.
# Example:
#
#     set-option -as terminal-features '*:usstyle'
#
# If the  issue persists, it  might be because the  terminal is not  detected as
# xterm compatible.  If so, try this:
#
#     &t_RV = "\<Esc>[>c"
#
# For more info, see:
# https://github.com/vim/vim/issues/10239#issuecomment-1107182341
#}}}

# end undercurl/underline
&t_Ce = "\<Esc>[4:0m"

# xterm-codes {{{3

# Resetting this option might avoid weird issues in xterm:
# https://github.com/vim/vim/issues/4836
# https://github.com/vim/vim/issues/6206
# https://github.com/vim/vim/issues/2581
#
# See `:help xterm-codes`.

# Alternative: `&t_RV = ''`
&xtermcodes = false
#}}}3
endif
# }}}2
# tags {{{2

# When searching the tags file, ignore the case unless an upper case letter is used.
&tagcase = 'smart'

# What's the default value? {{{
#
#     ./tags,./TAGS,tags,TAGS
#
# Explanation:
#
#    ┌────────┬──────────────────────────────────────────────────────────────────┐
#    │ ./tags │ file in the directory of the CURRENT FILE and whose name is tags │
#    ├────────┼──────────────────────────────────────────────────────────────────┤
#    │ tags   │ file in the WORKING DIRECTORY             and whose name is tags │
#    └────────┴──────────────────────────────────────────────────────────────────┘
#}}}
# What's the effect of our new value `./tags;`?{{{
#
# `;` tells Vim to look *up* recursively.
# It's the opposite of `**` which looks *down* recursively.
# You could also include the value `tags;`:
#
#     &tags = './tags;,tags;'
#
# Explanation:
#
#    ┌─────────┬──────────────────────────────────────────────────────────────┐
#    │ ./tags; │ file in the directory of the CURRENT FILE, then              │
#    │         │ in its parent directory, then in the parent of the parent    │
#    │         │ and so on, recursively                                       │
#    ├─────────┼──────────────────────────────────────────────────────────────┤
#    │ tags;   │ file in the WORKING DIRECTORY, then in its parent directory, │
#    │         │ then in the parent of the parent and so on, recursively      │
#    └─────────┴──────────────────────────────────────────────────────────────┘
#
# The value of `'tags'` influences commands such as `:tjump` and `:ltag`.
# It also influences tag completion (`:help  i^x^]`), which looks for matches in
# the tags files whose paths are stored in the value of `'tags'`.
#}}}
&tags = './tags;'
augroup Tags
    autocmd!
    # In our vimrc file, we want the ability to jump from the call of a function
    # defined in `myfuncs.vim`, to its definition, with `C-]`.
    autocmd BufReadPost $MYVIMRC &l:tags =  $'{$HOME}/.vim/autoload/tags'

    autocmd BufWritePost * ReGenerateTags('later')
augroup END

var run_ctags_in_these_directories: list<string>
def ReGenerateTags(when: string)
    if when == 'now'
        if run_ctags_in_these_directories->empty()
            return
        endif
        for dir: string in run_ctags_in_these_directories
            RunCtags(dir)
        endfor
        run_ctags_in_these_directories = []
        return
    endif

    #     when == 'later'

    if !exists('b:repo_root')
            || !b:repo_root->isdirectory()
            || run_ctags_in_these_directories->index(b:repo_root) >= 0
        return
    endif

    run_ctags_in_these_directories
        ->add(b:repo_root)

    # No need to generate the tags on every single write.
    # Delay until the next `CursorHold`.
    augroup ReGenerateTags
        autocmd!
        autocmd CursorHold * ++once ReGenerateTags('now')
    augroup END
enddef

def RunCtags(source_code: string)
    var tagfile: string
    if source_code->isdirectory()
        tagfile = source_code->trim('/', 2)
    else
        tagfile = source_code->fnamemodify(':h')
    endif
    tagfile ..= '/tags'
    job_start(['ctags', '-f', tagfile, '--recurse', source_code])
enddef

# temporary files:  undo, swap, backup {{{2

# TODO: Read these:
# https://www.zachpfeffer.com/single-post/Practice-Recovering-a-File-in-Vim
# https://begriffs.com/posts/2019-07-19-history-use-vim.html#backups-and-undo
# https://vi.stackexchange.com/a/53/13370
#
# ---
#
# Try to expose the info given by `swapinfo()` via a custom command.
# Maybe it could open a scratch buffer to display the info.

if !isdirectory($'{$HOME}/.vim')
    # `0o` is necessary for the octal to decimal conversion which is no longer
    # automatic in Vim9.
    mkdir($'{$HOME}/.vim', '', 0o700)
endif

# Put all swap files in `~/.local/share/vim/swap/`.{{{
#
# The default value is:
#
#     .,~/tmp,/var/tmp,/tmp
#     ^
#
# With this  value, if you  edit a file,  the swap file  will be created  in the
# parent directory of the file.
# IOW, your  swap files will be  scattered across your whole  filesystem; that's
# untidy, especially when Vim crashes, and the swap files persist.
#}}}
# Why the trailing double slash?{{{
#
# It's useful  if you  edit two  files with  the same  name, but  in different
# directories.
#
# Suppose  you  edit  `/tmp/dir1/file`   and  `/tmp/dir2/file`.   Without  the
# trailing double slash,  both swap files would have the  same name.  The last
# one to be created would probably overwrite the previous one.
#
# With  the trailing  double slash,  the  name of  each swap  file is  unique,
# because  it includes  the full  path  to the  file it's  associated to;  the
# slashes are replaced by percent signs.  From `:help 'directory'`:
#
#    > For Unix and Win32, if a directory ends in two path separators "//", the
#    > swap file name will be built from the complete path to the file with all
#    > path separators substituted to percent  '%' signs. This will ensure file
#    > name uniqueness in the preserve directory.
#}}}
&directory = $'{$HOME}/.local/share/vim/swap//'

# make sure the swap directory exists
if !isdirectory(&directory)
    mkdir(&directory, 'p', 0o700)
endif

# enable persistent undo
&undofile = true

# choose location of undo files
&undodir = $'{$HOME}/.local/share/vim/undo'

# If you  lose the undo  history after a buffer  reload (or write),  you might
# want to increase  the value of this  option.  But beware that  it causes the
# whole buffer  to be stored  in memory,  which in turn  causes Vim to  have a
# larger memory footprint.
&undoreload = 10'000

# make sure the undo directory exists
if !isdirectory(&undodir)
    mkdir(&undodir, 'p', 0o700)
endif

&backup = true

# See `:help backup-table` to understand when Vim creates a backup file.
&backupdir = $'{$HOME}/.local/share/vim/backup//'
#                                             ^^
# `//`: To ensure file name uniqueness in the backup directory, build the name
# of a backup file from the complete path to the file with all path separators
# changed to percent '%' signs.
set backupskip+=/run/*

# make sure the backup directory exists
if !isdirectory(&backupdir)
    mkdir(&backupdir, 'p', 0o700)
endif

# timeout {{{2

# enable a timeout for mappings
&timeout = true

# same thing for key codes
&ttimeout = true

# set the timeout for mappings to 3s
&timeoutlen = 3'000

# ... and 6 ms for key codes.
# Previously we used 50ms, but 6 is the max value to prevent this error:{{{
#
#    1. insert sth wrong
#    2. press escape
#    3. press `u` (undo)    →    M-u: uppercase next word
#
# Vim recognizes `M-u` as `Esc + u`, because of this line in vim-readline:
#
#     execute "set <M-U>=\<Esc>u"
#
# So, if we press `Esc` then `u` in less than `&ttimeoutlen` ms, Vim thinks that
# we've pressed `M-u`.   To avoid this kind of misunderstanding,  we need to set
# `'ttimeoutlen'` as low as possible.
#}}}
#   What other issue does this fix?{{{
#
# The default value of `'ttimeoutlen'` is -1.
# It means that it copies the value of `'timeoutlen'`, which we've set to 3s.
# Now suppose that you're in insert mode, and want to get back to normal mode by
# pressing `Esc`: you'll have to wait 3s.
#
# Why?
# Because  some special  keys (e.g. F1,  F2, ...,  left, right,  ...) produce  a
# sequence of terminal key codes beginning with `Esc`.
# So, Vim has to  wait `'ttimeoutlen'` ms to know whether  the `Esc` was pressed
# manually or it was part of some sequence of terminal key codes.
#}}}
#   What issue(s) can this cause?{{{
#
# If Vim is running on a remote machine, a low value could be insufficient for a
# key code to reach the latter.
#
# For example,  if we press `M-u`  and our local  machine sends `Esc +  u`, more
# than `&ttimeoutlen` ms could elapse  between `Esc` reaching the remote machine
# and `u`.  In  that case, Vim will  think we pressed `Esc` then  `u` instead of
# `M-u`.
#
# ---
#
# With a low value, the contents of a recording is weird:
#
#     set ttimeoutlen=6
#     # press: qqq
#     # press: qq A Esc q
#     echo @q
#     A^[<80><fd>a˜
#
# It makes reading  the contents of a register, and  `/tmp/.vimkeys` harder than
# it should be.
#
# Note that it disappears below a certain threshold which can vary (≈ 300ms?).
#
# See: https://github.com/vim/vim/issues/4725
#}}}
&ttimeoutlen = 6

# ttymouse {{{2

# This option might help when you need to interact with Vim with your mouse.{{{
#
# In particular,  it might  help resizing a  tmux pane where  Vim is  running by
# dragging its status line: http://superuser.com/a/550482
#
# It might also help clicking after the 223rd column.
#
# ---
#
# The best value seems to be `sgr`.
# From `:help 'ttymouse`:
#
#    > The "sgr"  value will be set  if Vim detects Mac  Terminal.app, iTerm2 or
#    > mintty, and when the xterm version is 277 **or higher**.
#
# It's the value used by Vim when it detects a recent xterm.
#}}}
&ttymouse = 'sgr'

# updatetime {{{2

&updatetime = 2'000

# viminfo {{{2

# To suppress an error:{{{
#
#     E528: Must specify a ' value: viminfo+=!
#
# For example,  when Vim is started  as `ex(1)`, `'viminfo'` is  empty, and so
# it's missing the `'100` item.
#}}}
if &viminfo != ''
    # useful to save variables such as `g:MY_VAR`
    set viminfo+=!

    # Ignore files under `$XDG_RUNTIME_DIR/gvfs`.
    # They can make `recent.Files()` (fz plugin) too slow.{{{
    #
    # That's because `filereadable()`  might be too slow on  files from inside
    # this directory:
    #
    #     # ~/.vim/pack/mine/opt/fz/autoload/fz/recent.vim
    #                                                v------v
    #     + (filereadable($'{$HOME}/.local/share/vim/oldfiles')
    #     ...
    #     ->filter((_, v: string): bool => util.Expand(v)->filereadable()
    #                                                      ^------------^
    #
    # For example:
    #
    #     :Time silent echo filereadable($'{$XDG_RUNTIME_DIR}/gvfs/ftp:host=ftp.vim.org/pub/vim/patches/8.1/README')
    #     0.125 seconds to run :echo filereadable($'{$XDG_RUNTIME_DIR}/gvfs/ftp:host=ftp.vim.org/pub/vim/patches/8.1/README')
    #       ^^^
    #       if you don't get such a slow time, try to open a FTP link with Vim first
    #
    # This is way too much; compare with a regular file:
    #
    #     :Time silent echo filereadable('/tmp/file')
    #     0.000 seconds to run :echo filereadable('/tmp/file')
    #       ^^^
    #
    # This can quickly add up, and make `recent.Files()` slow (several seconds).
    #}}}
    set viminfo+=r$XDG_RUNTIME_DIR/gvfs/
    #            ^
    # Originally this feature was meant to ignore **r**emovable medias.  Here,
    # we "abuse" the feature, because  files under `gvfs/` are not necessarily
    # from a  removable media.   Although, the help  itself documents  how the
    # feature can be used for regular files:
    #
    #    > You can also use it for temp files, e.g., for Unix: "r/tmp".
endif

&viminfofile = $'{$HOME}/.local/share/vim/info'

# virtualedit {{{2

# In visual-block mode, let us move the cursor on a cell where there's no character:
#
#    - in the middle of a tab
#    - beyond the last char on a line
#
# Useful to select a rectangle out of irregular (different lengths) lines.
&virtualedit = 'block'

# wild* {{{2

# Why tweaking `'wildignore'`?{{{
#
# Some files can't be edited by Vim.
# Or they should not be edited.
#
# We never want to see them:
#
#    - in a dirvish listing
#    - on the command-line after a tab completion
#    - in the output of `expand()`, `glob()`, `globpath()`
#}}}

# Warning: Do *not* add `*/.git/*` to `'wildignore'`!{{{
#
# It breaks the `:drop` command which we use in `Tapi_drop()`:
#
#     $ vim +terminal
#     $ cd /tmp && git clone https://github.com/junegunn/fzf && cd fzf
#     $ sed -i '1d' LICENSE && git add . && git commit -v
#     Error detected while processing function Tapi_drop:
#     line   14:
#     E479: No match
#
# That's because `:drop` honors `'wildignore'`, which  makes it fail to open any
# file whose path is matched by the option.
#
# ---
#
# There  are  other  commands/functions  which  might  honor  the  option  (like
# `expand()` when  using a  backtick expression),  and which  might unexpectedly
# fail to give the right result when you include `*/.git/*`.
#}}}

# lock files (example: `~/.gksu.lock`)
&wildignore = '*.lock'
    # vim temporary files
    .. ',*.bak,*.sw[a-p],*~'
    # latex temporary files
    .. ',*.aux,*.fdb_latexmk,*.fls,*/auxiliary/*'
    # password databases
    .. ',*.kdb,*.kdbx'
    # media files (music, pictures, ...)
    .. ',*.gif,*.jpeg,*.jpg,*.mkv,*.mobi,*.mp3,*.mp4,*.ogg,*.png,*.webm'
    # python objects/cache
    .. ',*.pyc,*/__pycache__/*'
    # undo/backup files
    .. $',{&undodir}/*'
    .. $',{&backupdir->trim('/', 2)}/*'
    .. ',tags'
    # compiled binaries in our Wiki
    .. ',*/build/*'

# Why don't you ignore archives?{{{
#
#     set wildignore+=*[^0-9].gz,*.rar,*.tar.*,*.zip
#                      ^----^
#                      don't ignore man pages in `/usr/share/man/man1/`
#
# Some system files are stored in archives, logs for example.
# When we inspect  the contents of a  directory in dirvish, we want  to see them
# (whether we can open them or not).
# Besides, usually, they can be read in Vim.
# Example:
#
#     /usr/share/keymaps/i386/azerty/azerty.kmap.gz
#}}}

# Tab completion should be case-insensitive.
# If we type `:edit bar Tab`, and a file `Bar` exists, we should get:
#
#     :edit Bar
&wildignorecase = true

# enable wildmenu
&wildmenu = true

# display the completion matches using the popupmenu
&wildoptions = 'pum'

# The value of 'wildmode' is a comma-separated list of (up to 4) parts.
# Each  part   defines  what   happens  when  we   press  Tab   (&wildchar)  the
# 1st/2nd/3rd/4th time.
&wildmode = 'full'

# What's 'wildchar'?{{{
#
# The  key to  press for  Vim to  start a  wildcard expansion  (which opens  the
# wildmenu).
#}}}
#   'wildcharm'?{{{
#
# The key to press for Vim to start a wildcard expansion, from:
#
#    - the recording of a macro
#    - the RHS of a mapping
#}}}

# What does `&wildcharm = 9` imply?{{{
#
# When you want  Vim to start a wildcard  expansion, in the RHS of  a mapping or
# while recording a macro, you must use Tab.
#}}}
# Which pitfall should I be aware of?{{{
#
# Suppose your recording contains Tab characters.
# While on the command-line, *any* one  of them will start a wildcard expansion.
# It might have unexpected results.
# For a real example, run:
#
#     :source $VIMRUNTIME/syntax/hitest.vim
#
# (Taken from `:help hitest.vim`)
# It will give `E475`, and the dumped highlight groups won't be highlighted.
# This is because of these commands:
#
#     :% yank a
#     @a
#
# They run the  contents of the buffer  as Ex commands, and  the latter contains
# Tab characters.
# Each Tab character makes Vim start a  wildcard expansion, but in the buffer it
# was just used to separate some texts.  It was not supposed to expand anything.
#}}}
#   What could I do to avoid it?{{{
#
#     &wildcharm = char2nr("\<C-Z>")
#}}}
#     Why don't you do it?{{{
#
# Having to remember to press `C-z` during a recording is cumbersome.
# You'll definitely forget about it,  then get unexpected results when replaying
# some macro.
#
# ---
#
# If you change `'wildcharm'`, among other things, in `vim-readline` you'll need
# to update the `<M-N>` mapping.
#}}}
&wildchar = char2nr("\<Tab>")
&wildcharm = &wildchar

# winaltkeys {{{2

# Disable `alt + {char}` key bindings used in the GUI to access some menu entries.
# They could shadow some of our custom mappings using the meta modifier key.

&winaltkeys = 'no'

# word / line wrapping {{{2

# don't wrap long lines by default
&wrap = false

# a soft-wrapped line should be displayed with the same level of indentation as the first one
&breakindent = true
# make sure a soft-wrapped line contains at least 40 characters;
# shift it to the right if necessary
&breakindentopt = 'min:40'
# display the 'showbreak' character *before* the indentation;
# this helps keeping all the start of lines aligned
&breakindentopt ..= ',sbr'
# uses the length of a match with 'formatlistpat' for indentation
&breakindentopt ..= ',list:-1'

# soft-wrap long lines at a character in 'breakat' (punctuation, math
# operators, tab, @) rather than at the last character that fits on the screen
&linebreak = true

# Problem: Moving vertically in a huge wrapped line (with `gj`, `gk`) makes Vim lag.
# Solution: Disable `'breakindent'` and `'linebreak'` when one of the first lines is too long.
augroup FastLongWrappedLines
    autocmd!
    # We need `WinEnter` because the contents of a file can change.{{{
    #
    # Ideally, we should listen to `TextChanged*`, but that looks too frequent.
    # `WinEnter` should be a good enough replacement.
    #}}}
    # We also need `BufWinEnter`, because `WinEnter` is fired too early the first time.{{{
    #
    # For example:
    #
    #     $ vim
    #     :edit file_with_huge_wrapped_line
    #
    #     $ vim
    #     # run some code
    #     # press:  !d  (to dump debugging variables; one of them containing a huge list/dictionary)
    #}}}
    autocmd WinEnter,BufWinEnter * FastLongWrappedLines()
augroup END

def FastLongWrappedLines()
    # We only inspect the first 10  lines, otherwise the expression could be
    # too costly on a huge file.
    if getline(1, 10)
            ->map((_, v: string): number => strcharlen(v))
            ->max() > 1'000
        &l:breakindent = false
        &l:linebreak = false
    else
        &l:breakindent = true
        &l:linebreak = true
    endif
enddef

# allow to soft-wrap after ) ] }
set breakat+=)]}

var showbreak: string = '↪ '
&showbreak = showbreak
augroup ShowBreak
    autocmd!
    # workaround to avoid this issue: https://github.com/vim/vim/issues/11272
    autocmd ModeChanged *:[vV\x16]* &showbreak = '+ '
    autocmd ModeChanged [vV\x16]*:* &showbreak = showbreak
augroup END

# allow `h` and `l` motion to move across lines
&whichwrap = 'h,l'
#}}}1
# Mappings {{{1
# Pitfall: A buffer-local mapping can break one of your "prefix" key.{{{
#
# For example, you use `-` as a prefix for various mappings.  Now, suppose you
# install a third-party plugin which installs this mapping in some buffers:
#
#     nnoremap <buffer><nowait> - :echo 'do something'<CR>
#
# In those buffers, you will not be able to use any of your mappings whose LHS
# starts with `-`.
#
# Solution: In a filetype plugin under `after/`, unmap the culprit:
#
#     nunmap <buffer> -
#}}}

# Disabled {{{2

# Purpose:{{{
#
# Use this function to disable some keys.
# Also, use it to remove some undesirable mappings installed by other plugins.
#}}}
def NopMaps()
    # Various keys used as a prefix
    for pfx: string in ['+', '-', '<Space>', '<Bar>', 'U', 's', 'S', '<C-G>']
        # We might let the timeout elapse.
        # In this case, the key should have no effect.
        # This is probably the reason why `:help sandwich-keymappings`, recommends this:{{{
        #
        #    > NOTE: To prevent unintended operation, the following setting is strongly
        #    >       recommended to add to your vimrc.
        #
        #         nmap s <Nop>
        #         xmap s <Nop>
        #}}}
        execute $'nnoremap {pfx} <Nop>'
        execute $'xnoremap {pfx} <Nop>'

        # Let us cancel a prefix by pressing it twice.
        # Not sure this is really needed.{{{
        #
        # But I think that sometimes, I press a prefix twice thinking the second
        # keypress will cancel the first one.
        #
        # That's  not what  happens;  the  first keypress  has  no effect  (it's
        # remapped to `<Nop>` then executed), but  the second one remains in the
        # typeahead buffer.  So  the prefix can still be used  to form a mapping
        # with the next keypress, which *I think* is unexpected in practice.
        #}}}
        if maparg($'{pfx}{pfx}', 'n') == ''
            execute $'nnoremap {pfx}{pfx} <Nop>'
        endif
    endfor
    # You've disabled `s` and `S`.  What about `sS` and `Ss`?{{{
    #
    # Disabling those is useless.
    #
    # When  you press  `s` after  `S`, `S`  is automatically  canceled (look  at the
    # command-line; 'showcmd').  Only `S` remains.
    # If you wait for the timeout, our  `nnoremap S <Nop>` mapping will be used,
    # which will make sure nothing happens.
    #}}}

    # We sometimes press `&` by accident instead of `<`.
    # This executes a substitution command which is too unexpected.
    nnoremap & <Nop>
    nnoremap g& <Nop>

    # I think we press  `[[` and `]]` by accident too  often; when that happens,
    # we jump far away, and lose context; this is too distracting.
    nnoremap [[ <Nop>
    nnoremap ]] <Nop>

    # We  often press  `<C-Space>` by  accident which  inserts the  previously
    # inserted text and stop insert (`:help i^@`).  That's distracting.
    inoremap <C-@> <Nop>

    # When I want to move the cursor  backward with `<C-B>`, I suspect I press
    # `<C-N>` by  accident instead.   Very annoying  (slow popup  menu; breaks
    # workflow).
    inoremap <expr> <C-N> pumvisible() ? '<C-N>' : ''

    # We sometimes press `<C-F>` by accident.
    # When we do, we lose context of where we are which is too distracting.
    nnoremap <C-B> <Nop>
    nnoremap <C-F> <Nop>

    # Don't suspend if we press `<C-Z>` by accident.
    noremap <C-Z> <Nop>
    # But do restore the feature on a double keypress (in normal mode only).
    nnoremap <C-Z><C-Z> <ScriptCmd>suspend<CR>

    # I often press `do`  and `dp` by accident, when in fact  I only wanted to
    # press `o`  or `p`.  Anyway,  `do` and `dp` are  only useful in  a buffer
    # which is in diff mode.
    nnoremap <expr> do &l:diff ? 'do' : ''
    nnoremap <expr> dp &l:diff ? 'dp' : ''

    # I think we often press `Uu` by accident.
    # When that happens, Vim undo our edits, which I don't want.
    nnoremap Uu <Nop>

    # We often press a spell command (such as `zg`) by accident which is distracting.{{{
    #
    # The default commands to add good / bad words in:
    #
    #    - a temporary list  use an uppercase character
    #    - a persistent list use only lowercase characters
    #
    #    ┌────────────┬──────────────┬──────────────┐
    #    │            │ mark         │ undo         │
    #    ├────────────┼──────┬───────┼──────┬───────┤
    #    │            │ good │ wrong │ good │ wrong │
    #    ├────────────┼──────┼───────┼──────┼───────┤
    #    │ persistent │ zg   │ zw    │ zug  │ zuw   │
    #    ├────────────┼──────┼───────┼──────┼───────┤
    #    │ temporary  │ zG   │ zW    │ zuG  │ zuW   │
    #    └────────────┴──────┴───────┴──────┴───────┘
    #}}}
    for cmd: string in ['zg', 'zG', 'zw', 'zW', 'zug', 'zuG', 'zuw', 'zuW']
        execute $'nnoremap {cmd} <Nop>'
    endfor
enddef

# Need to delay until `VimEnter` to be  sure that all plugins have been sourced,
# so that we can undo whatever undesirable mapping they've installed.
autocmd VimEnter * NopMaps()

# New {{{2

def RememberNewMappings(some_lhs: list<list<string>>)
    for lhs: list<string> in some_lhs
        execute $'nnoremap {lhs[0]} <ScriptCmd>ReminderNewMapping({lhs[1]->string()})<CR>'
    endfor
enddef

def ReminderNewMapping(new_lhs: string)
    echohl WarningMsg
    echo $'Press {new_lhs}    [3 times to make it stick faster]'
    echohl NONE
enddef

#     RememberNewMappings([
#         ['old key', 'new key'],
#         ...,
#     ])

# Free {{{2

# A key can be used as a prefix if, and only if, one of these conditions is true:
#
#    - it's useless for you (e.g.: U)
#    - it's used as a prefix by default (e.g.: Z)
#
# This means that you can *not* use `!` as a good prefix.
# Not useless, and not a prefix by default, so it would lead to too many issues.
#
# Still, you  might occasionally  use a  key sequence  `!{char}`.  But  do *not*
# infer, that `!` can be used as a  prefix associated with a meaning, to build a
# whole family of mappings.
# There would be times  when it wouldn't work, and then you  would have to build
# mappings which  do not follow  the same scheme (shell  command → !).  It would
# bring inconsistencies.


# When you find a new prefix, if it has a default meaning, disable it:
#
#     nnoremap <pfx> <Nop>
#
# Do it from `NopMaps()`.


#    - C-q is not used in insert mode (except for exiting a completion menu)
#      we could supercharge  it to do something  else when we aren't  in a completion
#      menu
#
#    - C-z has been disabled in visual mode
#
#      in insert mode, we use it as an “easier-to-type“ C-x C-p
#
#    - gh, gH, g C-h, gl, v_C-g
#
#    - @# has been mapped to g8, so g8 is free
#
#    - gy, gz
#
#    - PageUp PageDown
#
#    - S-Tab (not Tab, because it would also affect C-i used for moving
#      inside the jumplist)
#
#    - C-_
#
#    - search for 'not used' in the window opened by `:viusage`

# Leader {{{2

# If we install a  plugin which defines mappings using the  leader key, we don't
# want any clash with one of our existing mapping.  So, we assign to `mapleader`
# a garbage key.

# As an  example, this strategy is  useful to avoid the  `unicode.vim` plugin to
# cause  a timeout  when we  press `<Space>u`.   Indeed this  plugin installs  a
# mapping whose LHS is `<leader>un` (`:help <Plug>(UnicodeSwapCompleteName)`).

# Other benefit:
#
#     :map <leader>
#     →
#     displays all mappings installed by third-party plugins
#     in normal / visual / operator-pending mode

# Warning: Do *not* use `\<S-F5>`.{{{
#
# It would cause a weird issue:
#
#     $ vim --clean --cmd 'let mapleader = "\<S-F5>"' adb.adb
#     E329: No menu "PopUp"
#     E488: Trailing characters: :call ada#List_Tag ()<CR>: al :call ada#List_Tag ()<CR>
#
# I  think it  comes from  the  fact that  the internal  byte representation  of
# `<S-F5>` ends with a newline:
#
#     :echo "\<S-F5>" =~ '\n'
#     1
#}}}
g:mapleader = "\<S-F10>"

# same thing for localleader
g:maplocalleader = "\<S-F11>"

# Command-Line {{{2
# C-r C-l       insert current line {{{3

cnoremap <C-R><C-L> <C-R><C-R>=<SID>InsertCurrentLine()<CR>
def InsertCurrentLine(): string
    var cml: string = &l:commentstring->matchstr('\S*\ze\s*%s')
    cml = $'\%(\V{escape(cml, '\')}\m\)\='
    return getline('.')->substitute($'^\s*{cml}\s*:\=', '', '')
enddef

# C-r `          insert codespan {{{3

cnoremap <C-R>` <C-R><C-R>=<SID>InsertCodespan()<CR>
def InsertCodespan(): string
    var pat: string = '\%(\%<.c\|\%.c\)`\zs[^`]\+\ze`\%>.c'
    return getline('.')
        ->matchstr(pat)
        ->substitute('^:', '', '')
enddef
# }}}2
# Insert {{{2

# Most of these mappings take care of not breaking the undo sequence (`:help i^gU`).
# It means we can repeat an edition with the dot command, even if we use them.
# If you add another mapping, try to not break the undo sequence.  Thanks.

# C-g             (prefix) {{{3
# C-h {{{4

# Sometimes, we want to do this:{{{
#
# ┌ exceeding amount of whitespace
# ├──────┐
#         some text
#     ↓
# some text
#│
#└ compacted whitespace
#}}}
# Also, sometimes we want to do this:{{{
#
# ┌ exceeding amount of whitespace
# ├─────┐
#        # some text
#     ↓
# # some text
# │
# └ compacted whitespace
#}}}

# This  mapping  tries  to  perform  both edits,  depending  on  the  amount  of
# whitespace between the comment leader and the rest of the text.
inoremap <C-G><C-H> <ScriptCmd>CompactWhitespace()<CR>

def CompactWhitespace()
    if empty(&l:commentstring)
        return
    endif

    var cml: string = '\V'
        .. &l:commentstring
        ->matchstr('\S*\ze\s*%s')
        ->escape('\')
        .. '\m'

    var pat: string
    var rep: string
    if getline('.') =~ $'{cml}\s\s' && &filetype != 'markdown'
        pat = $'\s*{cml}\zs\s\+'
        rep = ' '
    else
        pat = '^\s*\ze\S'
        rep = ''
    endif

    getline('.')->substitute(pat, rep, '')->setline('.')
enddef
# }}}3
# C-m             more granular undo {{{3

# Make `C-m` break the undo sequence.{{{
#
# When  we write  a paragraph  then press  `u` to  undo, Vim  removes the  whole
# paragraph.  We  want it to  remove only the last  line.  Then the  one before,
# etc.
# To get a more granular undo, we need to press `C-g u` every time we press `C-m`.
# This will break the undo sequence into smaller undo sequences.
# Every time  we press `C-g  u`, the current state  of the buffer  is accessible
# with `u`/`C-r`.
#
# See: `:help i_CTRL-G_U`
#}}}

def CtrlM(): string
    var seq: string
    if pumvisible()
        # If you change the code, make sure not to introduce a regression.{{{
        #
        # The code should be able to do this:
        #
        # Write `bug_` in a markdown buffer.
        # Press `Tab` to complete.
        # Select `bug_vim` in the pum.
        # Press `Enter`: the snippet should be expanded immediately.
        #
        # Expand the `vimrc` snippet.
        # Press `C-h` when you are at a tabstop containing a file path.
        # Insert a space.
        # Insert `/h`.
        # Press `C-g Tab` to complete the path.
        # Press `Enter`:  `/h` should be  completed with `/home`,  *and* another
        # completion should have been performed.
        #
        # In a file with only 2 lines `unexpected`, and `une`, pressing
        # `C-x C-n Enter` should complete `une` into `unexpected`.
        #}}}
        seq = "\<C-Y>"

        # If no entry is selected in the pum, select one.{{{
        #
        # Otherwise,  the text  which was  inserted  in the  last completion  is
        # removed, which is very jarring.
        #}}}
        var nothing_selected: bool = complete_info(['selected'])
            ->get('selected', -1) == -1
        if nothing_selected
            seq = "\<C-N>" .. seq
        endif

        var items: list<dict<string>> = complete_info(['items'])
            ->get('items', [])
        var menu: string = get(items, 0, {})->get('menu', '')
        # for a file path, re-trigger completion for a next possible path component
        if menu == '[f]'
            seq ..= "\<ScriptCmd>filepath.Complete()\<CR>"
        # for an unexpanded snippet, trigger the expansion
        elseif menu[: 5] == '[snip]'
            seq ..= "\<ScriptCmd>UltiSnips#ExpandSnippet()\<CR>"
        endif

        return seq
    endif

    # If we press Enter on a commented line with nothing in it, we want to delete everything.
    var cml: string = &l:commentstring->matchstr('\S*\ze\s*%s')

    if empty(cml)
        return "\<C-G>u\<CR>" .. seq
    endif

    if getline('.') =~ $'^\s*\V{escape(cml, '\')}\m\s*$'
        # We can't invoke `setline()` immediately, because of `<expr>`.
        timer_start(0, (_) => setline('.', ''))
        # Why don't you simply press `BS`?{{{
        #
        #     return "0\<C-D>" .. repeat("\<BS>", strcharlen(cml) + 1)
        #
        # Not reliable, because sometimes BS deletes more than one char.
        # Happens after a sequence of whitespace.
        #}}}
        return ''
    endif

    return "\<C-G>u\<CR>" .. seq
enddef

inoremap <expr> <C-M> CtrlM()

# C-p             toggle punctuation {{{3

inoremap <C-P> <ScriptCmd>myfuncs.TogglePunctuation()<CR>

# C-r             ignore `'autoindent'` when inserting register {{{3

# Why handling a block specially?{{{
#
# The default `i^r` inserts a blockwise register as if it was linewise.
# We don't want an inconsistency; our custom `i^r` should behave the same.
#}}}
inoremap <expr> <C-R> getregtype(v:register) =~ '<C-V>' ? '<C-R>' : '<C-R><C-O>'
# The previous `<C-R>` mapping breaks the default `:help i^r^p`; let us still use it.{{{
#
# You might wonder how `:help i^r^p` gets broken.
# Suppose you have 2 mappings starting with `C-r`:
#
#     i  <C-R>       * <C-R><C-O>
#     i  <C-R><C-F>  * ...
#
# If you press `C-r` in insert mode,  Vim must wait for another keypress to know
# whether `C-r` needs to be remapped, and if so using which mapping.
#
# Next, suppose you press `C-p` right after `C-r`.  Vim now knows that you don't
# want to  use the 2nd mapping;  but the first mapping  is still OK, and  so Vim
# expands `C-r` into `C-r C-o`.
#
# In the end, the typeahead buffer contains:
#
#     C-r C-o C-p
#
# `C-r  C-o` is  valid, but  there  is no  register  named `C-p`,  so the  whole
# sequence fails.  In  any case, that's not  what you wanted; you  wanted Vim to
# execute `C-r C-p`.
#}}}
inoremap <C-R><C-P> <C-R><C-P>
# the same issue affects `:help i^r^o` and `:help i^r^r`
inoremap <C-R><C-O> <C-R><C-O>
inoremap <C-R><C-R> <C-R><C-R>

# C-s             save {{{3

# In a prompt buffer, we're in insert mode.
# And we can't save a prompt buffer; so don't try.
inoremap <C-S> <ScriptCmd>if &buftype == '' <Bar> silent update <Bar> endif<CR>

# Let's do the same in visual mode for good measure.  I think we sometimes press
# it while being accidentally in visual  mode.  It then fails, which is jarring.
# Make it work.
xnoremap <C-S> <C-\><C-N><ScriptCmd>if &buftype == '' <Bar> silent update <Bar> endif<CR>

# C-x [jk]        duplicate characters above/below {{{3

# Why these mappings? {{{
#
# They are more consistent and more powerful than the default ones.
#}}}
# What's the issue with the default ones ?{{{
#
# By default, Vim uses `C-e` and `C-y` in inconsistent ways:
#
#    i^e:            duplicate char below, or exit completion menu
#                    ✘ 2 unrelated functionalities
#                    ✘ shadows `end-of-line` in `vim-readline`
#
#    i^y:            duplicate char above
#                    ✘ hard to remember;
#                      it would be easier if Vim used `k` prefixed with some key
#
#    i^x^e  i^x^y:   scroll window
#                    ✘ ^x is usually used to complete text
#
#                    ✘ usually Vim uses `j` and `k` in mappings which must interact
#                      with a line below/above (example: gj, gk)
#
#                    ✘ i^x^e doesn't conflict with our custom c^x^e, but still
#                      it's a little confusing
#}}}

# Don't remove `<silent>`.{{{
#
# Sometimes, the RHS might be briefly displayed.
# Right now, it happens  when we smash the keys in  `myfuncs.vim` while the file
# is displayed in two tab pages, and we're focusing the second one.
#}}}
inoremap <silent> <Plug>(duplicate-char-below) <C-R>=<SID>DuplicateCharAround(v:false)<CR>
inoremap <silent> <Plug>(duplicate-char-above) <C-R>=<SID>DuplicateCharAround(v:true)<CR>

def DuplicateCharAround(above: bool): string
    # This function reimplements `C-y` (and `C-e`) in a more powerful way.{{{
    #
    # By default, `C-y` only duplicate the character right above.
    # If there's nothing, but there IS a character on the 2nd line above,
    # `C-y` ignores it.
    #}}}
    # Alternative: `virtcol([line('.'), col('.') - 1]) + 1`
    var vcol: number = virtcol('.', true)[0]
    var curlnum: number = line('.')

    # Don't do anything fancy, unless it's really necessary.{{{
    #
    # If  the adjacent  line  has a  character  on the  same  column where  we
    # currently  are,  then  we  can  leverage the  builtin  `C-e`  and  `C-y`
    # commands.
    #}}}
    # Need  to use  `vcol`  and not  `col`;  useful, for  example,  if the  line
    # contains multicell characters, like tabs.
    var pat: string = $'\S\%>{vcol - 1}v'
    if above && getline(curlnum - 1) =~ pat
        return "\<C-Y>"
    endif
    if !above && getline(curlnum + 1) =~ pat
        return "\<C-E>"
    endif
    pat ..= $'\%{above ? '<' : '>'}.l'

    var lnum: number = search(pat, $'{above ? 'b' : ''}nW')
    var char: string = getline(lnum)->matchstr($'\%{vcol}v.')
    return char
enddef

# M-a  M-e {{{3

execute mapping.Meta('inoremap <M-A> <ScriptCmd>normal! (<CR>')
execute mapping.Meta('inoremap <M-E> <ScriptCmd>normal! )<CR>')

# \ {{{3

inoremap <silent> <bslash> <C-R>=<SID>IndentBeforeBackslash()<CR>

def IndentBeforeBackslash(): string
    if &filetype != 'vim'
        return '\'
    endif

    var has_text_before_cursor: bool = getline('.')
        ->strpart(0, col('.') - 1) =~ '\S'
    var prev_indent: string = (line('.') - 1)->getline()->matchstr('^\s*\\')
    var next_indent: string = (line('.') + 1)->getline()->matchstr('^\s*\\')

    if has_text_before_cursor
            || empty(prev_indent) && empty(next_indent)
        return '\'
    endif

    var current_indent: string = empty(next_indent)
        ?     prev_indent
        :     next_indent

    #       ┌ if the cursor is in the middle of the indentation,
    #       │ `0 C-d` removes all whitespace before the cursor AND after
    #       ├─────┐
    return "0\<C-D>" .. current_indent .. ' '
    #                   │                  │
    #                   │                  └ to avoid that `\?` or `\:`
    #                   │                    which can cause a bug when Vim parses
    #                   │                    the ternary operator `?:` in a lambda
    #                   │
    #                   └ includes a backslash at the end
enddef

# }}}2
# Normal {{{2
# SPC {{{3
# . {{{4

# Problem:{{{
#
# Suppose you've just changed the word `foo` into `bar`.
# There's no easy way to repeat this change on all subsequent `foo`s.
# You need to first look for `foo`: `/foo CR`.
# Then, you need to:
#
#    - move to each `foo` by pressing `n`
#    - press `.` to repeat the change
#
# If you have `n` words to change, that's `4  + 2 * n` keypresses (4 to look for
# `foo`, then 2 more for each change).
#}}}
# Solution:{{{
#
# Include the `n` motion inside the change (somewhat similar to `^ifoo` vs `Ifoo`).
# You can  do so by  installing a mapping  leveraging the `gn`  text-object; the
# mapping should:
#
#    1. put the last changed text in the search register (`@"` → `@/`)
#    2. cut the next occurrence of the latter
#    3. insert the previously inserted text and stop insert (`C-@`)
#
# After `SPC .` has been pressed, you can repeat a change with `.`.
# `SPC` is not needed anymore.
#
# IOW, after you've  changed the first `foo`,  you can change the  next `n` ones
# with `2 + (n - 1)` keypresses.
#
# This is much more efficient:
#
#     2 + n - 1  <  4 + 2 * n
#}}}
nnoremap <expr> <Space>. RepeatLastEditOnLastChangedText()

def RepeatLastEditOnLastChangedText(): string
    # put the last changed text inside the search register, so that we can refer
    # to it with the text-object `gn`
    var changed: list<string> = getreg('"', true, true)
    if changed == []
        return ''
    endif

    changed->map((_, v: string) => escape(v, '\'))
    var pat: string
    if len(changed) == 1
        pat = changed[0]
    else
        # can't join with real newlines: they would be translated as NULs in the search register
        # we need to join with the *atom* `\n`
        pat = changed->join('\n')
    endif
    setreg('/', $'\V{pat}', 'c')
    &hlsearch = true
    return "cgn\<C-@>"
    #          ├────┘
    #          └ insert the previously inserted text and stop insert
enddef

# a                             arglist {{{4

# set arglist to visually selected paths
xnoremap <Space>a <C-\><C-N><ScriptCmd>execute 'arglocal '
    \ .. getline("'<", "'>")
    \ ->filter((_, fname: string): bool => fname->filereadable())
    \ ->map((_, fname) => fname->fnameescape())->join()
    \ <bar> args<CR>

# Define *n*ew arglist,  which is local to the current  window, and containing
# only the current buffer.  This causes the buffer to be reloaded.
nnoremap <Space>an <ScriptCmd>arglocal % <bar> execute 'normal! zvzz' <bar> args<CR>

# create *l*ocal arglist (by copying the global one)
nnoremap <Space>al <ScriptCmd>arglocal <bar> args<CR>

# add current buffer to argument list
nnoremap <Space>aa <ScriptCmd>argedit % <bar> argdedupe <bar> args<CR>

# delete current argument (which is not necessarily the current buffer)
nnoremap <Space>ad <ScriptCmd>:. argdelete <bar> args<CR>

# load *c*urrent argument
nnoremap <Space>ac <ScriptCmd>argument <bar> args<CR>

# t                             new tab page {{{4

nnoremap <Space>t <ScriptCmd>execute $':{v:count != 0 ? $'{v:count}tabnew' : 'tabnew'}'<CR>
#}}}3
# U {{{3
# Uc                clear undo history {{{4

nnoremap Uc <ScriptCmd>ClearUndoHistory()<CR>

def ClearUndoHistory()
    var fname: string = expand('%:p')
    if fname->empty()
        return
    endif

    # `:help clear-undo`
    var undolevels_save: number = &l:undolevels
    &l:undolevels = -1
    getline(1)->setline(1)
    &undolevels = undolevels_save
    execute $'wundo {fname->undofile()->fnameescape()}'
    silent update
    echomsg 'cleared undo history'
enddef

# US                undo changes during current session {{{4

augroup ChangenrSave
    autocmd!
    autocmd BufReadPost * ChangenrSave()
augroup END

def ChangenrSave()
    var bufnr: number = bufnr('%')
    if changenr_save->has_key(bufnr)
        return
    endif
    # Is `changenr()` reliable?{{{
    #
    # It was not in the past:
    # https://www.reddit.com/r/vim/comments/dszuz/gundo_my_little_undo_tree_visualization_plugin/c12ril4/
    #
    # `undotree().seq_cur` was not either.
    # But that has changed since 8.0.1290; now, they should both be reliable.
    #}}}
    changenr_save[bufnr] = changenr()
enddef
var changenr_save: dict<number>

# Ideas for other mappings navigating in the undo tree:{{{
#
#     # go to previous save
#     nnoremap UH <ScriptCmd>earlier 1f <Bar> g:SaveToggleAuto()<CR>
#     # go to next save
#     nnoremap UL <ScriptCmd>later 1f <Bar> g:SaveToggleAuto()<CR>
#     nnoremap UM <ScriptCmd>execute $'undo {undotree().seq_last} <Bar> g:SaveToggleAuto()<CR>'
#}}}

# Don't use `UU`; I think we used it in the past, but pressed it by accident too often.
nnoremap US <ScriptCmd>UndoChangesDuringCurrentSession()<CR>
def UndoChangesDuringCurrentSession()
    var bufnr: number = bufnr('%')
    if !changenr_save->has_key(bufnr) || changenr_save[bufnr] == changenr()
        return
    endif
    try
        execute $'undo {changenr_save[bufnr]}'
    # E830: Undo number 1234 not found
    catch /^Vim\%((\a\+)\)\=:E830:/
        var msg: list<string> =<< trim END
            Cannot access original state of the file
            you probably performed too many changes during the same session
            if this is an issue, try to increase 'undolevels'
        END
        echohl ErrorMsg
        for line: string in msg
            echomsg line
        endfor
        redraw
        echo msg[0]
        echohl NONE
    endtry
enddef
#}}}3
# g {{{3
# g SPC       break line {{{4

nnoremap <expr> g<Space> BreakLine()

def BreakLine(type = ''): string
    if type == ''
        &operatorfunc = BreakLine
        return 'g@l'
    endif

    # We sometimes press `g SPC` by accident after getting back to the beginning
    # of a markdown file.  It creates a superfluous empty line.
    if col('.') == 1
        return ''
    endif

    # break the line
    # Don't add a bang.{{{
    #
    # We want our custom  `<CR>` to be used, because it's able  to prevent a bug
    # where a text property gets sometimes off.
    #}}}
    execute "normal i\<CR>"

    # trim ending whitespace on both lines
    keepjumps keeppatterns :.-1,. substitute/\s\+$//e
    return ''
enddef

# g, g;       previous/next position in changelist {{{4

nmap g; <Plug>(next-change)
nmap g, <Plug>(prev-change)
nnoremap <Plug>(next-change) <ScriptCmd>TraverseChangelist(true)<CR>
nnoremap <Plug>(prev-change) <ScriptCmd>TraverseChangelist()<CR>

def TraverseChangelist(is_fwd = false)
    try
        if is_fwd
            execute $'normal! {get(g:, 'submode_count', v:count1)}g,zv'
        else
            execute $'normal! {get(g:, 'submode_count', v:count1)}g;zv'
        endif
    catch /^Vim\%((\a\+)\)\=:\%(E66[234]\|E19\):/
        echohl ErrorMsg
        echo v:exception->substitute('.\{-}:\zeE\d\+:', '', '')
        echohl NONE
    endtry
enddef

# g8          print hex *and octal* values of character under cursor {{{4
#
# By default, `g8` only prints values in hexadecimal.
# We want them in octal form too.
#
# Rationale: Some programs prints bytes in octal form:
#
#     $ bash -c "printf '%q\n' \$'\u0085'"
#     $'\302\205'

nnoremap g8 <ScriptCmd>G8()<CR>

def G8()
    var hex: list<string> = execute('normal! g8')
        ->split()
    var octal: list<string> = hex
        ->copy()
        # `byte == '+'`: for a composing character like `Ë͙͙̬̹͈͔̜́̽`
        ->map((_, byte: string) => byte == '+' ? '+' : printf('%o', byte->str2nr(16)))
    echo printf('hex: %s | oct: %s', hex->join(), octal->join())
enddef

# gV  g C-v   select last changed text {{{4

nnoremap g<C-V> `[v`]
nnoremap gV     '[V']

# g^ g$       first/last tabpage {{{4

nnoremap g^ <ScriptCmd>:1 tabnext<CR>
nnoremap g$ <ScriptCmd>:$ tabnext<CR>

# gj  gk      vertical jump {{{4

# Alternative: https://github.com/haya14busa/vim-edgemotion
# TODO: We never use these mappings.  I don't find the motions intuitive.{{{
#
# The problem is that we've implemented them without a clear goal in mind.
# When you feel the need to jump vertically, try to refactor the code so that it
# better suits our needs.
#
# These mappings  *could* be useful  when we start  coding in python  which uses
# indentation to specify when a construct ends.
#}}}
map gj <Plug>(vertical-jump-fwd)
map gk <Plug>(vertical-jump-bwd)
noremap <expr> <Plug>(vertical-jump-fwd) VerticalJumpRhs()
noremap <expr> <Plug>(vertical-jump-bwd) VerticalJumpRhs(false)

def VerticalJumpRhs(is_fwd = true): string
    var mode: string = mode(true)

    if mode == "\<C-V>"
        mode = "\<C-V>\<C-V>"
    endif

    return printf("\<ScriptCmd>%s(%d, %s)\<CR>",
        VerticalJumpGo, is_fwd ? 1 : 0, string(mode))
enddef

def VerticalJumpGo(is_fwd: bool, mode: string)
    if mode == 'n'
        normal! m'
    endif

    var n: number = GetJumpHeight(is_fwd)
    if n <= 0
        return
    endif

    # temporarily disable folds before we move
    var foldenable_save: bool
    var winid: number
    var bufnr: number
    [foldenable_save, winid, bufnr] = [&l:foldenable, win_getid(), bufnr('%')]
    &l:foldenable = false
    try
        execute $'normal! {is_fwd ? $'{n}j' : $'{n}k'}'
    finally
        # restore folds
        if winbufnr(winid) == bufnr
            var tabnr: number
            var winnr: number
            [tabnr, winnr] = win_id2tabwin(winid)
            settabwinvar(tabnr, winnr, '&foldenable', foldenable_save)
        endif
    endtry

    # open just enough folds to see where we are
    if mode =~ "[nvV\<C-V>]"
        normal! zv
    endif
enddef

def GetJumpHeight(is_fwd: bool): number
    var curlnum: number = line('.')
    var vcol: number = virtcol('.', true)[0]
    var flags: string = is_fwd ? 'nW' : 'bnW'

    # a line where there IS a character in the same column,
    # then one where there is NOT
    var lnum1: number = search(
        # let's make sure we find a *different* line (and not the one where we already are)
        $'\%{is_fwd ? '>' : '<'}.l'
        # now, we just need to find a line longer than `vcol` cells
        .. $'\%>{vcol}v\%(\n\|\%$\)'
        # followed by a line shorter than `vcol` cells
        .. $'.*\%<{vcol + 1}v\%(\n\|\%$\)',
        flags
    )

    # a line where there is NOT a character in the same column,
    # then one where there IS
    var lnum2: number = search(
        $'\%<{vcol + 1}v\n'
        .. $'\zs\%{is_fwd ? '>' : '<'}.l'
        .. $'.*\%>{vcol}v\%(\n\|\%$\)',
        flags
    )

    var lnums: list<number> = [lnum1, lnum2]
        ->filter((_, v: number): bool => v > 0)

    if empty(lnums)
        return 0
    endif

    return is_fwd
        ?     min(lnums) - curlnum
        :     curlnum - max(lnums)
enddef

# go {{{4

nnoremap go <ScriptCmd>Go()<CR>

def Go()
    # `:help :go`
    if v:count != 0
        execute $':{v:count}go'
        return
    endif

    var char: string = getcharstr()
    if char == 'f'
        expand('%:p:h', true)
            ->myfuncs.OpenGuiFileManager()
    elseif char == 'F'
        getcwd()
            ->myfuncs.OpenGuiFileManager()
    elseif char == 't'
        expand('%:p:h', true)
            ->myfuncs.OpenTerm()
    elseif char == 'T'
        getcwd()
            ->myfuncs.OpenTerm()
    endif
enddef

# gt  gT      move tab page {{{4

nmap gt <Plug>(move-tabpage-fwd)
nmap gT <Plug>(move-tabpage-bwd)
nnoremap <Plug>(move-tabpage-fwd) <ScriptCmd>MoveTabpage()<CR>
nnoremap <Plug>(move-tabpage-bwd) <ScriptCmd>MoveTabpage(false)<CR>

def MoveTabpage(is_fwd = true)
    try
        if is_fwd && tabpagenr() == tabpagenr('$')
            tabmove 0
        elseif !is_fwd && tabpagenr() == 1
            tabmove $
        elseif is_fwd
            tabmove +1
        else
            tabmove -1
        endif
    catch
        lg.Catch()
        return
    endtry
enddef
#}}}3
# m {{{3
# m;             mark current location {{{4

# These mappings can be used to traverse an arbitrary set of locations in the current buffer, using:{{{
#
#    - `m;` to save the current position into a list
#    - `m,` to empty the latter
#    - `[;` and `];` to jump from one location to the other
#}}}
# Why using text properties?  Why not a loclist?{{{
#
# A loclist would only save positions,  which could become invalid when the text
# changes (e.g. a line before has been removed).
# Text properties “follow” the text to which they're tied.
#
# ---
#
# Also, our breakdown plugin can frequently add a new loclist on the stack; when
# that happens we would need to run `:lolder` or `:[count]lhi`.
#}}}

# set mark on current position
nnoremap m; <ScriptCmd>MyLocations('save')<CR>
# clear locations
nnoremap m, <ScriptCmd>MyLocations('clear')<CR>

def MyLocations(action: string)
    var buf: number = bufnr('%')
    if action == 'save'
        if prop_type_get('MyLocations', {bufnr: buf}) == {}
            prop_type_add('MyLocations', {
                bufnr: buf,
                highlight: 'WildMenu',
                combine: false
            })
        endif
        prop_add(line('.'), col('.'), {
            bufnr: buf,
            type: 'MyLocations',
            combine: false,
        })
    else
        if prop_type_get('MyLocations', {bufnr: buf}) != {}
            prop_type_delete('MyLocations', {bufnr: buf})
            redraw!
        endif
        prop_type_add('MyLocations', {
            bufnr: buf,
            highlight: 'WildMenu',
            combine: false
        })
    endif
enddef

map ]; <Plug>(next-location)
map [; <Plug>(prev-location)
noremap <Plug>(next-location) <ScriptCmd>JumpMyLocations('f')<CR>
noremap <Plug>(prev-location) <ScriptCmd>JumpMyLocations('b')<CR>

def JumpMyLocations(direction: string)
    if prop_type_get('MyLocations', {bufnr: bufnr('%')}) == {}
        return
    endif
    var prop: dict<any> = prop_find({
        type: 'MyLocations',
        skipstart: true
    }, direction)
    if prop == {}
        return
    endif
    cursor(prop.lnum, prop.col)
enddef

#}}}3
# y {{{3
# Y y$ {{{4

nnoremap Y y$<ScriptCmd>Repeat.Invalidate()<CR>

# In visual mode, make `Y` yank until the end of the line, just like it does in normal mode.{{{
#
# We can't separate a  register name from the `y` command,  with a motion.  They
# must  be consecutive.   Otherwise  the  yanking fails  to  target the  desired
# register.  MRE:
#
#     C-v 3j "+ $ y    ✘
#     C-v 3j $ "+ y    ✔
#
# As  soon as  we type  the `$`  motion, the  register name  is lost  (watch the
# command-line).   So,  we  use  an  expression, to  make  sure  that  they  are
# consecutive.
#
# There is  no need to prefix  the keys with  `Escape` when a register  has been
# specified, and you need to reposition it in the command.
# As  soon  as   `$`  is  pressed,  the  old  register   is  cancelled  (because
# `"{register}$` is not a valid command).
#}}}
xnoremap <expr> Y '$"' .. v:register .. 'y' .. Repeat.Invalidate()

# y[cC]  y[mM]        yank code / Comments  matching / non-matching lines {{{4

nnoremap <expr>  yc myfuncs.OpYank('code')
xnoremap <expr> myc myfuncs.OpYank('code')

nnoremap <expr>  yC myfuncs.OpYank('comments')
xnoremap <expr> myC myfuncs.OpYank('comments')

# lines matching last search
nnoremap <expr>  ym myfuncs.OpYank('global//')
xnoremap <expr> mym myfuncs.OpYank('global//')

# lines which do *not* match last search
nnoremap <expr>  yM myfuncs.OpYank('vglobal//')
xnoremap <expr> myM myfuncs.OpYank('vglobal//')
#}}}3
# z {{{3
# z. {{{4

# Scroll the screen so that cursor is at the center of a long non-wrapped line.
# https://unix.stackexchange.com/a/585098/289772
nnoremap z. zszH
#           ├┘├┘
#           │ └ scroll half-a-screen to the left
#           └ scroll the screen so that the cursor is at the start

# z= {{{4

# Will a repetition of this command open a new menu?{{{
#
# No, it will simply repeat the previous edit.
# Consider this text:
#
#     Hellzo peozple.
#
# Move your cursor on `Hellzo`, and press `z=` to fix it.
# Move your cursor on `peozple`, and press `.` to repeat.
# Vim will simply replace the word with `Hello`, it won't try to fix `peozple`.
#
# This is normal, do *not* try to change the code so that it opens a new menu.
# From `:help z=`:
#
#    > When a word was replaced the redo command "." will
#    > repeat the word replacement.  This works like "ciw",
#    > the good word and <Esc>.
#}}}
nnoremap <expr> z= ZEqual()

def ZEqual(type = ''): string
    if type == ''
        &operatorfunc = ZEqual
        return 'g@l'
    endif
    try
        # Why not `normal! z=`?{{{
        #
        # We  would not  be  able to  select  an entry  in  the menu,  because
        # `:normal` would  press `Escape`.   Indeed, it  considers `z=`  as in
        # *in*complete command, since we don't give it the number of the entry
        # we want to select in advance.  From `:help normal`:
        #
        #    > {commands} should be a complete command.  If
        #    > {commands} does not finish a command, the last one
        #    > will be aborted as if <Esc> or <C-C> was typed.
        #}}}
        feedkeys($'{v:count != 0 ? v:count : ''}z=', 'in')
        return ''
    catch
        lg.Catch()
        return ''
    endtry
enddef

# zd  zD  zE {{{4

# make `zd` repeatable; also, make it handle Vim9's comment leader (`#`) correctly
nnoremap <expr> zd Zd('zd')
nnoremap <expr> zD Zd('zD')
nnoremap <expr> zE Zd('zE')

def Zd(cmd: string, type = ''): string
    if type == ''
        &operatorfunc = function(Zd, [cmd])
        return 'g@l'
    endif

    try
        execute $'normal! {cmd}'
    # `zd` only works when 'foldmethod' is `manual` or `marker`
    catch /^Vim\%((\a\+)\)\=:\%(E351\|E490\):/
        lg.Catch()
    endtry
    return ''
enddef

#}}}3
# | {{{3
# restore `:help bar` on `g|`
nnoremap g<Bar> <Bar>
# |c         execute the Compiler {{{4

# Don't be fooled by the name "Compiler".{{{
#
# This mapping runs whatever command is written in `&l:makeprg`.
# It could be anything; for example a linter.
# But we  say "Compiler",  because `'makeprg'` (as  well as  `'errorformat'`) is
# meant to be set via a compiler plugin.
#}}}
# Do *not* install a `<Bar>c` mapping in a filetype plugin to set the compiler and then compile.{{{
#
# Unless you have to, because it requires some special handling.
#
# Instead, simply set the compiler in the filetype plugin with `:compiler foo`.
# This global `<Bar>c` mapping will then use the right compiler.
#}}}
nnoremap <Bar>c <ScriptCmd>myfuncs.RunCompiler()<CR>

# |s         execute current line with Shell {{{4

# Test against this line:
#
#     $ printf '%02x\n' $(seq 100) | fmt --width=49
#
# This is similar to `!!sh`, but with a few added bonuses:
#
#    - only run on a line containing a shell command
#    - output indented like the original command-line
#    - no need to escape some characters (like `%`)
nnoremap <bar>s <ScriptCmd>ShellExecute()<CR>
def ShellExecute()
    var curline: string = getline('.')

    var cml: string
    if &filetype != 'markdown'
        cml = &l:commentstring
            ->matchstr('\S*\ze\s*%s')
        cml = $'\V{escape(cml, '\')}\m'
    endif

    var shell_prompt: string = '$ '
    if curline !~ $'^\s*{cml}\s*{shell_prompt}'
        echo 'no commented shell command on this line'
        return
    endif

    # to make sure the output is indented like the original command-line
    var indent: string = curline
        ->matchstr($'^\s*{cml}\s*')

    curline
        ->substitute($'^{indent}{shell_prompt}\s*', '', '')
        ->systemlist()
        ->map((_, line: string) => indent .. line)
        ->append('.')
enddef
# }}}3
# = {{{3
# = C-p               fix indentation of pasted text {{{4

# Why not `=p`?{{{
#
# Already used in `vim-brackets` to paste and fix right afterward.
# Same for `=P`.
#}}}
nnoremap =<C-P> m''[=']``

# =d                  fix display {{{4

# In normal mode, we remapped `C-l` to give the focus to the right window.
# But by default, `C-l` redraws the screen by executing `:redraw!`.
#
# So, we need to bind `:redraw!` to another key, `=d` could be a good
# candidate.

nnoremap =d <ScriptCmd>FixDisplay()<CR>

def FixDisplay()
    var view: dict<number> = winsaveview()
    redraw! | redrawstatus! | redrawtabline
    silent! popup.CloseAll()

    if &l:diff
        # update differences between windows in diff mode
        diffupdate!
        #         ^
        #         check if the file was changed externally and needs to be reloaded
        winrestview(view)
        return
    endif

    if &filetype == '' || &filetype == 'text'
        return
    endif

    # reload filetype plugins (to reapply window-local options)
    # Why don't you run `doautocmd filetypeplugin filetype`?{{{
    #
    # It would only reload the default filetype plugins.
    #
    # It would not run our custom autocmds listening to `FileType`.
    # In particular, it would not run the autocmd in the `StyledComments` augroup.
    # For that, you would need to run:
    #
    #     doautocmd StyledComments filetype
    #
    # Nor would it run the autocmd in `MyDefaultLocalFormatoptions`.
    # For that, you would need to run:
    #
    #     doautocmd MyDefaultLocalFormatoptions filetype
    #
    # IOW, you would need to run  an extra `:doautocmd` command for every custom
    # augroup you have installed; that's not manageable.
    #}}}
    execute $'doautocmd filetype {&filetype}'

    # recompute folds
    foldlevel(1)
    # and their titles
    doautocmd <nomodeline> BufWinEnter
    # to preserve the highlighting of trailing whitespace
    TrailingWhitespace(true)

    # Re-install HGs which might have been cleared after changing the color scheme.{{{
    #
    # Remember that to change the brightness of seoul, in effect, we *do* change
    # the color scheme.
    # Also,  note that  `doautocmd  Syntax` will  only re-install  a  HG if  its
    # attributes are defined in a syntax plugin which is sourced for the current
    # buffer.
    #}}}
    # We already run `:doautocmd Syntax` from an autocmd listening to `ColorScheme`.  Is it really useful here?{{{
    #
    # Yes.
    #
    # For  performance  reason,  the  autocmd only  iterates  over  the  buffers
    # *displayed* in a window.
    #
    # MRE:
    #
    #     $ tee --append ~/.vim/after/syntax/conf.vim <<'EOF'
    #     syntax match confError /some error/
    #     highlight confError ctermbg=red
    #     EOF
    #
    #     $ tee --append /tmp/conf.conf <<'EOF'
    #     # some comment
    #     some error
    #     EOF
    #
    #     $ vim ~/.bashrc /tmp/conf.conf
    #     :bnext | bprevious " to source conf syntax plugin
    #     ]ol
    #     [ol
    #     :bnext
    #
    # `some error` should be highlighted in red; it's not.
    # The `confError` HG has been cleared when we pressed `]ol` and `[ol`.
    # It has not been re-installed by  our autocmd, because there was no `.conf`
    # file displayed anywhere.
    #}}}
    doautocmd Syntax
    # Do *not* change the syntax syncing rules.{{{
    #
    #     ✘
    #     syntax sync minlines=200
    #     syntax sync maxlines=400
    #
    # It could cause the buffer to be highlighted differently, which is too confusing.
    # If you have an issue with a particular filetype, edit its syntax plugin.
    # And don't blindly run `syntax sync fromstart`; it can be too costly (it is
    # in our vimrc).
    #}}}

    winrestview(view)
enddef

# =m                  fix macro {{{4

# Usage:
#     =ma  →  edit recording a
nnoremap =m <ScriptCmd>FixMacro()<CR>

var fix_macro_c: string
def FixMacro()
    # don't open several windows if we press `=m` several times consecutively
    if !empty(fix_macro_c)
        return
    endif
    var char: string = getcharstr()
    if char !~ '^[a-z]$'
        return
    endif
    # Why don't you use the command-line window?{{{
    #
    # When the  register contains some  special characters (like `C-u`),  and we
    # press  Enter  to  leave  the  command-line window,  the  register  is  not
    # populated with what we expect.
    #}}}
    :40 vnew
    &l:bufhidden = 'wipe'
    &l:buftype = 'nofile'
    &l:buflisted = false
    &l:modified = false
    &l:swapfile = false
    &l:winfixwidth = true
    &l:wrap = true
    augroup FixMacro
        autocmd! * <buffer>
        fix_macro_c = char
        autocmd QuitPre <buffer> setreg(fix_macro_c, [getline(1)], 'c') | fix_macro_c = ''
    augroup END
    if !has('gui_running')
        # When running the macro, we don't want an escape to be wrongly translated as part of a terminal sequence.{{{
        #
        # E.g. `Esc f` → `M-f`.
        #
        # If we insert an escape character, it's probably just to get back to normal mode.
        #}}}
        # What if I really want to insert an escape?{{{
        #
        #     i C-r = " \ e " CR
        #}}}
        inoremap <buffer> <C-V><Esc> <C-V><C-\><C-V><C-N>
    endif
    nnoremap <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<ScriptCmd>quit<CR>'
    nmap <buffer><nowait> <CR> q
    nmap <buffer><nowait> ZZ q
    getreg(char, true, true)->setline(1)
    normal! 1|0f'
enddef
#}}}3
# hyphen {{{3
# -a  -8           ascii / bytes info {{{4

# We remap `-a`  to a function of  the `unicode.vim` plugin which  gives us more
# info about the character under the cursor.
# In   particular,   its  unicode   name,   html   entity  (`&entity_name;`   OR
# `&#entity_number;`), and digraph inside parentheses (if there's one defined).
#
# We also capture the  output of the command in the `o` register,  to be able to
# dump it in a buffer.
nnoremap -a <ScriptCmd>UnicodeGa()<CR>

def UnicodeGa()
    var out: string = execute('UnicodeName', 'silent!')->substitute('\s*$', '', '')
    setreg('o', [out], 'c')
    execute 'UnicodeName'
enddef

# We remap `-8` to `g8` for consistency.
nnoremap -8 <ScriptCmd>GetCharbyte()<CR>

def GetCharbyte()
    var out: string = execute('normal! g8', 'silent!')[1 :]
        ->substitute('\s*$', '', '')
    setreg('o', [out], 'c')
    echo @o
enddef

# -f  -F           print filetype / filetype plugins {{{4

nnoremap -f <ScriptCmd>PrintFiletype()<CR>
nnoremap -F <ScriptCmd>myfuncs.FileTypePlugins()<CR>

def PrintFiletype()
    setreg('o', [!empty(&filetype) ? &filetype : '∅'], 'c')
    echohl Title
    echo $'[filetype] {@o}'
    echohl NONE
enddef

# -i               print indent settings {{{4

nnoremap -i <ScriptCmd>PrintIndentSettings()<CR>

def PrintIndentSettings()
    var settings: list<string> =<< trim eval END
        shiftwidth:  {&l:shiftwidth}
        expandtab:   {&l:expandtab}
        tabstop:     {&l:tabstop}
    END
    settings->setreg('o', 'c')
    for line: string in getreg('o', true, true)
        # We should get a visual clue if 'tabstop' is not 8.{{{
        #
        # Many projects (especially old ones like Linux and Vim itself) mandates
        # tabs as 8 spaces:
        # https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation
        #
        # Have a look at the main Vim help file with a 'tabstop' different than 8:
        #
        #     $ vim +'help | set tabstop=4'
        #
        # Notice that  many fields are  no longer correctly aligned,  making the
        # document confusing and harder to read.
        #}}}
        if line =~ '^tabstop' && line !~ ' 8$'
            echohl ErrorMsg
            echo line
            echohl NONE
        else
            echo line
        endif
    endfor
enddef

# -p  -P           print full path / working directory {{{4

# `C-g` does something similar (`:help ^g`), but its output is:{{{
#
#    - noisy
#    - not colored
#    - unable to expand `~`
#    - relative to the working directory
#}}}
nnoremap -p <ScriptCmd>PrintFullPath()<CR>
nnoremap -P <ScriptCmd>PrintCWD()<CR>

def PrintFullPath()
    if &buftype == 'quickfix'
        var out: string = get(w:, 'quickfix_title', 'no title')
        setreg('o', [out], 'c')
        echo @o
        return
    endif

    var fname: string = expand('%:p')
    # later, we'll compare `fname` with its resolved form,
    # and the comparison might be wrongly different because of an extra ending slash
    fname = fname->substitute('/$', '', '')

    if fname == ''
        @o = '[No Name]'
    else
        if fname[0] == '/' || fname =~ '^\l\+://'
            var resolved: string = resolve(fname)
            var out: string = resolved == fname ? fname : $'{fname} -> {resolved}'
            setreg('o', [out], 'c')
        else
            # Why is adding the current working directory sometimes necessary?{{{
            #
            # If you edit a new buffer whose path is relative (to the working
            # directory), `expand('%:p')` will return a relative path:
            #
            #     :cd /tmp
            #     :edit foo/bar
            #     :echo expand('%:p')
            #}}}
            var out: string = $'{getcwd()}/{fname}'
            setreg('o', [out], 'c')
        endif
    endif

    echo @o
enddef

def PrintCWD()
    var CWD: list<string> =<< trim eval END
        window:  {getcwd()}
        tabpage: {getcwd(-1, 0)}
        global:  {getcwd(-1)}
    END
    # 'c' instead of 'l' to prevent the insertion of a trailing newline
    CWD->setreg('o', 'c')
    echo @o
enddef

# -r               edit README {{{4

# Works also for a CONTENTS file.
#
# Idea: Create a `CONTENTS.md` file in each of your wiki.
# Use it as  a table of contents,  which briefly explains what each  page of the
# wiki is about.

nnoremap -r <ScriptCmd>myfuncs.EditReadme()<CR>

# -s               edit snippets {{{4

nnoremap -s <ScriptCmd>UltiSnipsEdit<CR>

# -U               print unicode table {{{4

# We define this mappping because  it's more convenient than the `:UnicodeTable`
# command, and  to install a buffer-local  mapping to close the  “unicode table“
# window with a single `q` (instead of `:quit`).
nnoremap -U <ScriptCmd>UnicodeTable()<CR>

def UnicodeTable()
    execute 'UnicodeTable'
    nnoremap <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<ScriptCmd>quit<CR>'
enddef

# }}}3
# plus {{{3
# +>    +<      split/join listing or long data {{{4

# long data = dictionary, list, bulleted list

nnoremap <expr> +> myfuncs.LongDataSplit()

nnoremap <expr> +< myfuncs.LongDataJoin()
xnoremap <expr> +< myfuncs.LongDataJoin()

# +D            decode base64 {{{4

nnoremap <expr> +D DecodeBase64()
xnoremap <expr> +D DecodeBase64()
nnoremap <expr> +DD DecodeBase64() .. '_'

def DecodeBase64(type = ''): string
    if type == ''
        &operatorfunc = DecodeBase64
        return 'g@'
    endif

    var lnum1: number = line("'[")
    var lnum2: number = line("']")
    var range: string = $':{lnum1},{lnum2}'
    execute $'silent {range} !base64 --decode --wrap=0'

    return ''
enddef

# +a            remove ANSI escape codes {{{4

nnoremap <expr> +a RemoveAnsiEscapeCodes()
xnoremap <expr> +a RemoveAnsiEscapeCodes()
nnoremap <expr> +aa RemoveAnsiEscapeCodes() .. '_'

def RemoveAnsiEscapeCodes(type = ''): string
    if type == ''
        &operatorfunc = RemoveAnsiEscapeCodes
        return 'g@'
    endif

    # leave that  check here,  for the  error message  to not  be erased  by a
    # motion object (e.g. `G`)
    if !executable('ansi2txt')
        echohl ErrorMsg
        echomsg 'missing dependency: ansi2txt'
        echohl NONE
        return ''
    endif

    var lnum1: number = line("'[")
    var lnum2: number = line("']")
    var range: string = $':{lnum1},{lnum2}'
    execute $'{range} !ansi2txt'

    return ''
enddef

# +e            emphasize {{{4

# word → *word*
# WORD → *word*
nnoremap <expr> +e Emphasize()
def Emphasize(type = ''): string
    if type == ''
        &operatorfunc = Emphasize
        return 'g@l'
    endif

    var word: string = expand('<cword>')
    if word !~ '^\k\+$'
        return ''
    endif
    var line: string = getline('.')
    var pat: string = '\<\%('
        # the cursor is in the middle of a word, or on its last character
        ..     $'\%<.c{word}\%>.c'
        .. '\|'
        # the cursor is on the first character of a word
        ..     $'\%.c{word}'
        .. '\)\>'
    if line !~ pat
        return ''
    endif
    var rep: string = $'*{tolower(word)}*'
    var new_line: string = line->substitute(pat, rep, '')
    setline('.', new_line)
    return ''
enddef

# +E            expand short options in shell command {{{4

#     grep -iw -C3
#     →
#     grep --ignore-case --word-regexp --context=3
#
#     ls -larth
#     →
#     ls -l --all --reverse -t --human-readable
nnoremap <expr> +E myfuncs.ExpandShortOptionsInShellCmd()
xnoremap <expr> +E myfuncs.ExpandShortOptionsInShellCmd()

# +t            trim whitespace {{{4

nnoremap <expr> +t  myfuncs.OpTrimWs()
xnoremap <expr> +t  myfuncs.OpTrimWs()
nnoremap <expr> +tt $'{myfuncs.OpTrimWs()}_'
# }}}3
# Control / Meta / CR / Tab / Shift {{{3
# CR                  move cursor on 80th column {{{4

# If the buffer is special (`!empty(&buftype)`), we let `CR` unchanged.
# Special  buffers  include   the  ones  displayed  in  the   quickfix  and  the
# command-line windows.
# It's important to not alter the behavior of `CR` in those buffers, because
# usually it's already mapped to a very useful function such as executing
# a command or going to an entry in the quickfix list.
#
# Otherwise, if the buffer  is a regular one, we remap `CR` to  move on the 80th
# column.  It can be overridden on a filetype-basis, by an arbitrary Ex command.
# Example:
#
#     b:cr_command = 'echo "hello"'
#
# If we wrote the previous line in a python ftplugin, hitting CR would display
# 'hello'.

nnoremap <expr> <CR> CR()
def CR(): string
    return !empty(&buftype)
        ? "\<CR>"
        : "\<ScriptCmd>" .. getbufvar('%', 'cr_command', "normal! 80\<Bar>") .. "\<CR>"
enddef

# C-]                 jump to definition {{{4

# Purpose:{{{
#
# This mapping overloads `C-]`.
#
# It keeps  its default behavior, however,  if it fails because  there's no tags
# file, it tries `1gd` as a fallback.
#
# It's useful for example, in `~/bin`, where atm we don't have any tags file.
#}}}
# Why `1gd` instead of `gd`?{{{
#
# Sometimes, `gd` jumps  to a location where the identifier  under the cursor is
# present, but it's not its definition.
# It happens for example,  if you have a shell script  which includes a function
# `install`, and the command `apt install package` somewhere in a function.
#
# `1gd` makes `gd` ignore any occurrence of the identifier which is inside curly
# brackets, and with  the closing one written  on a column whose  index is lower
# than the one of the current cursor position.
#}}}
nnoremap <C-]> <ScriptCmd>JumpToDefinition()<CR>

def JumpToDefinition()
    try
        execute "normal! \<C-]>zvzz"
    catch /^Vim\%((\a\+)\)\=:E\%(426\|433\)/
        if &filetype != 'help'
            normal! 1gd
            normal! zvzz
        else
            lg.Catch()
            return
        endif
    catch
        lg.Catch()
        return
    endtry
enddef

# C-g                 run simple macro {{{4

# run a simple macro on all the lines
# What do you mean by “simple”?{{{
#
# It doesn't contain many keys, and it doesn't alter the addresses of the lines.
# Remember that `:normal`  – like most Ex commands –  doesn't mark the lines
# in its range, contrary to `:global`.
#}}}
nnoremap <C-G>n :% normal!<Space>

# C-[np]              move across tab pages {{{4

nnoremap <C-P> <ScriptCmd>tabprevious<CR>
nnoremap <C-N> <ScriptCmd>execute $':{v:count > 1 ? v:count : ''}tabnext'<CR>

# C-q [tT]            search Todo, fixme, ... {{{4

nnoremap <C-Q>t <ScriptCmd>myfuncs.SearchTodo('buffer')<CR>
nnoremap <C-Q>T <ScriptCmd>myfuncs.SearchTodo('project')<CR>
#           │
#           └ quickfix

# C-w s               send to tab page {{{4

nnoremap <C-W>s <ScriptCmd>myfuncs.SendToTabPage(v:count)<CR>
# }}}3
# @@ {{{3

# Save the name of the last register executed interactively, to avoid a pitfall with `@@`.{{{
#
# During a  recording, if  you use a  mapping whose RHS  contains `@=`,  it will
# reset the last executed register.
#
# More generally,  if you execute  `@b` during  a recording into  register `"a`,
# `"b` will be considered  to be the last executed register,  not `"a`, and `@@`
# will re-execute it.  If that happens,  you'll probably find `@@`'s behavior to
# be unexpected.
#
#     let @a = "a@a\<Esc>@b"
#     let @b = "a @b \<Esc>"
#     # press @a: '@a @b ' is inserted
#     # press @@: ' @b'    is inserted
#
# To “fix” this, we  use this `@` wrapper mapping to save  the name of the
# last  register  executed *interactively*.   We  assume  that a  register  is
# executed interactively if, and only if, no recording is active.
# Note  that this  assumption might  be wrong;  you *could*  execute a  register
# interactively while  a recording is  active.  But  in practice, I  doubt we'll
# ever want to re-execute such a register with `@@`.
# Usually,  we  press  `@@`  to  re-execute  a  register  which  we've  executed
# previously *outside* a recording.
#}}}
nnoremap <expr> @ SaveLastRegisterExecutedInteractively()
def SaveLastRegisterExecutedInteractively(): string
    # ask which register we want to execute
    var char: string = getcharstr()
    if char !~ '^\%([a-z]\|:\)$'
        return '@'
    endif
    if reg_executing()->empty()
        last_register_executed_interactively = char
    endif
    return $'@{char}'
enddef

nnoremap <expr> @@ Atat()
def Atat(): string
    return $'@{last_register_executed_interactively}'
enddef
var last_register_executed_interactively: string = '@'

# _                   0_ {{{3

# Problem:
#
#     set columns=80
#     'some short text'->setline(1)
#     (repeat(' ', 50) .. repeat('some long text ', 10))->setline(2)
#     &l:wrap = false
#     # press:
#     #     G to move on the last line
#     #     $ to move on the last character
#     #     _ to move on the first non-whitespace
#
# The text of the first line is partially hidden.
# You can only read `text`, not `some short text`.
#
# Solution:
nnoremap _ 0_

# << >>               indent with 'shiftround' {{{3

nnoremap <expr> >> IndentWithShiftround('>>')
nnoremap <expr> << IndentWithShiftround('<<')

def IndentWithShiftround(cmd: string, type = ''): string
    if type == ''
        &operatorfunc = function(IndentWithShiftround, [cmd])
        return 'g@l'
    endif
    var shiftround_save: bool = &shiftround
    try
        &shiftround = true
        g:d_ebug = $'normal! {v:count != 0 ? v:count : ''}{cmd}'
        execute $'normal! {v:count != 0 ? v:count : ''}{cmd}'
    catch
        lg.Catch()
        return ''
    finally
        &shiftround = shiftround_save
    endtry
    return ''
enddef

# <b  >b              destroy/create box {{{3

# Draw a box around the text inside the paragraph.
# The fields must be separated with `|`.
# The function will populate the `s` and `x` registers with 2 kind of separation
# lines.  We can paste them to fine tune the box.
nnoremap <expr> >b $'{myfuncs.BoxCreate()}ip'

# undo the box, make it come back to just bars between cells
nnoremap <expr> <b $'{myfuncs.BoxDestroy()}ip'

# ""                  easy access to clipboard register (and tweak put/yank) {{{3
# Warning: Don't tweak `'clipboard'` instead.{{{
#
# It causes too many issues.  Use a mapping instead.
#}}}
# Warning: Do *not* try to replace `‘` or `’` with `'`.{{{
#
# It's  way trickier  than  it  seems.  You  would  undoubtedly perform  wrong
# replacements.
#}}}

nnoremap ""p <ScriptCmd>EditClipboard()<CR>"+p
nnoremap "" "+
xnoremap ""p <ScriptCmd>EditClipboard()<CR>"+p
xnoremap "" "+

def EditClipboard()
    var reginfo: dict<any> = getreginfo('+')
    var contents: list<string> = get(reginfo, 'regcontents', [])
    var original: list<string> = contents->copy()

    if &filetype == 'markdown' || &filetype == 'navi'
        contents
            ->map((_, line: string) => line
            ->substitute('\w\zs \ze, \w', '', 'g'))
        if getline('.') =~ '^\S\|^$'
            contents
                ->map((_, line: string) =>
                    line->substitute('^\s*\zs\Chttp.*', '<&>', ''))
        endif
    endif

    contents
        ->map((_, line: string) =>
            line
            ->tr('٪', '$')
            # when we copy-paste a command from  a PDF, sometimes, some spaces are
            # represented with  no-break spaces,  which prevents the  command from
            # running correctly; let's fix that
            ->tr("\u00a0", ' '))

    # Only reset the clipboard if necessary to avoid creating confusing noise in logs.{{{
    #
    # To make  the clipboard persist  after quitting Vim,  we write it  into a
    # file, which  is watched by a  systemd unit path, to  automatically start
    # `xsel(1x)`.  Setting the clipboard with `setreg()` might cause this line
    # to be added in the journal:
    #
    #     $ journalctl --user --boot=-0 --no-hostname --pager-end -nall --unit=vim-persistent-clipboard.service
    #     ...
    #     [...]: vim-persistent-clipboard.service: Succeeded.
    #
    # That's  because `xsel(1x)`  was  running  to own  the  clipboard from  a
    # previous Vim  instance, and now it's  no longer needed; the  current Vim
    # instance has become the new owner.
    #
    # Anyway, if you're debugging a clipboard issue, this line is confusing.
    #}}}
    if contents != original
        setreg('+', reginfo)
    endif
enddef

# When we yank a multiline shell command, we want to be able to put it and run
# it immediately in an interactive shell.
augroup FixMultilineShellCommand
    autocmd!
    autocmd TextYankPost * FixMultilineShellcmd()
augroup END

def FixMultilineShellcmd()
    if v:register != '+'
        return
    endif

    var reginfo: dict<any> = getreginfo('+')
    var contents: list<string> = get(reginfo, 'regcontents', [])
    var original: list<string> = contents->copy()
    if empty(contents)
        return
    endif

    var cml: string
    if &l:commentstring != ''
        cml = &l:commentstring->matchstr('\S*\ze\s*%s')
        cml = $'\%(\V{escape(cml, '\')}\m\)\='
    endif

    # remove possible dollar sign in front of a shell command
    var pat: string = $'^\s*{cml}\s*\$\s'
    if contents[0] =~ pat
        contents[0] = contents[0]->substitute(pat, '', '')
        # remove possible comment leaders in front of continuation lines
        if cml != ''
            contents->map((_, v: string) => v->substitute($'^\s*{cml}\s*', '  ', ''))
        endif
    endif

    # remove possible indentation/comment leader in front of terminating `EOF`
    if len(contents) > 1
        # Why do you look for `EOF` only on the first line of the register?{{{
        #
        # We don't want to remove the  indentation if we're copying a bug report
        # which  includes some  heredoc.   We  need it  so  that it's  correctly
        # formatted as a codeblock on whatever forum we paste it.
        #}}}
        if contents[0] =~ '<<-\=\([''"]\=\)EOF\1'
            var eof_line: string = contents[match(contents, $'^\s*{cml}\s*EOF$')]
            var indent: string = eof_line->matchstr($'^\s*{cml}\s*')
            contents
                ->map((_, v: string) => v->substitute(indent, '', ''))
        endif
    endif

    if contents != original
        setreg('+', reginfo)
    endif
enddef

# Problem: Fix `E353` in case `"+` has been written into from another Vim instance.{{{
#
# Indeed, the previous mapping and autocmd write into `"+`; now watch this:
#
# First Vim instance:
#
#     :call setline(1, 'first')
#     :normal! "+y$
#     :registers "+
#     Type Name Content
#       c  ""   first
#       c  "+   first
#
# Second Vim instance:
#
#     :let @+ = 'second'
#     :registers "+
#     Type Name Content
#       c  "+   second
#
# For some  reason, writing into  `"+` from a  second Vim instance  breaks the
# connection from `""` to `"+` in the first instance.
#}}}
# Solution: run `:registers "` before putting the unnamed register.{{{
#
# For some reason, this reconnects `""` to `"+`.
#}}}
# https://github.com/vim/vim/issues/6435
nnoremap <expr> p P('p')
nnoremap <expr> P P('P')
xnoremap <expr> p P('p')
xnoremap <expr> P P('P')

def P(key: string): string
    silent registers "
    return key
enddef

# { }                 move by paragraphs {{{3

nnoremap { <ScriptCmd>search('\(^\s*$\<Bar>\%^\)\_s*\zs\S', 'bW')<CR>zv
nnoremap } <ScriptCmd>search('\S\+.*\ze\n\s*$', 'W')<CR>zv

# ] C-S               send to server {{{3

# Install a  mapping to  send the  current Vim buffer/file  to a  remote running
# server.   This is  useful –  in particular  – to  send the  output of  a shell
# command to our main Vim instance.
nnoremap ]<C-S> <ScriptCmd>myfuncs.SendToServer()<CR>

# c*                  change word under cursor {{{3

# Why `setreg()`?  Why not the simpler `*` normal command?{{{
#
# It would move the cursor to the next occurrence of the word.
# We could use a  double backtick to get back where we were,  but the view might
# still change which is too distracting.
#
# Besides, `*` ignores `'smartcase'`.  We want the latter to be honored.
# The way to fix this is to search back for the word via the `/` command:
#
#     *``/<Up><CR>``cgn
#
# But again, the view might be changed.
#}}}
# bounded search
nnoremap c* <ScriptCmd>expand('<cword>')->printf('\<%s\>')->setreg('/')<CR>cgn
# UNbounded search
nnoremap cg* <ScriptCmd>expand('<cword>')->setreg('/')<CR>cgn

# d[gv]...            delete all lines containing/excluding some pattern {{{3

# If you need to delete folds, use `zd`, `zD`, or `zE`.
# They also work in visual mode (except `zE`).

nnoremap dg<Space> <ScriptCmd>myfuncs.DeleteMatchingLines('empty')<CR>
xnoremap mg<Space> <ScriptCmd>myfuncs.DeleteMatchingLines('empty')<CR>

nnoremap dg# <ScriptCmd>myfuncs.DeleteMatchingLines('comments')<CR>
xnoremap mg# <ScriptCmd>myfuncs.DeleteMatchingLines('comments')<CR>
nnoremap dv# <ScriptCmd>myfuncs.DeleteMatchingLines('comments', true)<CR>
xnoremap mv# <ScriptCmd>myfuncs.DeleteMatchingLines('comments', true)<CR>

nnoremap dg/ <ScriptCmd>myfuncs.DeleteMatchingLines('search')<CR>
xnoremap mg/ <ScriptCmd>myfuncs.DeleteMatchingLines('search')<CR>
nnoremap dv/ <ScriptCmd>myfuncs.DeleteMatchingLines('search', true)<CR>
xnoremap mv/ <ScriptCmd>myfuncs.DeleteMatchingLines('search', true)<CR>

# dr                  replace without yank {{{3

nnoremap <expr> dr  myfuncs.OpReplaceWithoutYank()
nnoremap <expr> drr $'{myfuncs.OpReplaceWithoutYank()}_'

# j  k  ^  0  $       gj  gk  ... {{{3

# let us move across several lines of a long wrapped line with `j` and `k`
nnoremap <expr> j JK('j')
nnoremap <expr> k JK('k')

def JK(key: string): string
    var keys: string
    # if we used a count, we probably don't care about wrapped lines
    if v:count != 0
            # Don't use `gj` or `gk` when we're in a closed fold.{{{
            #
            # Otherwise, when we  open a fold with `za`, the  first visible line
            # depends on the direction in which we landed on the fold:
            #
            #  - if we've moved from *below*, the first visible line is the
            #    *last* line in the fold
            #
            #  - if we've moved from *above*, the first visible line is the
            #    *first* line in the fold
            #
            # This is a new behavior introduced in 8.2.2385.
            # It might make sense, but I  find this confusing; I prefer the fold
            # to always open in the same way, regardless of how we reached it.
            #}}}
            || foldclosed('.') >= 0
        # If the count is bigger than 5, we consider the motion as a jump useful
        # to come back with `C-o`.
        if v:count >= 5
            keys = "m'"
        endif
        keys ..= $'{v:count}{key}'
    else
        keys = $'g{key}'
    endif
    return keys
enddef

nmap <Down> j
nmap <Up> k

# If we're inside a long wrapped line, `^` and `0` should go the beginning
# of the line of the screen (not the beginning of the long line of the file).
nnoremap ^ g^
nnoremap 0 g0

# To draw freely, sometimes we need to enable 'virtualedit'.
# And then, when we press `$`, the cursor moves to the very end of the screen.
# We never want that.  We want the cursor on the last non whitespace.
nnoremap <expr> $ &virtualedit == 'block' ? '$' : 'g_'
# Do *not* use `g$` by default (i. e. don't write `g$` in the LHS when 'virtualedit' is 'block')!  Keep using `$`.{{{
#
# It would break the dot command when you've pressed `$` right before.
#
# MRE:
#
#     var lines =<< END
#     foo = a
#           ab
#           abc
#     END
#     lines->setline(1)
#
#     # press: / a$
#     # press: C-v G h A ' Esc
#     # press: g$.
#
# Expected:
#
#     foo = 'a'
#           'ab'
#           'abc'
#
# Actual:
#
#     foo = 'a'
#           'a'b
#           'a'bc
#
# Theory: Maybe `$` moves the cursor on the  newline, while `g$` moves it on the
# last character of the screen line (excluding the newline).
# And for the dot command to work as expected, we need to be on the newline...
#}}}

# Same mappings for visual mode.
xnoremap j gj
xnoremap k gk
xnoremap ^ g^
xnoremap 0 g0

# J        gJ         join without moving {{{3

nnoremap <expr> J $'m''{v:count1}J``'

# gJ doesn't insert or remove any spaces
nnoremap <expr> gJ $'m''{v:count1}gJ``'

# Q        q {{{3

# no more entering Ex mode by accident
nnoremap Q q
# }}}2
# Objects {{{2
# i- {{{3

xnoremap i- <ScriptCmd>myfuncs.TextObjHorizontalRule('inside')<CR>
xnoremap a- <ScriptCmd>myfuncs.TextObjHorizontalRule('around')<CR>

onoremap i- <ScriptCmd>normal Vi-<CR>
onoremap a- <ScriptCmd>normal Va-<CR>

# iE {{{3

# Entire buffer.
# We don't use `ie` but `iE`, because `ie` is too easily typed.
# We could easily delete the whole buffer by accidentally pressing `cie`, `die`.

xnoremap iE G$ogg0
onoremap iE <ScriptCmd>normal ViE<CR>

# iF {{{3

xnoremap iF <ScriptCmd>FencedCodeblock('inside')<CR>
xnoremap aF <ScriptCmd>FencedCodeblock('around')<CR>

onoremap iF <ScriptCmd>normal ViF<CR>
onoremap aF <ScriptCmd>normal VaF<CR>

def FencedCodeblock(what: string)
    if mode() != 'V'
        normal! V
    endif
    if what == 'around'
        if search('^```\l*$', 'bW') == 0
            return
        endif
        normal! o
        search('^```$', 'W')
    else
        if search('^```\l*$', 'bW') == 0
            return
        endif
        normal! jo
        if search('^```$', 'W') == 0
            return
        endif
        normal! k
    endif
enddef

# iN {{{3

# next number after cursor on current line
xnoremap in <ScriptCmd>TextobjNumber(false)<CR>
# same thing, but includes possible whitespace after the number
xnoremap an <ScriptCmd>TextobjNumber(true)<CR>

onoremap in <ScriptCmd>normal vin<CR>
onoremap an <ScriptCmd>normal van<CR>

def TextobjNumber(around: bool)
    var stopline: number = line('.')
    var pat: string = $'\%({GetPatnum()}\){around ? '\s*' : ''}'
    # move cursor to end of number
    if search(pat, 'ceW', stopline) == 0
        return
    endif

    # select back to start of number
    normal! o
    search(pat, 'bcW', stopline)
enddef

def GetPatnum(): string
    var sign: string = '[-+]\='
    var decimal: string = '\d\+\.\=\d*'
    var fraction: string = '\.\d\+'
    var exponent: string = $'[eE]{sign}\d\+'
    var number: string = printf('%s\%%(%s\|%s\)\%%(%s\)\=',
        sign, decimal, fraction, exponent)

    var binary: string = '0b[01]\+'
    var hex: string = '0x\x\+'

    # the order matters; keep `number` at the end
    var pat: string = $'{binary}\|{hex}\|{number}'
    return pat
enddef

# if / iC {{{3

# function or class

xnoremap if <C-\><C-N><ScriptCmd>myfuncs.TextObjBlock('function', true)<CR>
xnoremap af <C-\><C-N><ScriptCmd>myfuncs.TextObjBlock('function', false)<CR>

onoremap if <ScriptCmd>normal Vif<CR>
onoremap af <ScriptCmd>normal Vaf<CR>

xnoremap iC <C-\><C-N><ScriptCmd>myfuncs.TextObjBlock('class', true)<CR>
xnoremap aC <C-\><C-N><ScriptCmd>myfuncs.TextObjBlock('class', false)<CR>

onoremap iC <ScriptCmd>normal ViC<CR>
onoremap aC <ScriptCmd>normal VaC<CR>

# il {{{3

# `il` = in line (operate on the text between first and last non-whitespace on the line)
# Useful to copy a line and paste it characterwise (in the middle of another line)

xnoremap il _og_
xnoremap al V

onoremap il <ScriptCmd>normal vil<CR>
onoremap al _

# We don't need to create `al` (around line) to operate on the whole line
# including newline, because `_` can be used instead.
# Example:
#
#     +y_
#     +y3_
#
# ... add current line to plus register (`+y` = custom operator, incremental yanking).
# Besides, an operator should  be able to operate on the  current line when it's
# repeated (`cc`, `yy`, `dd`...).
# But still, it brings consistency/symmetry.

# }}}2
# Select {{{2

# move to left/right in select mode (useful for UltiSnips)
snoremap <C-B> <C-\><C-N>i<Left>
snoremap <C-F> <C-\><C-N>i<Right>

# After expanding a  snippet, we want to  be able to delete  the character after
# the cursor with C-d like in insert mode.
snoremap <C-D> <C-\><C-N>i<Del>

# Visual {{{2
# C-g g {{{3

# search inside visual selection
# What difference with `:* ilist! foobar`?{{{
#
# `:ilist`:
#
#    - searches in all included files. `:global` only in current buffer.
#    - can ignore comment if we don't put a bang
#    - automatically adds `\<`,`\>` around the pattern, if we don't surround it with slashes
#}}}
xnoremap <C-G>g <C-\><C-N>:* g/\%V/#<Left><Left>

# /           search only in visual selection {{{3

# Do not try to install an `<expr>` mapping which would return the keys.{{{
#
# Before the  function checks the  position of the  visual marks, you  must have
# quit visual mode so that they have been updated.
# But you can't do that if the function is called while the text is locked.
#}}}
xnoremap / <ScriptCmd>VisualSlash()<CR>
def VisualSlash()
    # if  we've selected  only 1  line, we  probably don't  want to  look for  a
    # pattern; instead, we just want to extend the selection
    if line('v') == line('.')
        feedkeys('/', 'in')
    else
        feedkeys("\<C-\>\<C-N>/\\%V", 'in')
    endif
enddef

# .    @ {{{3

# repeat last edit on all the visually selected lines with dot
xnoremap . <C-\><C-N><ScriptCmd>:* normal! .<CR>

# Purpose:{{{
#
# Repeat last macro on all the visually selected lines with `@{reg}`.
#}}}
# Do *not* add a bang after `:normal`.{{{
#
# We want the recursiveness, for one of our mapping to be used.
# It temporarily disables some keysyms which might break the replay of a macro.
#}}}
xnoremap @ <C-\><C-N><ScriptCmd>execute $':* normal @{getcharstr()}'<CR>

# A  I  gI    niceblock {{{3

# https://github.com/kana/vim-niceblock/blob/master/doc/niceblock.txt
#
# v_b_I = Visual-block Insert
# v_b_A = Visual-block Append
#
#    - Make |v_b_I| and |v_b_A| available in all kinds of Visual mode.
#    - Adjust the selected area to be intuitive before doing blockwise insertion.

# Why appending `h` for the `$` motion in characterwise and blockwise visual mode?{{{
#
# In characterwise visual mode, `$` selects the trailing newline.
# We don't want that; `h` makes sure we leave it alone.
#
# ---
#
# In blockwise  visual mode, if you  set `'virtualedit'` with the  value `block`
# (which we do by default), then something unexpected happens.
#
# MRE:
#
#     abc
#     def
#     ghi
#
# Position the cursor on `a` and press `C-vjj$`, then yank or delete the block.
# Paste it below by running `:put` (or pressing our custom `]p`):
# a trailing space is added on every pasted line.
#
# What's weird,  is that the  contents and type of  the unnamed register  is not
# affected by our custom `'virtualedit'`.
# You only see a difference when you paste.
#
# Anyway, I don't like that trailing space.
# That's not how  Vim behave without config;  so this makes it  harder to follow
# instructions found on forums.
# Besides, a trailing space is useless.
#}}}
var niceblock_keys: dict<dict<string>> = {
    '$':  {v: 'g$h',      V: '$',          "\<C-V>": '$h'},
    'I':  {v: "\<C-V>I",  V: "\<C-V>^o^I", "\<C-V>": 'I'},
    'A':  {v: "\<C-V>A",  V: "\<C-V>0o$A", "\<C-V>": 'A'},
    'gI': {v: "\<C-V>0I", V: "\<C-V>0o$I", "\<C-V>": '0I'},
    '>':  {v: "\<C-V>>",  V: "0\<C-V>>",   "\<C-V>": '>'},
    '<':  {v: "\<C-V><",  V: "0\<C-V><",   "\<C-V>": '<'},
}

def Niceblock(key: string): string
    return niceblock_keys[key][mode()]
enddef


# The purpose of this mapping is to not include a newline when selecting
# a characterwise text until the end of the line.
xnoremap <expr> $ Niceblock('$')
xnoremap <expr> I Niceblock('I')
xnoremap <expr> gI Niceblock('gI')
xnoremap <expr> A Niceblock('A')

# Why these assignments:
#
#     niceblock_keys['>']['V'] = "0\<C-V>>"
#     niceblock_keys['<']['V'] = "0\<C-V><"
#
# ... and not simply:
#
#     niceblock_keys['>']['V'] = ">"
#     niceblock_keys['<']['V'] = "<"
#
# ? Because, without `\<C-V>`, sometimes the alignment is lost.

xnoremap <expr> > Niceblock('>')
xnoremap <expr> < Niceblock('<')

# d y         preserve last deleted/yanked visual selected text through registers {{{3

# When we delete sth in visual mode to  move it somewhere else, if we delete sth
# else before  pasting it, we  lose it  (well technically it's  still accessible
# from a numbered register, but if we  delete several things, we have to execute
# `:registers` to see where it is now).

# With this  mapping, we can  always access the last  text we deleted  in visual
# mode, from the `v` register.
xnoremap d d<ScriptCmd>getreginfo('"')->setreg('v')<CR>

# same thing when we yank
xnoremap y y<ScriptCmd>getreginfo('"')->setreg('v')<CR>

# h l         disabled at the beginning/end of line in visual block mode {{{3

# Why `virtcol()`, and not `col()`?{{{
#
# With `col()`,  if the  first character  on the  cursor line  occupies multiple
# cells  but takes  only 1  byte  (e.g. a  tab  character or  a literal  control
# character), `h` would  not be able to  move onto its first cell.   It would be
# blocked on its last cell:
#
#     tab character
#     v------v
#     <------>xxx
#            ^
#            'h' could not move before that cell
#
# This is because  `col('.')` evaluates to 1  when `h` reaches the  last cell of
# the tab character (a tab's weight is 1 byte).
#
# ---
#
# Same thing for `l`.
# We want  to know whether  the cursor has reached  the maximum number  of cells
# which can be  displayed in the current  window.  The byte index  of the cursor
# position could be much bigger depending on the kind of text which is currently
# displayed; but we don't care about the latter.
#}}}
xnoremap <expr> h mode() == '<C-V>' && virtcol('.') == 1 ? '' : 'h'
xnoremap <expr> l VisualBlockL()

# Purpose:{{{
#
# Prevent Vim  from scrolling  horizontally when  we smash `l`  for too  long by
# accident while in visual block mode.
# When  that happens,  we lose  context, and need  to scroll  back in  the other
# direction which is annoying/distracting.
#
# If you *really*  want to visually select beyond the  current last screen cell,
# you can always use another motion like  `e` just to bypass the limit; then `l`
# is not blocked anymore.
#}}}
def VisualBlockL(): string
    if mode() != "\<C-V>"
        return 'l'
    endif

    var sidescrolloff: number = &l:sidescrolloff == -1 ? &g:sidescrolloff : &l:sidescrolloff
    # this should evaluate to the total width of the fold/number/sign columns
    var left_columns: number = win_getid()->getwininfo()[0].textoff

    if virtcol('.') >= winwidth(0) - left_columns - sidescrolloff
        return ''
    endif

    return 'l'
enddef

# ip          disable on empty line {{{3

# Sometimes we press `vip` by accident on an empty line.
# That's annoying, because it can make  me lose previous visual selection (you
# can cycle through the last 2 visual selections with `gv`).

nnoremap <expr> vip getline('.') =~ '^\s*$' ? '' : 'vip'

# mq          populate qfl with lines in the selection {{{3

# Alternative:
xnoremap mq <C-\><C-N><ScriptCmd>execute $':{line("'<")},{line("'>")}cgetbuffer' <Bar> cwindow<CR>

# }}}1
# Commands {{{1
# Warning: Here, do *not* install commands which are only relevant for a specific type of buffer. {{{2
#
# Those should be defined in a filetype plugin with the `-buffer` attribute.
# }}}2

# CartesianProduct {{{2
# https://en.wikipedia.org/wiki/Cartesian_product

# Purpose:{{{
#
# Here is a situation which we frequently encounter:
#
# We find some issue which can be  influenced by several parameters.  To get a
# better understanding,  we want to make  a test in all  possible environments
# (i.e.  for  all  combinations  of parameters  values).   Getting  all  those
# combinations  can be  time-consuming, and  tedious.   We need  a command  to
# automate the task.
#}}}
# Usage:{{{
#
# Write all the possible values of each parameter on a dedicated line, separated
# by whitespace.  Then run the command against this range of lines.
#
# As an example, executing the command on these lines:
#
#     a
#     b c
#
# should replace them with:
#
#     a b
#     a c
#
# And these lines:
#
#     a
#     b c
#     d e f
#
# should be replaced with:
#
#     a b d
#     a b e
#     a b f
#     a c d
#     a c e
#     a c f
#}}}
command -bar -range=% CartesianProduct CartesianProduct(<line1>, <line2>)

def CartesianProduct(lnum1: number, lnum2: number)
    var params: list<list<string>> = getline(lnum1, lnum2)
        ->filter((_, v: string): bool => v != '')
        ->map((_, v: string): list<string> => split(v))

    if len(params) < 2
        return
    endif

    deletebufline('%', lnum1, lnum2)
    cursor(lnum1, 1)
    params->Combine()
    execute $'silent! :{lnum1},{lnum2} EasyAlign *\ '
enddef

def Combine(sets: list<list<string>>, combination = [])
    if sets->empty()
        append(line('.') - 1, combination->join())
        return
    endif

    for item: string in sets[0]
        combination->add(item)
        Combine(sets->slice(1), combination)
        # The next value of `item` (taken in the next iteration of the current
        # `for`  loop) cannot  be simply  appended to  `combination`; it  must
        # *replace* it.
        combination->remove(-1)
    endfor
enddef

# Cfg {{{2

command -bar -nargs=1 -complete=custom,myfuncs.CfgComplete Cfg myfuncs.Cfg(<q-args>)
cnoreabbrev <expr> cfg getcmdtype() =~ '[:>]' && getcmdpos() == 4 ? 'Cfg' : 'cfg'

# Def {{{2

# `:def` – contrary to `:function` – doesn't support any completion.
# https://github.com/vim/vim/issues/6525
# Let's fix that.

command -bar -nargs=? -complete=customlist,lg.FuncComplete Def Def(<q-args>)

def Def(arg_name: string)
    var name: string = arg_name->trim('()')
    # By default `:def` – without argument – prints *all* function names.
    # It's convenient for our `:Def` to only print the names of the Vim9 functions.
    if name == ''
        echo execute('def')
            ->split('\n')
            ->filter((_, v: string): bool => v =~ '^def')
            ->join("\n")
        return
    endif
    try
        execute $'def {name}'
    catch
        lg.Catch()
        return
    endtry
enddef

# DiffLines {{{2

command -bar -bang -range -nargs=? DiffLines myfuncs.DiffLines(<bang>0, <line1>, <line2>, <q-args>)

# DiffOrig {{{2

# See differences between current buffer and original file.
command -bar DiffOrig echo DiffOrig()

def DiffOrig(): string
    g:SaveToggleAuto()
    var conceallevel_save: number = &l:conceallevel
    &l:conceallevel = 0

    if difforig_tmp_file != ''
        silent! delete(difforig_tmp_file)
        difforig_tmp_file = ''
    endif
    difforig_tmp_file = $'{tempname()}/Original File'
    execute $'vnew {difforig_tmp_file}'
    &l:buftype = 'nofile'
    &l:buflisted = false
    &l:swapfile = false
    &l:wrap = false

    bufname('#')
        ->fnamemodify(':p')
        ->readfile()
        ->append(0)
    keepjumps :$ delete _
    &l:modifiable = false
    &l:readonly = true

    diffthis
    nnoremap <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<ScriptCmd>quit<CR>'
    &filetype = getbufvar('#', '&filetype')

    TmpPartial = function(DiffOrigRestoreSettings, [conceallevel_save])
    augroup DiffOrigRestoreSettings
        autocmd! * <buffer>
        autocmd BufHidden <buffer> {
            g:SaveToggleAuto(true)
            timer_start(0, TmpPartial)
        }
    augroup END

    winnr('#')->win_getid()->win_gotoid()
    diffthis
    return ''
enddef
var difforig_tmp_file: string = ''
var TmpPartial: func

def DiffOrigRestoreSettings(conceallevel: number, _)
    &l:conceallevel = conceallevel
    diffoff!
    normal! zvzz
enddef

# DumpWiki {{{2

command -bar -nargs=? DumpWiki myfuncs.DumpWiki(<q-args>)

# GoToChar {{{2

command -bar -nargs=1 GoToChar search('\%^\_.\{<args>}', 'es')

# HighlightColorValues {{{2

# Before any hex color code, display a black square character:
#     ■ #123456
#     ^
# And colorize it using the following hex color code.
# To test the command, open this file: `$VIMRUNTIME/colors/lists/default.vim`

# Don't use an autocmd instead of a command.{{{
#
#     autocmd BufReadPost,BufWritePost,ColorScheme * HighlightColorValues()
#
# There might be false positives:
#
#     $ vim $(locate ctlseqs.txt)
#     ...
#     updated for XTerm Patch #353 (2020/01/26)
#                             ^--^
#     ...
#}}}
command -bang -range=% HighlightColorValues {
    myfuncs.HighlightColorValues('#\zs\%(\x\{6}\|\x\{3}\)\ze\%([ [:punct:]]\|$\)', <bang>0)
}

# HiTest {{{2

command -bar HiTest vimhighlight.HighlightTest()

# HlWeirdWhitespace {{{2

# Why don't you use an autocmd instead?{{{
#
# So, you're thinking about sth like this:
#
#     augroup StrangeWhitespace
#         autocmd!
#         autocmd WinEnter * HlWeirdWhitespace()
#     augroup END
#
# OK, but we wouldn't be able to disable the highlight in a 'fex' buffer.
#
# The  same issue  would probably  apply to  other types  of buffers  (like help
# buffers), where we don't want this highlighting.
#
# The issue comes from the fact that when `WinEnter` is fired after a split, the
# current buffer is still the one displayed  in the original window, not the one
# which is going to be loaded.
# So this guard wouldn't work:
#
#     var bufnr: number = winnr()->winbufnr()
#     if getbufvar(bufnr, '&filetype', '') == 'fex'
#         return
#     endif
#
# MRE:
#
#     :LogEvents -v WinEnter
#     :split /tmp/file
#     12:34  WinEnter  /home/user/.vim/vimrc˜
#                      ^-------------------^
#                      ✘ we would need `/tmp/file`, but the latter has not yet been loaded˜
#}}}
command -bar -range=% HlWeirdWhitespace HlWeirdWhitespace()

def HlWeirdWhitespace()
    if !exists('w:strange_whitespace')
        # https://vi.stackexchange.com/a/17697/17449
        var pat: string = '[\x0b\x0c\u00a0\u1680\u180e'
            .. '\u2000-\u200a\u2028\u202f\u205f\u3000\ufeff]'
        #       ^-----------^
        #       yes, one can write an arbitrary range of unicode characters
        w:strange_whitespace = matchadd('ErrorMsg', pat, 0)
    else
        matchdelete(w:strange_whitespace)
        unlet! w:strange_whitespace
    endif
enddef

# OnlySelection {{{2

# This command deletes everything except the current visual selection (or any
# arbitrary range).
#
# Usage:
#
#     :'<,'> OnlySelection
#     :12,34 OnlySelection

command -bar -range=% OnlySelection myfuncs.OnlySelection(<line1>, <line2>)

# PluginGlobalVariables {{{2

command -bar -nargs=? PluginGlobalVariables myfuncs.PluginGlobalVariables(<q-args>)

# RemoveSwapFiles {{{2

command -bar RemoveSwapFiles RemoveSwapFiles()

def RemoveSwapFiles()
    for file: string in swapfilelist()
            # FIXME: Why is `&directory` prepended to each path?
            #
            #     /home/lgc/.local/share/vim/swap///home/lgc/.local/share/vim/swap//%path%to%file
            #     ^-------------------------------^
            #
            # Vim bug?
            ->map((_, fname: string) => fname->substitute('.*///', '/', ''))
            ->filter((_, fname: string): bool => fname->filereadable())
        delete(file)
    endfor
enddef

# RemoveTabs {{{2

# The purpose of this command is to replace all tab characters in the buffer
# with a nr of spaces which will occupy the same nr of cells.
#
# Before using it, set 'tabstop' (2, 4, 8) so that the text is aligned.
command -bar -range=% RemoveTabs myfuncs.RemoveTabs(<line1>, <line2>)

# Retab {{{2

# `:retab` substitutes all the tabs from a file to spaces.
# We don't want that.  We want a command which substitutes only leading tabs.
#
# Besides, `:retab` automatically chooses which  substitution to do based on the
# value  of `'expandtab'`.   That is,  if the  latter is  set, then  it replaces
# tabs into spaces.  Otherwise, it does the reverse substitution.
# We prefer to manually decide the type of substitution.
#
# So, we define `:Retab` which accepts a bang:
#
#     # tabs → spaces
#     :Retab
#
#     # spaces → tabs
#     :Retab!
#
# Mnemonic: we use spaces as the default way to indent, so it makes sense to
# to use a bang only for the less useful conversion: spaces → tabs

command -bar -bang -range=% Retab Retab(<line1>, <line2>, <bang>0)

def Retab(
        line1: number,
        line2: number,
        bang: bool
        )
    var view: dict<number> = winsaveview()
    var range: string = $':{line1},{line2}'
    var mods: string = 'silent keepjumps keeppatterns'
    if !bang
        RetabRep = (): string => repeat(' ', &tabstop * submatch(0)->strcharlen())
        execute $'{mods} {range}substitute/^\t\+/\=RetabRep()/e'
    else
        RetabRep = (): string => repeat("\<Tab>", submatch(0)->strcharlen() / &tabstop)
        execute $'{mods} {range}substitute/^\( \{{{&tabstop}}}\)\+/\=RetabRep()/e'
    endif
    winrestview(view)
enddef
var RetabRep: func

# ReverseEveryNLines {{{2

command -bar -range=% -nargs=1 ReverseEveryNLines ReverseEveryNLines(<args>, <line1>, <line2>)

def ReverseEveryNLines(
        n: number,
        line1: number,
        line2: number
        )
    var mods: string = 'silent keepjumps keeppatterns lockmarks'
    var range: string = $':{line1},{line2}'
    execute $'{mods} {range} global/^/execute $"move .-{{Offset({line1}, {n})}}"'
enddef

def Offset(line1: number, n: number): number
    var offset: number = (line('.') - line1 + 1) % n
    return offset != 0 ? offset : n
enddef

# SortLines {{{2

# Commented for the moment.  Keep it for educational purpose.

# We define the `:SortLines` command which moves lines containing `foo` or `bar` at
# the bottom.  Lines containing `foo` are put before the ones containing `bar`.

#     command -bar -range=% SortLines SortLines(<line1>, <line2>)
#
#     def SortLines(lnum1: number, lnum2: number)
#         getline(lnum1, lnum2)
#             ->sort(Compare_lines)
#             ->setline(lnum1)
#     enddef
#
#     def CompareLines(line1: string, line2: string): number
#         # The greater the score, the further to the right in the sorted list
#         var score1: number = line1 =~ 'bar' ? 2 : line1 =~ 'foo' ? 1 : 0
#         var score2: number = line2 =~ 'bar' ? 2 : line2 =~ 'foo' ? 1 : 0
#         return score1 - score2
#     enddef

# TrimWhitespace {{{2

command -bar -range=% TrimWhitespace TrimWhitespace(<line1>, <line2>)

def TrimWhitespace(line1: number, line2: number)
    var view: dict<number> = winsaveview()
    var mods: string = 'silent keepjumps keeppatterns lockmarks'
    var range: string = $':{line1},{line2}'
    execute $'{mods} {range} substitute/\s\+$//e'
    winrestview(view)
enddef

# Uniq {{{2

command -bar -range=% Uniq silent :<line1>,<line2> !awk '\!seen_lines[$0] { print $0; seen_lines[$0] = 1 }'
#                                                        ^
# `!` is replaced by the previous external command (see `:help :!`).
# But not when there is a backslash before the `!`, then that backslash is removed.
#
# ---
#
# `:sort u`  would  also  remove  duplicate  lines,  but  it  would  have  the
# side-effect  of sorting  the lines.   Our command  preserves their  original
# relative order.


# }}}1
# Autocmds {{{1
# Do *not* resource the vimrc automatically.  It creates too many issues.{{{
#
# First, you will need  to make sure that – out of  all the autocmds listening
# to `BufWritePost` – the one resourcing the vimrc is always the last one.
#
# Otherwise, if the pattern is `$MYVIMRC`,  it won't work, probably because when
# the vimrc is re-sourced, the augroup is cleared.
# Yes, the autocmd is re-installed, but it's  a new one, which won't take effect
# immediately for the current `BufWritePost` event.
# It will be executed only for the next `BufWritePost`.
# At that point, the issue will repeat.
#
# MRE:
#
#     $ cat /tmp/vim.vim
#         augroup TestSth
#             autocmd!
#             autocmd BufWritePost /tmp/vim.vim execute $'source {expand('<afile>:p')}'
#             autocmd BufWritePost * let g:d_ebug = get(g:, 'd_ebug', 0) + 1
#         augroup END
#
#     $ vim -Nu /tmp/vim.vim /tmp/vim.vim
#     :write
#     :echo d_ebug
#     ✘ E121˜
#
# The issue disappears if you change the order of the autocmds.
#
# ---
#
# Second, after some time (after visiting or writing many buffers), Vim might be
# slow whenever  you write the  vimrc.  As  a workaround, you  can *temporarily*
# disable the autocmd; but that's cumbersome to do every time.
#
# ---
#
# Finally,  you'll need  to write  a  bunch of  `has('vim_starting')` guards  in
# various places to avoid issues which are hard to understand.
#
# This shows that the  vimrc is not really meant to  be re-sourced; forget about
# it; it's not  worth it, especially now  that you can restart Vim  and not lose
# your session thanks to `vim-session`.
#}}}
# Same thing for `myfuncs.vim`.{{{
#
# For  example,  once  we had  an  issue  where  a  regular buffer  was  wrongly
# transformed into a qf buffer: https://github.com/vim/vim/issues/7352
#}}}

# Check tooling is installed {{{2

augroup CheckToolingIsInstalled
    autocmd!
    autocmd FileType html,css,js CheckToolingIsInstalled('js-beautify', 'formatprg')
    autocmd FileType lua CheckToolingIsInstalled('luacheck', 'makeprg')
augroup END

def CheckToolingIsInstalled(tool: string, option: string)
    # no need to give a warning if the tool is already installed
    if executable(tool)
            # nor if we already did give a warning
            || execute('messages') =~ tool
        return
    endif

    # no need to give a warning if we don't intend to use the tool
    if eval($'&l:{option}') !~ $'\<{tool}\>'
            && eval($'&g:{option}') !~ $'\<{tool}\>'
        return
    endif

    var message: list<string>
    if tool == 'js-beautify'
        message =<< trim eval END
            Installation:

                $ npm install --global js-beautify

            Documentation:
            https://github.com/beautify-web/js-beautify
        END
    elseif tool == 'luacheck'
        message =<< trim eval END
            Installation:

                $ sudo apt install luarocks
                $ sudo luarocks install luacheck

            Documentation:
            https://luacheck.readthedocs.io/en/stable/index.html
        END
    endif
    message = [
        $'{tool} is not installed, but you refer to it in your ''{option}'' option!',
        ''
    ] + message
    for line: string in message
        unsilent echowindow line
    endfor
enddef

# Command Window {{{2

# Form more ideas:
# http://vim.wikia.com/wiki/Enhanced_command_window

augroup MyCmdlineWindow
    autocmd!
    # Purpose:{{{
    #
    # By default, `Tab` is mapped to `C-x C-v` in the command-line window.
    # This shadows our custom `Tab` mapping which can expand a snippet.
    #
    # This  local mapping  is not  installed in  the search  command-line window
    # (`q/`, `q?`), which is why we use the pattern `:` instead of `*`.
    #
    # Note that  for some  reason, UltiSnips  fails to expand  a snippet  in the
    # search command-line window.
    #}}}
    autocmd CmdwinEnter : silent! iunmap <buffer> <Tab>

    autocmd CmdwinEnter * nnoremap <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<ScriptCmd>quit<CR>'
    autocmd CmdwinEnter * nnoremap <buffer><nowait> ZZ <CR>
augroup END

# Create Missing Directory {{{2

augroup MakeMissingDir
    autocmd!
    autocmd BufWritePre * MakeMissingDir(expand('<afile>:p'), expand('<abuf>')->str2nr())
augroup END

def MakeMissingDir(file: string, buf: number)
    # before creating  a directory,  make sure  that the  current buffer  is not
    # special (`:help special-buffers`)
    if !getbufvar(buf, '&buftype')->empty()
            # also, make sure it's not tied to a remote file (`ftp://...`)
            || file =~ '^\w\+:/'
        return
    endif

    var dir: string = file->fnamemodify(':h')
    # if the directory already exists, nothing needs to be done
    if dir->isdirectory()
        return
    endif

    try
        mkdir(dir, 'p')
    catch /^Vim\%((\a\+)\)\=:E739:/
        # If the directory is in a root directory, `mkdir()` will fail.
        # We need to run `$ sudo mkdir`.
        myfuncs.RunSudoShellCommand($'mkdir {dir}')
        # Write the file  as root, so that the next  `:update` (executed when we
        # press `C-s`) does not fail.
        execute $'write !sudo tee >/dev/null {shellescape(file, true)}'
        setbufvar(buf, '&modified', false)
    endtry
enddef

# Default Extension {{{2

# Temporarily commented, because I find it annoying now with `.vim`.
# Keep it, because it could still be useful for other extensions.

#     augroup DefaultExtension
#         autocmd!
#         autocmd BufNewFile * ++nested expand('<afile>:p')->DefaultExtension()
#     augroup END
#
#     def DefaultExtension(fname: string)
#         # If the buffer name ends with a dot, it's probably a mistake.
#         # We don't want to add a default extension.
#         # We  would  end  up  with  a  buffer whose  name  contains  a  sequence  of
#         # consecutive dots.
#         if fname[-1] == '.'
#             return
#         endif
#
#         # If the buffer is created inside `/tmp` and has no extension
#         if fname->fnamemodify(':p:h')[: 3] == '/tmp' && fname->fnamemodify(':e')->empty()
#             # ... make  sure it  will be  wiped when it's  hidden which  will happen
#             # after the next command
#             &l:bufhidden = 'wipe'
#
#             # edit a new buffer with the same name + the `.vim` extension
#             execute $'keepalt edit {fnameescape(fname)}.vim'
#
#             # If  the  previous  command  fails,  with or  without  error,  we  want
#             # `'bufhidden'` to be reset to its default value.
#             set bufhidden<
#         endif
#     enddef

# Delete Corrupted Undo Files {{{2

# Prevent `E823` from being given again and again for the same file.{{{
#
# After a crash,  an undo file might  get corrupted, causing `E823`  to be given
# when loading the matching file:
#
#     E823: Not an undo file: /home/lgc/.local/share/vim/undo/%path%to%file'
#                             ^------------------------------^
#                                     &undodir
#
# Being warned is useless; there is no `:undorecover` command which we could use
# to get back some info out of it (there is a patch in the todo list though).
# And being  warned every single time  we load the  buffer for the same  file is
# annoying.  Let's get rid of the corrupted undo file.
#}}}
augroup DeleteCorruptedUndoFile
    autocmd!
    autocmd BufReadPost * DeleteCorruptedUndoFile()
augroup END

def DeleteCorruptedUndoFile()
    if v:errmsg =~ '^E823:'
        var corrupted_undofile: string = v:errmsg
            ->matchstr('E823:[^:]*:\s*\zs.*')
        v:errmsg = ''
        delete(corrupted_undofile)
    endif
enddef

# Delete Noname Buffers {{{2

# We want to automatically delete buffers which are empty and don't have a name.

var noname_buffers: list<number>

augroup WipeNonameBuffers
    autocmd!
    # Do *not* try to wipe the noname buffer right away!{{{
    #
    # We tried in the past, but it conflicted with other plugins in subtle ways,
    # creating  hard-to-debug issues.   We also  tried to  delay until  the next
    # `BufEnter`, which fixed some issues, like this one:
    #
    #     set hidden
    #     autocmd BufHidden * execute $'bwipeout! {expand('<abuf>')->str2nr()}'
    #     new
    #     quit
    #     Error detected while processing BufHidden Autocommands for "*":˜
    #     E937: Attempt to delete a buffer that is in use: [NULL]˜
    #
    # but not all  issues can be fixed  like that.  In particular,  we still had
    # this issue:
    #
    #     $ vim +help +quit +'call feedkeys("\<Space>U")'
    #     Error detected while processing function window#unclose#restore:˜
    #     line   20:˜
    #     E16: Invalid range: 2wincmd w˜
    #
    # So now, instead, we just register the buffer number in a list, and we wipe
    # all buffers in that list on  the next `CursorHold`.  It's good enough.  We
    # don't need to wipe a noname buffer *immediately*.
    #}}}
    autocmd BufHidden * RegisterNonameForWiping()
    autocmd CursorHold * WipeNoname()
augroup END

def RegisterNonameForWiping()
    var buf: number = expand('<abuf>')->str2nr()
    if buflisted(buf) && bufname(buf)->empty()
        noname_buffers->add(buf)
    endif
enddef

def WipeNoname()
    for buf: number in noname_buffers
        if buflisted(buf) && bufname(buf)->empty()
            # we might have redisplayed the buffer in a window; don't wipe it then
            if win_findbuf(buf)->empty()
                execute $'silent! bwipeout! {buf}'
            endif
        else
            noname_buffers->filter((_, v: number): bool => v != buf)
        endif
    endfor
enddef

# Dummy Autocmds {{{2

# We need to always have at least one autocmd listening to `CursorMoved`.{{{
#
# Otherwise, Vim might detect the motion of the cursor too late.
#
# For an explanation of the issue, see:
# https://github.com/vim/vim/issues/2053#issuecomment-327004968
#
# Although, I don't think it really explains the issue...
#}}}
#   Same thing for `TextChanged`.{{{
#
# MRE:
#
#     # purpose: automatically surround a  url with angle
#     # brackets to format  it as a markdown  link,
#     # when we paste  it by pressing ""p
#     nnoremap "" <ScriptCmd>Func()<CR>"+
#     def Func()
#         autocmd TextChanged * ++once substitute/^\s*\zshttp.*/<&>/e
#     enddef
#     @+ = 'http://www.example.com'
#     # press: ""p
#     <http://www.example.com>˜
#     ✔
#     # press: u
#     #        ""p
#     http://www.example.com˜
#     ✘
#}}}
#   Why also `CursorMovedI`, `WinEnter` and `TextChangedI`?{{{
#
# The default matchparen plugin also installs autocmds listening to these events.
# If we disable  the plugin, I want  to be sure that there's  still at least
# one autocmd listening to each of them.
# Otherwise, we could encounter bugs which  are hard to understand, and that
# other people can't reproduce.
#}}}
{
    var events: list<string> =<< trim END
        CursorMoved
        CursorMovedI
        WinEnter
        TextChanged
        TextChangedI
    END
    for event: string in events
        # Why not using a guard to only install the autocmd if there's none?{{{
        #
        # So, sth like this:
        #
        #     if !exists($'#{event}')
        #     ...
        #     endif
        #
        # It wouldn't be reliable.
        # Indeed, we could have a temporary one-shot autocmd listening to the event.
        # In that case, the guard would prevent the installation of the autocmd running `"`.
        # Shortly after, the one-shot autocmd could be removed, and we would end
        # up with no autocmd listening to our event.
        #}}}
        augroup MyDummyAutocmds
            execute $'autocmd! {event} * #'
        augroup END
    endfor
}

# Fire *Leave events on startup {{{2

# Purpose:{{{
#
# When Vim starts up, none of these events seem to be fired:
#
#    - `BufLeave`
#    - `BufWinLeave`
#    - `WinLeave`
#
# This might give unexpected results when Vim has just finished its startup.
#
# MRE:
#
#     $ vim -Nu NONE \
#           --cmd 'autocmd BufWinEnter,WinEnter * setlocal statusline=active' \
#           --cmd 'autocmd BufWinLeave,WinLeave * setlocal statusline=NOT\ active' \
#           -O /tmp/file{1..2}
#
# The status line in the right window displays `active`; I would expect it to display `inactive`.
#}}}
# https://github.com/vim/vim/issues/5243
augroup FireLeaveEventsOnStartup
    autocmd!
    autocmd VimEnter * timer_start(0, (_) => FireLeaveEvents())
augroup END

def FireLeaveEvents()
    if match(v:argv, '\C^-[doO]$') >= 0
        var curwin: number = win_getid()
        windo eval 0 + 0
        win_gotoid(curwin)
    endif
enddef

# Include shell CWD in 'path' {{{2

augroup IncludeShellCWDInPath
    autocmd!
    # Rationale:{{{
    #
    # We want to be able to press `ZF` to  open a file path in a Vim split, when
    # the buffer has been populated with a shell command such as:
    #
    #     $ find -name '*.rs' | vipe
    #     $ find -name '*.rs' | vim -
    #}}}
    #   Wait.  Doesn't Vim look in the CWD by default?{{{
    #
    # Yes it does, regardless of the value of `'path'` (even if you empty it).
    # But we have an autocmd in `vim-cwd` which might change the CWD (to `~/.vim`).
    # So, to be sure `ZF` works all the time, we need to tell Vim – explicitly –
    # to look into the CWD of the parent shell.
    #}}}
    autocmd VimEnter * if $_ =~ '/vipe$' | set path+=$PWD | endif
    autocmd StdinReadPost * set path+=$PWD
augroup END

# Indent settings {{{2

augroup IndentSettings
    autocmd!
    # Vim test files are indented with 2 spaces (see their modelines)
    autocmd BufReadPost */vim/src/testdir/*.vim &l:shiftwidth = 2
augroup END

# No syntax in diff mode {{{2

augroup NoSyntaxInDiffMode
    autocmd!
    # Why do you clear the syntax in a diff'ed buffer?{{{
    #
    # When  you're  comparing  the  differences between  two  files,  you're
    # interested in the text which has changed.
    # You're not interested in the semantics of the code.
    #
    # IOW, the syntax  adds visual clutter, which makes it  hard to focus on
    # what is really important.
    #}}}
    autocmd OptionSet diff ToggleSyntax()
    # We need this when we start Vim in diff mode right from the shell.{{{
    #
    #     $ vimdiff file1 file2
    #
    # This is because the previous autocmd is not fired in that case.
    # Maybe because the option is set  before the autocmd is installed, or maybe
    # because `OptionSet` is not fired on startup.
    #}}}
    autocmd VimEnter * IfDiffSynClear()
augroup END

def ToggleSyntax()
    if v:option_new == '1'
        syntax clear
    else
        doautocmd Syntax
    endif
enddef

def IfDiffSynClear()
    if !&l:diff
        return
    endif
    for d: dict<any> in getwininfo()
        win_execute(d.winid, 'syntax clear')
    endfor
enddef

# Parse ANSI escape escape codes {{{2

# A buffer might have been generated by a shell command.
# If so, it might contain ANSI escape codes.
# Those are  not meant  to be displayed,  but interpreted as  some styles  to be
# applied (colors, underlines, ...).
# See: https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
# The simplest way to handle them is  to just `cat(1)` the regular Vim buffer in
# a new Vim terminal buffer.
augroup ParseAnsiEscapeCodes
    autocmd!

    # `$ trans word | vim -`
    autocmd StdinReadPost * ParseAnsiEscapeCodes()

    # `$ trans word | vipe`
    autocmd VimEnter * {
        if $_ =~ '/vipe$'
            ParseAnsiEscapeCodes()
        endif
    }

    # erase noise: "-stdin-" 123L, 456B
    autocmd StdinReadPost * echo ''
augroup END

# We save the filename  in a global variable in case we later  need it to send
# the file to a running Vim server (via `SendToServer()`).
g:ParseAnsiEscapeCodesFile = tempname()
def ParseAnsiEscapeCodes()
    if search('\e\[\d*m', 'cnW') == 0
            # ignore a man  page when Vim is  invoked as a man  pager from the
            # shell's CLI
            || v:argv->index('+Man!') >= 0
        return
    endif

    getline(1, '$')
        ->writefile(g:ParseAnsiEscapeCodesFile)
    # NOTE: The background is not highlighted with the `Terminal` HG.{{{
    #
    # Probably because  the latter  has not  been defined  yet.  That  said, I
    # prefer the current behavior (i.e. the background is not highlighted in a
    # different color compared to `Normal`).
    #}}}
    term_start($'cat {g:ParseAnsiEscapeCodesFile}', {curwin: true})
        # need to wait when we start  Vim from `less(1)` (by pressing our custom
        # `E` key binding which pipes `less(1)`'s buffer to Vim)
        ->term_wait()
enddef

# Parse `grep(1)`-like address {{{2

# Example:
#
#               copied from grep(1)'s output
#           v----------------------------------v
#     $ vim /path/to/some/file:123:456:some text
#                              ^-----^
#                              address
#
#     # should open: /path/to/some/file
#     # with cursor on lnum: 123
#     # with cursor on col: 456

augroup ParseGrepLikeAddress
    autocmd!
    # Warning: Do *not* listen to `BufReadCmd`.{{{
    #
    # It would create subtle issues, and make the code more complex.  Besides,
    # it's fundamentally wrong, because the  autocmd pattern is too broad (the
    # trailing `*`  can match any  extension).  Thus, you might  have multiple
    # autocmds  listening to  `BufReadCmd` which  compete to  handle the  same
    # file.  In that case, the first one which is installed wins.
    #}}}
    autocmd BufNewFile *:[1-9][0-9]\\\{0,\}{:*,$} ++nested ParseGrepLikeAddress()
augroup END

def ParseGrepLikeAddress()
    var afile: string = expand('<afile>:p')
    var lnum: number
    var col: number = 1
    var fname: string

    var with_column: bool = afile =~ ':\d\+:\d\+\%(:\|$\)'
    if with_column
        [lnum, col] = afile
            ->matchlist(':\(\d\+\):\(\d\+\)\%(:\|$\)')[1 : 2]
            ->map((_, n: string): number => n->str2nr())
        fname = afile
            ->substitute(':\d\+:\d\+\%(:.*\|$\)', '', '')
    else
        lnum = afile
            ->matchstr(':\zs\d\+\ze\%(:\|$\)')
            ->str2nr()
        fname = afile
            ->substitute(':\d\+\%(:.*\|$\)', '', '')
    endif

    if !fname->filereadable()
        return
    endif

    var buf: number = expand('<abuf>')->str2nr()
    execute $'keepalt edit! {fname->fnameescape()}'
    cursor(lnum, col)
    execute $'bwipeout! {buf}'
enddef

# Persistent clipboard {{{2

# Which issue is solved by this autocmd?{{{
#
# Start a terminal (not urxvt).
# Start Vim and copy some text in the clipboard (`""y...`).
# Quit Vim.
# Try to paste the clipboard in the terminal: it doesn't work.
#}}}
#   What's the cause of the issue?{{{
#
# A text copied in the clipboard is called a “selection”.
#
# When you yank some  text in the clipboard selection, Vim  becomes the owner of
# the latter.
#
# Later,  in the  terminal, when  you ask  for the  clipboard selection  to be
# pasted, the  terminal sends  a request  to the  X server,  and asks  for the
# clipboard selection from whoever currently owns  it.  The X server will then
# relay this request to the other X  client, here Vim, that owns the clipboard
# selection.
#
# Now, if you've  quit Vim, then no one owns  the clipboard selection anymore,
# and so the  request of the terminal  fails.  The same is true  for any other
# application, like  the web browser.  So,  if you've yanked some  text in the
# clipboard from Vim, then  quit the latter, you won't be able  to paste it in
# Firefox.
#
# This is explained at `:help x11-selection`.
#
#    > ... selections  are "owned" by  an application, and disappear  when that
#    > application (e.g., Vim) exits, thus losing the data ...
#}}}
#   How do you fix it?{{{
#
# Before quitting Vim, we write the clipboard into a file.  We watch that file
# via  a systemd  path unit.   Whenever the  file changes,  a systemd  service
# starts `xsel(1x)` so that it becomes the new owner of the clipboard.
#}}}
#   Does it affect all applications?{{{
#
# No,  for example,  zathura is  not affected.   I don't  know why.   Maybe it
# gives the  ownership of  its clipboard selection  to another  program before
# quitting...
#
# OTOH, the issue does affect LibreOffice.
#}}}

augroup MakeClipboardPersistAfterQuittingVim
    autocmd!
    autocmd VimLeave,VimSuspend * MakeClipboardPersistAfterQuittingVim()
augroup END

def MakeClipboardPersistAfterQuittingVim()
    if !executable('xsel')
            || strlen(@+) == 0
            # We don't want to Vim to take too much time to quit if the clipboard selection is big.{{{
            #
            # If you  find the  current limit  too low,  you might  increase it,
            # after doing some tests:
            #
            #     :let @+ = repeat('a', 999999)
            #     :10 Time call system('xsel --input --clipboard', @+)
            #}}}
            || strlen(@+) > 9'999
            # TODO: How to preserve `TMPDIR` when Vim is started by `sudoedit(8)`?
            # This doesn't work:
            #
            #     $ sudo visudo --file=/etc/sudoers.d/99-local
            #     :/^Defaults env_keep/s/"$/ TMPDIR"/
            #     :exit
            #
            # And yet, the variable is reportedly preserved:
            #
            #     $ sudo --login
            #     $ sudo --version
            #     ...
            #     Environment variables to preserve:
            #             TMPDIR
            #             ...
            || $TMPDIR == ''
        return
    endif

    # Do *not* start `xsel(1x)` from Vim!{{{
    #
    #     ✘
    #     system('xsel --input --clipboard', @+)
    #
    # First, it doesn't work in the GUI.
    #
    # Second,  it  causes kitty  to  hang  when we  press  `M-s`  to pipe  the
    # scrollback buffer to  `less(1)`, then `E` to load it  into a Vim buffer.
    # kitty waits for `xsel(1x)` to terminate.
    #
    # Similar issue if we lock a shell script:
    #
    #     # press Super+o to start ~/bin/drop-in/omni-GUI, which starts with:
    #     [[ "$FLOCKER" != "$0" ]] && exec env FLOCKER="$0" flock --exclusive --nonblock "$0" "$0" "$@" || :
    #
    #     # select "config_files"
    #     # choose a file for Vim to open
    #     # quit Vim
    #
    #     # press Super+o again
    #     # expected: the xterm window is open
    #     # actual: the xerm window is not open
    #
    # It can cause other subtle issues which are hard to debug:
    # https://unix.stackexchange.com/questions/523255/why-is-this-xclip-process-killed-when-i-quit-vim
    #
    # Don't bother; let a file watcher do the job.
    #}}}
    getreg('+', true, true)
        ->writefile($'{$TMPDIR}/vim/clipboard', 'bs')
enddef

# Quit if reading empty shell command {{{2

augroup QuitIfReadingEmptyShellCommand
    autocmd!
    autocmd StdinReadPost * {
        # the buffer is empty
        if (line('$') + 1)->line2byte() <= 2
                # Might be necessary when we want to pipe `less(1)` output to Vim.{{{
                #
                # If  `less(1)` output  contains ANSI  escape sequences,  and we
                # press `E` to  pipe it to Vim, one of  our autocmd replaces the
                # Vim  buffer with  a terminal  buffer so  that those  sequences
                # are  automatically parsed  correctly.  For  a short  period of
                # time,  the  buffer is  temporarily  empty.   For some  reason,
                # `term_wait()` doesn't help; not sure why.
                #}}}
                && &buftype != 'terminal'
            cquit
        endif
    }
augroup END

# Read special files (e.g. PDF or EPUB) {{{2

var convert2text_supported_extensions: list<string> = $'{$HOME}/.cache/convert2text/supported-extensions'
    ->readfile('', 1)
    ->get(0, '')
    ->split()

augroup ReadSpecialFile
    autocmd!
    execute 'autocmd BufReadCmd *.{lz4,'
        .. convert2text_supported_extensions->join(',')
        .. '} ReadSpecialFile()'

    # If we run  `$ grepc pat some.pdf`, `grep(1)` will actually  look for the
    # pattern in  pre-processed files under `~/.cache/convert2text/`.   And if
    # we use the output to set Vim's  quickfix list, we will open those files;
    # when  that happens,  we  don't want  to mess  up  the pre-processing  by
    # editing the files.
    autocmd BufReadPost ~/.cache/convert2text/*.txt ReadSpecialFileSetOptions()

    # Those files should never be written.{{{
    #
    # And     we    can't     set    `'buftype'`     to    `nowrite`.      See
    # `ReadSpecialFileSetOptions()`  for  the  reason why.   Instead,  when  a
    # command tries to write the buffer,  we actually reload it from the file,
    # and reset options (for `'readonly'`).
    #}}}
    autocmd BufWriteCmd ~/.cache/convert2text/*.txt edit! | ReadSpecialFileSetOptions()
    # `++nested`: for `:edit!` to trigger `BufReadPost` and re-process the file
    execute 'autocmd BufWriteCmd *.{lz4,'
        .. convert2text_supported_extensions->join(',')
        .. '} ++nested edit! | ReadSpecialFileSetOptions()'
augroup END

def ReadSpecialFile()
    var fname_for_bang: string = expand('<afile>:p')
        # Warning: Do *not* use `:S` instead.{{{
        #
        # In the end,  `fname_for_bang` will be written in  a command executed
        # by `:!`. And its value might contain characters which are special on
        # Vim's command-line, like `%` or `#`. We want those to be escaped.
        #}}}
        ->shellescape(true)
    var ext: string = expand('<afile>:e')

    var pre_processing_cmd: string = ext == 'lz4'
        ? $'lz4 --decompress --stdout {fname_for_bang}'
        : $'convert2text {fname_for_bang}'
    var cmd: string = pre_processing_cmd->matchstr('\S\+')

    if !cmd->executable()
        echohl ErrorMsg
        echomsg $'cannot find executable "{cmd}"; need it to pre-process .{ext} file'
        echohl NONE
        return
    endif

    # Here, we do  *not* want to escape characters which  are special on Vim's
    # command-line.
    var fname_for_system: string = expand('<afile>:p:S')
    silent if cmd == 'convert2text'
            && !system($'convert2text --print-cached-filepath {fname_for_system}')
            ->trim("\n")
            ->filereadable()
        unsilent echo 'need to pre-process the file; wait a moment'
    endif

    &l:modifiable = true
    &l:readonly = false

    # preserve cursor position after `:edit`
    var pos: list<number> = getcurpos()
    # Alternative:{{{
    #
    #     pre_processing_cmd
    #         ->systemlist()
    #         ->setline(1)
    #
    # But it's a *little* bit slower.
    #}}}
    execute $'silent lockmarks :0 read !{pre_processing_cmd}'
    # Don't try to delete the first line.{{{
    #
    # You could, if  you dropped the previous `:0` before  `:read`.  But then,
    # your cursor would move one line up after quitting Vim and re-opening the
    # file:
    #
    #     :quitall!
    #     $ vim /path/to/file
    #
    # Deleting the last line doesn't cause  such an issue; it can't change the
    # address of any subsequent line (there is none).
    #}}}
    expand('<abuf>')
        ->str2nr()
        ->deletebufline('$')
    setpos('.', pos)

    ReadSpecialFileSetOptions()
enddef

def ReadSpecialFileSetOptions()
    # Warning: Do *not* set `'buftype'` to `nofile`.{{{
    #
    # It would prevent `:mksession` from saving the buffer's window.
    #}}}
    # Warning: Do *not* set `'buftype'` to `nowrite`.{{{
    #
    # It would unconditionally open a new split window whenever we press Enter
    # in the  quickfix window, which is  annoying when we traverse  a quickfix
    # list with entries from a PDF.
    #}}}
    &l:modifiable = false
    &l:readonly = true
    &l:swapfile = false
    # We once had a huge undo file in `~/.local/share/vim/undo/` for a PDF.
    # Make sure that doesn't happen again.
    &l:undofile = false
enddef

# Problem: The default `zip` plugin interferes with our autocmd.{{{
#
# For example, if you open an epub:
#
#     $ vim /path/to/some.epub
#
# You'll read something like this at the top of the buffer:
#
#     " zip.vim version v33
#     " Browsing zipfile /path/to/some.epub
#     " Select a file with cursor and press ENTER
#
# And if you press Enter on any line, Vim will try to open a non-existing file
# (whose name  is based on  whatever is  written on the  line) in a  new split
# window, causing the screen not to be completely drawn (need to `:redraw!`).
#
# Also, the filetype will be set to `zip`, and the syntax to `tar`.
#
# Since our autocmd converts the file into plain text, all of this is wrong.
#}}}
# Solution: Make it ignore some file extensions.
# Alternative: Disable the `zip` plugin entirely:{{{
#
#     g:loaded_zipPlugin = true
#     g:loaded_zip = true
#}}}
if $'{$VIMRUNTIME}/plugin/zipPlugin.vim'->filereadable()
    var lines: list<string> = $'{$VIMRUNTIME}/plugin/zipPlugin.vim'
        ->readfile()
    var lnum: number = lines->match('^\s*let\s*g:zipPlugin_ext\s*=')
    if lnum != -1
        g:zipPlugin_ext = lines[lnum]
            ->matchstr('=\s*[''"]\zs.*\ze[''"]$')
            ->split(',')
            ->filter((_, glob: string): bool => convert2text_supported_extensions->index(glob[2 :]) == -1)
            ->join(',')
    endif
endif

# Regenerate helptags {{{2

augroup RegenerateHelptags
    autocmd!
    autocmd BufWritePost ~/.vim/pack/*/doc/*.txt execute $'helptags {expand('<afile>:p:h')}'
augroup END

# Spell files {{{2

# When spell checking is enabled, and we mark  a word as good or bad, we make an
# addition into `~/.vim/spell/fr.utf-8.`.
# But,  for  Vim to  take  this  addition into  account,  it  has to  perform  a
# successful check on the corresponding binary file `fr.utf-8.add.spl`.
#
# Versioning  those binary  files with  git  could cause  pb (conflicts  between
# different versions).

# When  we switch  to  another  machine, we  should  regenerates  them with  the
# `:mkspell!` command.
# The bang asks to overwrite an old binary if there's already one.
# So  we do  it  here, for  every  spell binary  file, but  only  if the  binary
# (.add.spl) is older than the original addition file (.add).

augroup MyMkspell
    autocmd!
    autocmd VimEnter * Mkspell()
augroup END

def Mkspell()
    var spelldir: string = $'{$HOME}/.vim/spell'
    if !isdirectory(spelldir)
        return
    endif
    # There can be several spell files (one per language), in which we made additions.
    # http://vi.stackexchange.com/a/5052/6960
    for file: string in spelldir
            ->readdir((n: string): bool => n =~ '\.add$', {sort: 'none'})
            ->map((_, v: string) => $'{$HOME}/.vim/spell/{v}')
        if filereadable(file)
                && !filereadable($'{file}.spl')
                || (getftime(file) > getftime($'{file}.spl'))
            execute $'mkspell! {file->fnameescape()}'
        endif
    endfor
enddef

# Swap file handling {{{2

# What does this autocmd do?{{{
#
# It answers automatically to the question asked when a swap file is found.
# If the swap file is older than the file, it's removed because useless, and the
# file is editd as if nothing happened.
#
# If the swap  file is newer, the file  is opened in readonly mode,  so that you
# can see its contents, but not change it (without being warned).
#}}}
# Which pitfall does it fix?{{{
#
#     $ vim /tmp/file
#     $ vim (a 2nd instance)
#     :try | edit /tmp/file | catch | endtry
#
# If the  file is  already loaded in  another instance, it  will give  the error
# `E325` (“Attention: Found a swap file ...”).
#
# But the  error won't be  catched because Vim prompts  us with a  question to
# know  what we  want to  do (edit,  quit, ...).  Worse, the  question is  not
# visible.
#
# This can happen when a plugin tries to edit a file with a `try` conditional,
# and Vim finds out that a swap file exists.
#}}}
# Why don't you use `set shortmess+=A`?{{{
#
# `set shortmess+=A` would completely bypass  the question, and the existence of
# a swap file would never be brought to our attention.
#
# In contrast, this  autocmd will still warn  us whenever a swap  file is found,
# and write the  warning in the messages, so  that we can review it  later if we
# need to debug some unexpected behavior from Vim.
#
# Besides, it won't let us edit a file for which a newer swap file exists.
# There could be valuable information in there.
#}}}

# A swap file has been found, and the file has been loaded in readonly mode!  What should I do?{{{
#
# If you only need to read the file, nothing.  Just read it.
#
# If you  need to edit the  file, you have  an issue.  Indeed, if  the autocmd
# hasn't removed the  swap file, it means  the latter is more  recent than the
# file (or has the same timestamp).
#
# So, it could contain valuable information  that you need to recover *before*
# doing any further change (because  this valuable information might radically
# alter the change you intend to perform).
#}}}
# How do I recover the contents of a swap file?{{{
#
#     # recover swap file
#     $ vim -r file
#
#     # save the result in another file
#     :write file.recovered
#
#     # load the original (unrecovered) file in readonly mode
#     # (this works thanks to our autocmd which should answer the question)
#     :edit!
#
#     # show the differences between the original file and its recovered version
#     :diffsplit file.recovered
#
# We have encapsulated this procedure in a navi snippet.
#
# If the recovered file looks good, you still have to run:
#
#     $ mv file.recovered file
#
# See `:help 11.1` for more info.
#}}}

augroup SwapfileHandling
    autocmd!
    autocmd SwapExists * expand('<afile>:p')->HandleSwapfile()
augroup END

def HandleSwapfile(fname: string)
    # If the swap file is older than the file itself, just get rid of it.
    if getftime(v:swapname) < getftime(fname)
        Warn($'Old swap file detected, and deleted:  {fname}')
        delete(v:swapname)
        v:swapchoice = 'e'
    else
        Warn($'Swap file detected, opening read-only:  {fname}')
        v:swapchoice = 'o'
    endif
enddef

def Warn(msg: string)
    echohl WarningMsg
    # It seems that when `SwapExists` is fired, Vim executes `:echomsg` silently.
    unsilent echomsg msg
    echohl NONE
enddef

# Trailing Whitespace {{{2

# Trailing whitespace in red but not if the filetype is blacklisted:
var NO_TRAILING_WHITESPACE_FT: list<string> =<< trim END

    git
    help
    info
    qf
    text
END

augroup TrailingWhitespace
    autocmd!
    autocmd VimEnter,BufWinEnter,InsertLeave * TrailingWhitespace(true)
    # We need to  delay because `TrailingWhitespace()` inspects  the filetype of
    # the displayed buffer.  But if a new window is created to display a buffer,
    # the latter is not displayed on  `WinEnter` (it will be shortly after).  As
    # a result, the  filetype is not necessarily correct, which  creates a bunch
    # of corner cases where a match is wrongly installed.
    autocmd WinEnter * timer_start(0, (_) => TrailingWhitespace(true))
    autocmd WinLeave,InsertEnter * TrailingWhitespace()
augroup END

def TrailingWhitespace(create_match = false)
    if exists('g:expanding_snippet')
        return
    endif

    if exists('w:my_trailing_whitespace')
            && (!create_match || &buftype != '')
        # `silent!` because the match might not exist anymore.
        # For example, a plugin could have executed `clearmatches()`.
        silent! matchdelete(w:my_trailing_whitespace)
        unlet! w:my_trailing_whitespace

    elseif create_match
            && !exists('w:my_trailing_whitespace')
            && NO_TRAILING_WHITESPACE_FT->index(&filetype) == -1
        w:my_trailing_whitespace = matchadd('Error', '\s\+$', 0)
    endif
enddef
# }}}1
# To Do {{{1

#     :* substitute/^\%V#\s\=\zs\d\+\ze\s*-/\=submatch(0) - 1/c
#
# 1 - Implement the concept of “narrowing region”.
#
# A mapping, or command which would copy a range of lines in a temporary buffer.
# We could edit this temp buffer, and after writing it, the original selection
# would be replaced by it.  There's a plugin for that:
#
# https://github.com/chrisbra/NrrwRgn
#
# ... but the source code is too long (1500 sloc).
# Take inspiration from it.
#
# 2 - Implement ]n, ]s, ]u, ]x, ]y from unimpaired.vim
#
# 3 -
#
# https://github.com/hunspell/mythes
# https://hunspell.github.io/
# http://icon.shef.ac.uk/moby/mthes.html
#
# Lire le code de:
#
# https://github.com/beloglazov/vim-online-thesaurus/
#
# Ajoute ça dans le vimrc:
#
#     plug 'beloglazov/vim-online-thesaurus'
#     let g:online_thesaurus_map_keys = 0
#
# Très court (144 sloc).
# Comme le plugin est court, on pourrait peut-être l'adapter pour le support
# du français.
# Chercher un site équivalent à thesaurus.com pour le français.
# Ou chercher une bdd de synonymes, et écrire un algo qui l'analyse:
#
# http://www.dicollecte.org/download.php?prj=fr
#
# On pourrait aussi s'inspirer de la méthode du plugin pour ouvrir un split de
# taille dynamique, adapté à la taille des données à afficher.
#
# Jeter un oeil aux liens suivants :
#
# https://hyperdic.net/en/doc/antonyms
# (trouvé en cherchant “where can i download antonym file” page 3)
# https://github.com/emugel/vim-thesaurus-files
#
# character-wise visual mode word lookup
# https://github.com/beloglazov/vim-online-thesaurus/pull/31
#
# Créer une méthode mucomplete qui s'en sert.
#
# 4 -
#
# Extract big chunks of code from `myfuncs.vim` into separate plugins.
#
# 5 -
#
# Read and integrate `:help slow-start` in our notes.
#
# Edit: Could we remove `!` from `'viminfo'`?   If so, maybe it would make Vim
# start faster; it would not have to load a possibly big dictionary saved in a
# global variable.
#
# 6 -
#
# Integrate `~/Wiki/diff.md` into `~/Wiki/vim/vim.md`.
# Or into `~/Wiki/linux/Linux.md`.
# Yeah... maybe everything which is related  to diff or vimdiff, put it inside
# `Linux.md`.
#
# 7 -
#
# In a temporary directory, execute these shell commands:
#
#     touch file{1..3}; mkdir -p foo/{bar,baz}/{qux,norf}
#     tree -a | vipe
#
# Look at  the diagram.   Implement a  mapping / command  which would  expand an
# abbreviation into this kind of diagram.
# For  the abbreviation,  we  could  take inspiration  from  the shell  commands
# themselves.  Or sth else?
#
# A simple way of doing this would be to call just the `tree` command:
#
#     :new
#     :!mkdir /tmp/test
#     :cd /tmp/test
#     :read !touch file{1..3}; mkdir -p foo/{bar,baz/qux}/{norf,abc}; tree -a
#
#     during the shell expansion `bar` and `baz/qux` are appended to `foo`
#     and `norf` and `abc` are appended to `foo/bar` and `foo/baz/qux`
#     so we end up with 4 (2 * 2) leaf directories + 4 intermediate directories
#     (foo, bar, baz, qux)
#
# But we would have to create a temporary directory, and temporarily `cd` to it
# to avoid polluting the current working directory.
# Besides, we would have to protect all kind of special characters which could
# be present in the text we want to insert in the diagram.
#
# However, mkdir seems limited to produce a complex hierarchy.
# A better way would be to look at the syntax used by emmet to expand html
# tags.  Our mapping/command would parse a similar command to produce
# a hierarchy of items of an arbitrary complexity.
#
# Also, have a look at the diagram at `:help syntax-loading`.  Very interesting.
# Without this diagram, the explanations would be much more verbose, and less
# readable.  Implement a visual mapping, which would automatically draw the
# right diagram in front of the lines inside the selection (drawing `+`, `-`, `|`).
#
# Also, install mappings to draw vertical diagrams instead of horizontal ones.
# Have a look at our notes about the `try` conditional for an example where it
# would be useful.
#
# Try this:
#
#     $ sudo apt install libgraph-easy-perl
#
# Write this in a file:
#
#     digraph {
#         start -> adsuck;
#         adsuck -> block;
#         block -> noop[label="yes"];
#         block -> unbound[label="no"];
#         noop -> serve_noop[label="yes"];
#         noop -> serve_empty[label="no"];
#     }
#
# Visually select it, and execute:
#
#     :'<,'> !graph-easy --as ascii
#                                   ^
#                                   don't add `%`
#                                   it would work, but if you have several digraph codes
#                                   in the current file, they will all be expanded, even
#                                   if you only select one in particular
#
# Interesting links:
# https://vi.stackexchange.com/a/541/13370
# http://melp.nl/2013/08/flow-charts-in-code-enter-graphviz-and-the-dot-language/
# https://github.com/wannesm/wmgraphviz.vim
# `man graph-easy`
#
# Edit: This is really useful with  vim-movesel, and vim-draw.  You create the
# skeleton of  the diagram with graph-easy,  then tweak it with  vim-movesel +
# vim-draw.
#
# Also, remember we've created the  `:BoxPrettify` command.  Useful to convert
# a raw ASCII diagram into a more polished one.
#
# Edit: The `--fromfile` option of `tree(1)` could be very useful.
#
# 8 -
#
# Look  for mappings  which would  benefit from  being made  dot/semicolon/comma
# repeatable.
#
# 9 -
#
# Document the fact that the tmux buffers are especially useful when you work in
# a Vim which wasn't compiled with the clipboard support (no `+` register).
#
# Think docker ultisnips:
#
# https://github.com/SirVer/ultisnips/blob/master/CONTRIBUTING.md#running-using-docker
# https://github.com/sirver/ultisnips/blob/master/CONTRIBUTING.md#reproducing-bugs
#
# 10 -
#
# Protect all temporary change of option with `try|catch|endtry`.
# Look for the pattern:
#
#     _save\|save_\|old_\|_old
#
# Do it in vimrc, myfuncs, plugins.
#
# For the replacement, use this snippet:
#
#     preparations (like saving options)
#     try
#         # do sth which can fail
#
#     # optional
#     catch /some error/
#         lg.Catch()
#         return
#
#     finally
#         # mandatory conclusion (like restoring options)
#     endtry
#
# 11 -
#
# Create a mapping to populate command-line with `:ltag /`, then open the
# location window.  Ex:
nnoremap <expr> <C-G>t Ltag()
def Ltag(): string
    augroup MyLtag
        autocmd!
        autocmd CmdlineLeave : execute(['autocmd! MyLtag', 'augroup! MyLtag'], 'silent!')
    augroup END
    return $':ltag / | lwindow | wincmd p{"\<C-B>" .. repeat("\<Right>", 6)}'
enddef
# We need to execute `:lwindow` manually, because `QuickFixCmdPost` is not fired.
# Vim bug: https://github.com/vim/vim/pull/3001
#
# Edit: It should probably be implemented as a cycle in `vim-cmdline`.
#
# Also: Play with `:tjump / C-d`.
#
# If you have a  stack of horizontal splits, and the current  window is in the
# middle, the  window below might  be wrongly maximized which  is distracting.
# `:wincmd p` prevents that.  The alternative is:
#
#     doautocmd <nomodeline> QuickFixCmdPost lwindow
#
# No need  to guard `:wincmd p`.  If  `:ltag` gives an error  because it can't
# find any tag, Vim bails out immediately  and doesn't execute the rest of the
# command (which includes `:lwindow`).
#
# 12 -
#
# Read `:help cscope` (useful to list tags in qfl?)
# https://www.reddit.com/r/vim/comments/6p6uch/how_to_refactor_by_tags/dkn30bd/
#
# 13 -
#
# Use `:[c|l]bottom` in your jobs plugins (if they populate a qfl asynchronously)
#
# 14 -
#
# Re-implement these mappings to open the file you're editing on github.
# It could be handy when you want to see a commit you've just pushed.
#
#     nnoremap <Space>og V<ScriptCmd>OpenCurrentFileInGithub()<CR>
#     xnoremap <Space>og <C-\><C-N><ScriptCmd>OpenCurrentFileInGithub()<CR>
#
#     def OpenCurrentFileInGithub()
#         var file_dir: string = expand('%:h:S')
#         silent var git_root: string = system(
#             $'cd {file_dir}; git rev-parse --show-toplevel | tr --delete "\n"'
#             )
#         var file_path: string = expand('%:p')->substitute($'{git_root}/', '', '')
#         silent var branch: string = system('git symbolic-ref --short -q HEAD | tr --delete "\n"')
#         silent var git_remote: string = system(
#             $'cd {file_dir}; git remote get-url origin'
#             )
#         var repo_path: string = git_remote->matchstr(':github\.com/\zs.*\ze\.')
#         var url: string = $'https://github.com/{repo_path}/blob/{branch}/{file_path}'
#         var first_line: number = getpos("'<")[1]
#         url ..= $'#L{first_line}'
#         var last_line: number = getpos("'>")[1]
#         if last_line != first_line
#             url ..= $'-L{last_line}'
#         endif
#         silent system($'xdg-open {url}')
#     enddef
#
# Source:
# https://www.reddit.com/r/vim/comments/9r3rcd/open_current_file_in_github/
#
# Edit: `:Gbrowse` does something similar.
#
# 15 -
#
# Refactor all our functions which populate the qfl to offload work to a single
# function in `vim-qf`?
#
#     set\%(qf\|loc\)list
#
# 16 -
#
# Look for  functions containing  the keyword  `maybe` or  `later` (or  look for
# `aug\%[roup]!`).
# These functions probably execute code which must be delayed.
# Make sure they are not called by yet another function:
#
#     def Func()
#       ...
#       Func_later()
#       ...
#     enddef
#
# There is no need to:
#
#     def Func(later)
#       ...
#       if later
#           Func(false)
#       endif
#       ...
#     enddef
#
# 17 -
#
# https://github.com/chrisbra/vim_faq
# We've  stopped  reading  at  `faq-4.2`,  because we  need  time  to  integrate
# `:tselect` in our workflow.
# Indeed there are many similar commands:
#
#    - `g]`
#    - `:stselect`
#    - `:tselect`
#    - `:ptselect`
#
#    - `g C-]`
#    - `:tjump`
#    - `:stjump`
#    - `:ptjump`
#
# 18 -
#
# No need  to check  `if &buftype  == 'quickfix'`  before applying  conceal, try
# conditional is enough.  Sure?
#
#     if\s\+&buftype\s\+==\s\+'quickfix'
#
# 19 -
#
# https://github.com/justinmk/vim-dirvish/issues/62
# https://github.com/bounceme/remote-viewer/
#
# Alternative:
# fuse/sshfs provides an abstraction at the filesystem layer (as opposed to some
# other “middleware”),  so that  any dumb local  navigator (like  dirvish) works
# without adding special-case support for scp, ftp, webdav, ..., netrw does.
#
#
# See also “Editing Remote Files with SSHFS”:
# https://www.youtube.com/watch?v=0fAygjWHpdM
#
# 20 -
#
# Create mapping to send current line to terminal, and execute it
# Use `g>` for the LHS?
#
#     g> + text object
#     g> on visual selection
#     g>> for line
#
# 21 -
#
# Finish reviewing vim-math
# What insight can we gain from it?
#
# Also, look at this:
#
# https://github.com/sk1418/howmuch
#
# Is there any functionality we could steal?
#
# 22 -
#
# Finish reviewing `~/Dropbox/vim_plugins/pair_complete.vim`.
#
# Edit: I lost the file.  Anyway, it was stolen from:
# https://github.com/dhruvasagar/vim-pairify
#
# 23 -
#
# We use `cml`, `commentstring`, in vimrc, myfuncs and in some of our plugins:
#
#    - iabbrev
#    - pair-complete
#    - titlecase
#
# It's  reliable for  programming languages  where  the cml  must be  repeated
# identically on  every line of  a multiline  comment.  What about  the others
# (e.g.:  `C`)?
#
# Edit: We should distinguish  2 problems. (un)commenting a  line vs detecting
# whether a  line is commented.  We  solved the 1st problem  in `vim-comment`.
# For the 2nd one, try this expression:
#
#     synID('.', col('.'), true)->synIDattr('name') != 'comment'
#
# 24 -
#
# Check whether some Ex commands would be better suited as mappings.
#
# And check whether some mappings would be better suited as Ex commands.
# Tip: if you keep forgetting the LHS of a mapping, turn it into an Ex command.
#
# 25 -
#
# Install autocmd listening to `BufReadPost */after/ftplugin/*.vim`
# which would install a buffer-local autocmd listening to `BufWritePost`
# which would give us a warning when we forget to undo a
# mapping/abbreviation/command/autocmd/variable
#
# or when we undo a non-existing ...
#
# 26 -
#
# Normalize underscore/hyphen in plug mappings, and function names in shell init
# files.
#
# 27 -
#
# Should we add `:noautocmd` every time we use `:wincmd`?
#
#     wincmd p\|call win_gotoid
#
# Same question for `:[cl]open`, `:[cl]window`?
# Why this 2nd question?
# `noautocmd`  was useful  in  `vim-interactive-lists` to  prevent the  original
# window from being  minimized when it's a middle horizontal  viewport (2nd of 3
# for example).
# The issue, if there's one, might be with `:l[open|window]` only.
#
# Edit: Whenever you need to *temporarily* change the focus to another window,
# you should try to use `win_execute()`.
#
# Changing the focused window can  lead to hard-to-debug issues, especially from
# an autocmd; `win_execute()` does not trigger autocmds when changing the focus.
# Also, it  preserves the previous window (`winnr('#')` and  `wincmd p` have the
# same result).
#
# 28 -
#
# Check that whenever we use `wincmd p` we get to the right window.
# Maybe we should use this instead:
#
#     var id: number = win_getid()
#     ...
#     win_gotoid(id)
#
# Edit: We definitely should *not* be using `wincmd p`.
# It could give `E366` if you've just created a popup window.
#
#     set previewpopup=height:11,width:59
#     pedit /tmp/file
#     wincmd p
#     E366: Not allowed to enter a popup window˜
#
# The issue is that `wincmd p` seems too unpredictable...
#
# 29 -
#
# Read:
# https://dev.to/idanarye/omnipytent-5g5l
# https://www.reddit.com/r/vim/comments/7kwlxc/omnipytent_plugin_explained/
# https://github.com/idanarye/vim-omnipytent
#
# 30 -
#
# Move every  function (like  `comment.Object()`) called from  several scripts
# inside `lg-lib`.
#
# Also, make sure they are self-contained.
# They must not call functions from one of our other plugins.
# If they do, move the latter inside `lg-lib` too.
#
# 31 -
#
# When you create a  loclist, replace the old one if  its title is `breakdown`
# or `fix_me & to_do`.   Also, maybe  create a  mapping to  show the  stack of
# location lists, and another to remove the current one.
#
# Also, if  you execute  `:WTF` several times  consecutively, `vim-stacktrace`
# keeps recreating and adding the same  qfl.  It shouldn't.  It should replace
# the old  one, or better leave  it alone.  To  do so, it should  remember the
# last qfl it produced, or the  last `:messages` it parsed, or any information
# sufficient to know that there's no need to recreate a qfl.
#
# 32 -
#
# Create a submode to insert numbers more easily.
#
# Ex:
#
#     enter “easy-number” submode
#     v---v
#     C-g n u  →  1
#           i  →  2
#           o  →  3
#           j  →  4
#           k  →  5
#           l  →  6
#           ,  →  7
#           ;  →  8
#           :  →  9
#           !  →  0
#
# Edit: Maybe a submode is not the right concept, because of the timeout.
# Maybe you should take inspiration from `vim-capslock`.
# Create a mapping, which would toggle temporary mappings.
#
#     inoremap <C-G>n <ScriptCmd>EasyNumber()<CR>
#
#     def EasyNumber(): string
#         if !maparg('!', 'i')->empty()
#             for key: string in ['!', 'u', 'i', 'o', 'j', 'k', 'l', ',', ';', ':']
#                 execute $'iunmap <buffer> {key}'
#             endfor
#         else
#             var i: number = 0
#             for key: string in ['!', 'u', 'i', 'o', 'j', 'k', 'l', ',', ';', ':']
#                 execute $'inoremap <buffer> {key} {i}'
#                 ++i
#             endfor
#             autocmd InsertLeave <buffer> ++once EasyNumber()
#         endif
#     enddef
#
# 33 -
#
# Read:
#
#     :help popup.txt
#     :help sign.txt
#     :help textprop.txt
#
#     :help channel.txt
#
#     :help tagsrch.txt
#
#     :help syntax.txt
#                      only 2400 lines once you remove part 4, and part 5: `:help syn-file-remarks`
#                      you're not supposed to read part 5 entirely anyway, only the tags
#                      relevant to the types of files you use frequently;
#                      to get a list:  :help ft-*-syn C-d
#
#     :help recover.txt
#     :help diff.txt
#     :help tips.txt
#
#     :help pattern.txt
#     :help indent.txt
#
#     :help terminal.txt
#     :help vim9-script
#
# Note that LSP is not a replacement for tags:
# https://www.reddit.com/r/vim/comments/fj9tsz/do_lsps_make_tag_generating_tools_obsolete/fkmna6k/
# https://www.reddit.com/r/vim/comments/fj9tsz/do_lsps_make_tag_generating_tools_obsolete/fkmvji3/
#
# 34 -
#
# In `~/Wiki/vim/funcref.md`, look for the pattern `funcref(`.
# There are 2 codes side-by-side.
# They are separated with `┊` characters.
# If you press `+sip` on the code, only the one on the left is sourced.
#
# This is neat.
# Try to develop this mechanism.
# For example, we could have a mapping which toggles which part is sourced,
# the one on the left or the one on the right.
#
# Also, when we  source the code on the  right, in a line ending with  `┊ "`, we
# could make `vim-source` replace the double quote  with the code on the left of
# `┊`. This would allow us to use `"` instead of repeating a whole command.
#
#
# 35 -
#
# Document `:spellinfo`, and `:help spellfile-cleanup`.
# Also, try to fix this item in the user manual:
#
#    > There should be something about spell checking in the user manual.
#
# 36 -
#
# Every time we  populate a qfl from  a script, we should save  the command we
# used with  the 'context'  qf property.  We  could use it  to refresh  a qfl,
# using a  custom mapping  which would  inspect the  value of  'context'.  The
# mapping would  re-execute the command and  replace the old qfl  with the new
# one.
#
# 37 -
#
# `gf`, `^wf`, and `^wgf` should be able to parse a column number.
#
# See here for inspiration:
# https://github.com/wsdjeg/vim-fetch
# https://github.com/kana/vim-gf-user/blob/master/doc/gf-user.txt
#
# Also, they should be able to parse a reference link in a markdown buffer:
#
#     [description][123]
#     ...
#     [123]: link
#
# Edit: What about  the line number?   Note that `:help gF`,  `:help ^wF`, and
# `:help ^wgF` can already process the latter.
#
# 38 -
#
# Finish implementing `!t` (timer info)
#
# Add syntax highlighting, additional info, mappings, ...
# also, create a mapping to interactively (un)pause/stop a timer.
#
# Also, do the same for matches (`getmatches()` + `matcharg()`).
# Use `! C-m` for the LHS of the mapping?
#          ^
#          getmatches
#
# Or, supercharge `!s`, so that when there's no syntax item under the cursor, it
# falls back on the matches.
# Also, do the same for these functions:
#
#     getbufinfo()              get a list with buffer information
#     gettabinfo()              get a list with tab page information
#     getwininfo()              get a list with window information
#     ch_info()                 get channel information
#     job_info()                get information about a job
#
# BTW: The 'lnum' and 'windows' key  in the output of getbufinfo(...)[...] are
# very interesting.
#
# Edit: Maybe we should use `!i` as a prefix (i for **i**nfo).
#
#  - `!it` = timer
#  - `!ic` = channel
#  - ...
#
# 39 -
#
# Check which mappings could be supercharged using `v:count`:
#
#     nnoremap <F3> <ScriptCmd>Func(v:count)<CR>
#     def Func(cnt: number)
#         echo cnt ? 'hello' : 'world'
#     enddef
#
# And check which mappings could benefit from being passed a count.
# see what we did with `!w` (`:WTF`), and `spc t` (`:tabnew`).
# Basically,  any  mapping which  calls  an  Ex  command accepting  a  numerical
# argument, or a bang, could be passed the latter via `v:count`.
#
# 40 -
#
# Extract the code dedicated to templates from `vim-unix`.
# Make it able to evaluate vimscript (i.e. dynamic templates).
#
# See here for inspiration:
# https://github.com/aperezdc/vim-template
#
# 41 -
#
# Search for `[ SPC`, `SPC ]`, `{ SPC`, `SPC }`, `^\s*\\` everywhere.
# Refactor the style.
#
#     \[ \| \]\|{ \| }\|^\s*\\
#
# 42 -
#
# Every time you  open a window, be  aware that an error might  be given because
# you're in the command-line window.
# You might want to catch that error to avoid a stack trace.
#
# 43 -
#
# - remove `&l:` when it's not necessary?  (or the opposite: add it everywhere?)
# - switch from 4 spaces to 2 spaces for indentation?
#
# These are complex refactorings, because there will probably be a lot of matches.
# Try to write a custom command, which would refactor a script on-demand.
# Use it from time to time on a plugin you want to improve.
#
# But don't fuck up the alignment of our diagrams.
# So, before using your custom refactoring command, look for all the diagrams:
#
#     [─│]
#
# And manually refactor everything you can around them.
# Then, you  should be able to  use your refactoring command  wherever you want,
# without breaking our diagrams.
#
# 44 -
#
# We often  have errors  when we  import the  contents of  a file  with `:read`,
# because the current buffer is not modifiable.
# Maybe we should always bail out in those cases...
#
# 45 -
#
# Read:
#
# https://gist.github.com/yegappan/3b50ec9ea86ad4511d3a213ee39f1ee0
#    > Updating a quickfix/location list asynchronously without interfering with another plugin
#
# Also, study these plugins:
#
# https://github.com/yegappan/asyncmake (125 sloc)
# https://github.com/foxik/vim-makejob (197)
# https://github.com/prabirshrestha/async.vim (243)
# https://github.com/metakirby5/codi.vim (747)
#
# 46 -
#
# Supercharge `]e` and `[e` to move a fold when the cursor is on a line inside a
# closed fold.  Maybe do the same with `J` and `K` in visual mode.
#
# 47 -
#
# We don't version control our PDFs in `~/Wiki`.  Suppose one of our notes has
# a link to a  local PDF, and we restore our notes on  a new machine; the link
# will be broken.  Improve `gx` so that if it doesn't find a PDF, it looks for
# a `.tex` source code,  compile it into a PDF, and open  it.  Also, make sure
# we do version control the tex source code of all PDFs used in links.
#
# 48 -
#
# Review how we set folding ('foldexpr', 'foldtext') in all our plugins.
# If it makes sense, try to move as much code as possible in `vim-fold`.
#
# 49 -
#
# `[ SPC` and `] SPC`  are not reliable when  we're on a line  inside a closed
# fold.  Maybe  you should  use other keys  to handle folds,  so that  you can
# decide yourself  if you  want Vim  to add an  empty line  or an  empty fold.
# Currently, I  don't think we have  an easy algo  to teach Vim how  to decide
# itself.
#
# 50 -
#
# Watch these videos about using Vim as a diff tool, and as a merge tool:
# https://www.youtube.com/watch?v=zEah_HDpHzc
# https://www.youtube.com/watch?v=VxpCgQyUXlI
#
# 51 -
#
# We have too many comments in this file about the bracketed paste mode.
# Move all of that in a dedicated file (vim notes, terminal notes, ...).
#
# 52 -
#
# In the  past, we have  had too many  issues by trying  to parse the  output of
# `execute('syntax list ...')`.
# Maybe we should ask for  some built-in function (`getsynlist()`?), which would
# give this info in a nice dictionary.
#
# Also, `:verbose syntax list ...` doesn't print the script location from which the
# syntax group was installed.  Maybe ask for an improvement of `:verbose`.
#
# 53 -
#
# *Maybe*, our notes about plugins should be in help files.
# If so, *maybe* they should support folding.
#
# Also, document somewhere, that when you  try to assimilate a plugin, the first
# thing to do is to refactor its documentation.
# Remove  any documentation  about a  feature you find  useless (and  remove the
# associated code).
# Make  the explanations clearer,  and add explanations or  questions/answers if
# needed.
# Once you  fully understand the doc,  and it only contains  useful information,
# you know the plugin's interface.
# And  once  the  interface  has  entered your  muscle  memory,  you  can  start
# refactoring the code.
#
# 54 -
#
# We really need a library function to get a comment leader.
#
#     if &filetype == 'markdown'
#         return ''
#     else
#         var cml: string = &l:commentstring->matchstr('\S*\ze\s*%s')
#         return $'\V{escape(cml, '\')}\m'
#     endif
#
# grep everywhere for `cml`.
#
# Edit: We should probably define functions in our library (lg-lib), to:
#
#    - extract the comment leader
#    - detect whether a given line is commented
#    - return the commented version of a line (before pasting it somewhere)
#
# Edit: I think we should  not look at the comment leader  to detect whether a
# line is commented.  Instead, maybe we should just look at the syntax item at
# the end of the line:
#
#     :echo synID('.', col('$') - 1, true)->synIDattr('name')
#
# Source: https://vi.stackexchange.com/a/18992/17449
#
# This would be more reliable.
# For example, right now, our `myc` visual mapping (yank only lines of code
# in the visual selection) fails to yank a line in a heredoc, if it starts
# with a comment leader.
#
# ---
#
# We  also need  a  library function  to  get  a commented  shell  command in  a
# codeblock (and maybe in a codespan).
#
# It should support continuation lines (see how we did it in vim-tmux for `|x`).
# I don't know how easy it will be  to write, but I think the integration *will*
# be  easy.  A  plugin  invoking this  library function  should  just receive  a
# string, with no newline inside.
# This way, the existing code in our plugins should not need any modification.
#
# Once you have the library function, use it in:
#
#     ~/.vim/pack/mine/opt/doc/autoload/doc/mapping.vim
#     ~/.vim/pack/mine/opt/tmux/autoload/tmux/run.vim:36
#
# Also, we need a library function to install this kind of `q` mapping:
#
#     nnoremap <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<ScriptCmd>quit!<CR>'
#
# 55 -
#
# We often make this error:
#
#     # insert this
#     getline()
#     # press M-b instead of C-b to get inside the parentheses
#
# What could be done to reduce the frequency of such errors?
#
# Idea: Every time you make such a mistake, undo, and re-insert `getline()` 3 times;
# each time make sure to press C-b.
#
# Other Idea: Make `M-b` inspect the 2 previous characters.
# If they are a pair of brackets, make it move the cursor as if `C-b` had been pressed.
#
# 56 -
#
# In a markdown file, `gc` should behave slightly differently.
# It  should  make sure  there  are  4 spaces  between  `>`  and the  first  non
# whitespace on each line; and reformat the quote with `par(1)`.
# Because that's what we do all the time; so better automate it.
#
# 57 -
#
# The  interface of  your plugins  and custom  config should  be simplified  and
# exposed; review every custom mapping/command.
#
# **simplified** = for any mapping/command you never use, do any of these:
#
#    - remove it
#    - change its name to make it easier to remember/find
#    - merge the feature it provides with another mapping/command
#
# **exposed** =  for any feature  provided by  a mapping/command whose  name you
# keep forgetting, do any of these:
#
#    - include it in a shell snippet
#    - include it in a help command (e.g. `g?`, `:MyCmd -help`)
#
#        If the help of a command gets too big, you could spread it across
#        several pages, using a `-help {keyword}` argument.
#
# 58 -
#
# Document a few things about debugging with breakpoints.
#
# Don't think that you enter debugging mode just at the breakpoint; you can stay
# in debugging mode  as long as Vim  has to process commands,  provided that you
# don't run `>cont` or `>quit`; those 2  only stop at the next breakpoint, while
# all the other ones come back to debug mode for some other command.
#
# `>next` and `>step` are similar (but not identical)
# `>interrupt` and `>quit` are similar (but not identical)
#
# `>finish`  lets  Vim  process  all  the  remaining  commands  in  the  current
# script/function;  after that  it makes  Vim come  back to  debug mode  for the
# command B which follows  the command A (A being the  command which had sourced
# the script/run the function in the first place).
# IOW,   `>finish`  is   useful  when   you've  stepped   into  a   long  called
# function/sourced script,  and you don't  want to  inspect it anymore,  but you
# still want to debug the outer function/script.
#
# Use  `>s` only  when necessary  (i.e.  only when  you  need to  step into  a
# function or a sourced file).
#
# Use `>f` as a shortcut to reach the line where the code breaks.
# Use it as many  times as possible; the more commands you have  run so far, the
# harder  it will  be to  reach the  vicinity of  your current  location in  the
# execution path (and you'll need to reach it yet another time because debugging
# is often an iterative process).
# In particular, if your buggy line is  run by a function, called by a function,
# called by a function... it might be  tricky to find in which function you need
# to add a breakpoint.
# Don't  try  to find  the  right  function, just  add  your  breakpoint in  the
# interface function.   From there, inspect  the value of some  expression which
# you know will have – at some point – an unexpected value.
# Run `>f`, and inspect the same expression again; if the value is still the one
# you  expect, run  `>f` again;  if it's  not, you'll  know that  the issue  was
# somewhere in the previous function call.
# Repeat the process until the value is unexpected.
# Note somewhere  how many times  you had to  run `>f` – let's  call it N  – and
# restart a debugging session.
# Next, run `>f` (N-1) times, then run  `>n` as many times as possible until the
# value is unexpected.
# If the value  gets unexpected once you  reach a function call,  you'll need to
# step into it by running `>s`, then immediately run `>n` again.
# If you notice that you've run `>n`  throughout the whole code of a function,
# next time replace all the corresponding `>n` with a single `>f`.
# Build progressively the  shortest sequence of debugging  commands (`>f`, `>n`,
# `>s`) to  reach the buggy  line.  Update the  sequence somewhere in  a scratch
# buffer.
#
# You don't  need to make  a script-local function  temporarily public to  add a
# breakpoint into it.
# Just run `:function *function_name`, then press Tab.
# The `*`  wildcard should be  expanded into something like  `<SNR>123_`; this
# assumes that  the function already  exists, which might  not be the  case if
# it's in  an autoloaded directory  (in which case,  run the interface  of the
# plugin to force the sourcing of the autoloaded directory).
# Now you can run `:breakadd func <SNR>123_function_name`.
#
# 59 -
#
# Vim saves anything typed on the  command-line, regardless of how we've left it
# (including when we've pressed `C-c` or `Esc`).
#
# To prevent this, you could install these mappings:
#
#                   necessary in Vim to not break readline mappings on the command-line
#                   v---v
#     cnoremap <Esc><Esc> <C-E><C-U><C-C>
#     cnoremap <C-C> <C-E><C-U><C-C>
#
# The  reason why  we use  `C-c`  instead of  `Esc`,  is because  on the  search
# command-line, pressing `Esc` would search the pattern:
#
#     cnoremap <Esc> <Esc>
#     'aaa bbb ccc'->setline(1)
#     # press: /bbb
#     # press: Esc
#     # expected: the cursor does not move
#     # actual: the cursor jumps onto `bbb`
#
# 60 -
#
# Look for `:windo` and `:wincmd` everywhere.
#
#     \C\<\%(windo\|wincmd\)\>
#
# Replace these commands with `win_execute()` whenever possible.
#
# 61 -
#
# Review all the custom motions you've installed.
# For each  of them, make  sure you can  jump back with  `C-o` (set mark  `'` on
# original position).
#
# Actually, maybe not for all of them.
# Think about which motions should add an entry in the jumplist.
#
# 62 -
#
# Every time you've used sth like `normal! %` in the past, it was probably wrong.
# You should have used sth like:
#
#     searchpair('(', '', ')', 'W', (): bool =>
#         synID('.', col('.'), true) =~ '\ccomment\|string')
#
# This is what the matchit plugin does, and it's more reliable.
# For example, position your cursor on the first open parenthesis on the following line:
#
#     if match(FUNCTION_NAMES, $'^\V{funcname}\m\%((\|()\)') == -1
#             ^
#
# And run `:normal! %`: the cursor doesn't jump on the closing parenthesis.
# Now run `:call searchpair('(', ...)`: the cursor does jump on the closing parenthesis.
# Wrap this in a `lg#` function, and use it whenever you used `normal[!] %` in the past.
#
# Edidt: Actually, this  is only an issue  when you're dealing with  code, not
# prose.  In code,  you might have an unbalanced closing  brace inside a regex
# for example; it should be ignored,  but `:normal! %` won't ignore it.  Right
# now,  the  only  places  where  that  is  a  real  issue  are  in  `vim-vim`
# (`:RefHeredoc`, `:RefLambda`, `:RefMethod`).
#
# 63 -
#
# Every time we've changed a buffer in a  way that the line count did not change
# (`y` operator, `:yank`, `:write`, `:update`, ...),  make sure we have used the
# `:lockmarks` modifier.
#
# In particular, it is useful to preserve the marks `'[` and `']`.
# This works since 8.1.2302:
# https://github.com/vim/vim/releases/tag/v8.1.2302
#
#     '\[\|'\]
#     ^------^
#     the pattern should look for more things (`:write` command, `:update` command, ...)
#
# ---
#
# Also, whenever we've used `:!`, maybe we should have used the `:keepmarks` modifier...
#
# 64 -
#
# Remove all custom mappings/Ex commands you never use.
# They create noise which makes it harder to assimilate useful mappings/commands.
#
# 65 -
#
# Read:
# https://vimways.org/2019/indentation-without-dents/ (see `~/.vim/indent/[my]matlab.vim`, `~/Desktop/m.m`)
# https://vimways.org/2019/a-test-to-attest-to/
#
# 66 -
#
# Try to replace as many timers as possible:
#
#     timer_start(0, (_) => ...)
#     →
#     autocmd SafeState * ++once ...
#
# Should we though?
#
# I mean, sometimes it helps:
# https://vi.stackexchange.com/a/22414/17449
# *prevents flickering*
#
# and sometimes, it doesn't work and you really need a timer:
# https://github.com/vim/vim/issues/5243#issuecomment-555250613
#
# In general, it seems that `SafeState` executes a command earlier compared to a
# timer (that would explain the behaviors observed in the previous 2 links).
#
# Do we want a delayed command to be executed earlier?
# Naively, I would say yes.  The longer a command is delayed, the longer we stay
# in an undesirable state...
#
# 67 -
#
# We refer to dirvish in several locations in `vim-fex`.
# I don't like that.
# dirvish and fex are two different plugins.
#
# 68 -
#
# Remove all invocations of `setenv()` and `getenv()`.
# Use global variables  instead; don't write them in uppercase  though; we don't
# want them to be saved/restored via viminfo.
#
# Document somewhere how `[gs]etenv()` can be used.
#
# 69 -
#
# Assimilate the `SendToClipboard()` function, and the `~/bin/send-to-clipboard` script.
def SendToClipboard(text: string)
    # What's this `send-to-clipboard` ?{{{
    #
    # A custom script: `~/bin/send-to-clipboard`.
    # It writes the text in:
    #
    #    - a tmux buffer
    #    - the clipboard via `xsel(1x)`
    #    - the clipboard via OSC 52
    #}}}
    silent var seq: string = system('send-to-clipboard', text)
    # Why this guard?{{{
    #
    # In the GUI, OSC 52 doesn't seem to be supported.
    #}}}
    #   Why don't you move it at the top?{{{
    #
    # In  addition  to producing  an  OSC  52 sequence,  `send-to-clipboard`
    # copies the  text in  the clipboard via  `xsel(1x)`; this  last feature
    # might still be useful in the GUI.
    #}}}
    if has('gui_running')
        return
    endif
    if v:shell_error != 0
        echohl ErrorMsg
        echomsg 'could not write the yanked text to the clipboard'
        echohl NONE
        return
    endif
    # TODO: Document why this line is needed.{{{
    #
    # Hint: It's only needed when you're working on a remote machine.
    #
    # If   you're   not   convinced,   comment    the   line,   and   in   the
    # `send-to-clipboard` script, comment the line invoking `xsel(1x)`.  Then,
    # try to use  this function: it will  fail.  It should work  thanks to the
    # OSC 52 sequence, but it doesn't  without this `echoraw()` line.  I think
    # that's  because the  script is  called via  `system()` and  thus has  no
    # controlling terminal; so the sequence is written nowhere.
    #}}}
    echoraw(seq)
enddef
nnoremap <Space>y y<ScriptCmd>SendToClipboard(@0)<CR>
# 70 -
#
# Create a command to cycle between different buffer states.
# E.g.:
#
#    1. press some custom mapping to remember the current state (`:echo undotree().seq_cur`)
#
#    2. edit the buffer
#
#    3. press some custom mapping to get back to the original remembered state;
#       before that, remember the new current state to be able to cycle between the 2 states
#
# This would  be useful when  we bisect the  code in some  file, and we  need to
# temporarily remove a lot of code.
#
# Edit: A command would be better.
#
#     # add current undo seq to a dictionary (key = undo seq, value = description of the buffer state)
#     # save the info in a file
#     :UndoSeq -save 'some description'
#
#     # removes undo seq 123 from the dictionary
#     :UndoSeq -del 123
#
#     # removes the file where the info contained in the dictionary is saved
#     :UndoSeq -del
#
#     # load list of undo seq into location window
#     # pressing Enter on an entry runs `:undo 123` in the associated buffer
#     :UndoSeq
#
# Edit: 'undolevels'  is set to  1000 by default.   It means that  beyond 1000
# changes, old  undo states start  being lost.  It's  easy to reach  the limit
# when refactoring  a script, especially  via a script.  Increasing  the limit
# could have a bad impact on performance.
#
# To avoid losing an old undo state, maybe our custom command should also make a
# backup of the current version of the file...
#
# 71 -
#
# Consider adding `silent!` to unmap all buffer-local mappings from `b:undo_ftplugin`.
# We've lost some time  trying to understand why we sometimes  had an error when
# opening a dirvish buffer.  See:
#
#     ~/.vim/plugin/ultisnips.vim
#
# But we didn't learn  much in the process; not sure  it's worth avoiding `silent!`
# going forward.
#
# ---
#
# Also, in  all other locations,  try to remove  as many `silent!`  as possible.
# Replace them with  `try/catch` if necessary (with an  `echomsg v:exception` in
# the `catch` clause).
#
# `silent!` can shadow the real cause of a bug, and make the debugging more difficult.
# For  example,  once  we had  an  issue  where  a  regular buffer  was  wrongly
# transformed into a qf buffer: https://github.com/vim/vim/issues/7352
#
# 72 - Find a fix for these console-related issues:
#
# https://vi.stackexchange.com/questions/25151/how-to-change-vim-cursor-shape-in-virtual-console
# https://vi.stackexchange.com/questions/25093/how-to-use-16-color-colorscheme-in-tty
#
# This link might also be helpful:
# https://askubuntu.com/a/153493
#
# 73 - Replace all `_save` with `save_`.
#
# Rationale: If you need to save several settings,  it makes sense to do it in a
# `save` dictionary:
#
#     save = {
#         option1: value1,
#         option2: value2,
#         ...
#     }
#
# And when you refer to a value, you write `save.option123`.
# Notice that `save` comes first.
# Let's be consistent: if  we write `save` first here, then let's  do it all the
# time.  Besides, it's nicer to read that way, because that's the order in which
# the words come up in an english sentence:
#
#     save the option
#     ^--^     ^----^
#
# 74 -
#
# Make sure  we've never  written `line('.')`,  `line('$')`, `line("'x")`  (x is
# an  arbitrary  mark), `line('w0')`,  `line('w$')`,  `line('v')`,  when it  was
# unnecessary.
#
# Hint: It's only necessary for a function which can operate on arbitrary buffer
# (e.g. `setbufline()`, `prop_add()`, `screenpos()`, ...).
# For any function which can only operate  on the current buffer, you don't need
# `line()`.
#
# 75 -
#
# Autoload as  many functions as possible  out of the vimrc,  to improve startup
# time.
#
# 76 -
#
# Consider doing this kind of refactorings:
#
#     var tmp_file: string = tempname()
#
#     →
#
#     if tmp_file != ''
#         silent! delete(tmp_file)
#         tmp_file = ''
#     endif
#     var tmp_file: string = tempname()
#
# The purpose would be  to prevent Vim from piling up  temporary files for the
# same feature.  This is what junegunn does in `fzf#vim#helptags()`.
# Although, I didn't find this kind of precautions anywhere else...
#
# Edit: What about the `D` flag of `writefile()`?
# Could it be used instead?
#
# 77 -
#
# Install a mapping to toggle `'breakindent'` and `'linebreak'`?
#
# It  would help  when the  buffer contains  huge wrapped  lines, and  our vimrc
# autocmd has not been able to reset the options.
#
# ---
#
# Also, add an indicator in the status line when the options are reset?
#
# 78 -
#
# Should we have used the autocmd pattern `?*` instead of `*` in some autocmds?
# It could simplify some of them  (or maybe slightly improve their performance);
# because, then, there's no need to write sth like this:
#
#     if bufname('%') == ''
#         return
#     endif
#
# 79 -
#
# Check whether we should have sometimes  saved and restored `"0` in addition to
# `""`. Look for `setreg(` everywhere.
#
# The issue is a  bit complex because we've forgotten a  lot about how registers
# work.  Explain the issue to yourself in great detail.
#
# To help you, here is a start:
#
#     # write this in /tmp/t.vim
#     vim9script
#     &showcmd = true
#
#     nnoremap <expr> <C-B> MyOp()
#
#     def MyOp(type = ''): string
#         if type == ''
#             &operatorfunc = MyOp
#             return 'g@'
#         endif
#         var unnamed: dict<any> = getreginfo('"')
#         var zero: dict<any> = getreginfo('0')
#         normal! `[v`]y
#         echomsg strlen(@")
#         setreg('"', unnamed)
#         setreg('0', zero)
#         return ''
#     enddef
#
#     setreg('0', {regcontents: 'zero'})
#     setreg('a', {regcontents: 'aaa'})
#     setreg('"', {regcontents: 'zzz', points_to: 'z'})
#     setreg('*', {})
#     setreg('+', {})
#     repeat(['the quick brown fox jumps over the lazy dog'], 5)->setline(1)
#
#     # then, start Vim like this
#     $ vim -Nu NONE -i NONE -S /tmp/t.vim
#
# Did we say something wrong here?
# https://vi.stackexchange.com/questions/28354/reliably-saving-and-restoring-registers-across-a-function-call/28356#28356
#
# ---
#
# BTW, when we use `v_p`, what happens exactly regarding the registers?
# I think that:
#
#    - the selected text is written in `"-` or a numbered register (depending on whether it's big or not)
#    - if it's written into a numbered register, Vim perform a rotation on the stack of numbered registers
#    - the unnamed register is reconnected to `"-` or a numbered register
#
# ---
#
# In general, should we restore `"0` before or after `""`?
# Does  the answer  to  that  question depend  on  what  `""` points  to
# (especially `"0`)?
#
# ---
#
# Did we make some mistake when restoring `"0` in the past?
# Like maybe we should have restored it before or after `""`, or with a timer...
#
# ---
#
# In  our library  function  `Opfunc()`,  should we  save/restore  `"-` and  the
# numbered registers too?
#
# 80 -
#
# Look for `map()` and `mapnew()` everywhere.
#
# Whenever you've used  them as a “clever” replacement for  a `:for` loop,
# remove them;  use a `:for` loop.   Don't be “clever”; it  makes the code
# less readable. `map()`  and `mapnew()` are meant to make  a list/dict mutate
# or output  a new  one.  If you  don't care about  their output,  then you're
# abusing them for a different purpose.  Don't.
#
# Edit: Instead of `:for`, try `foreach()`.
#
# 81 -
#
# Review all `function()` occurrences in our code.
# When it's assigned, is the type always correct?
# When it's used at runtime, are there any errors?
#
# Edit: If you use `function()`, it's for a partial, right?
# I think that for a partial, there is no type checking.
# At least in compiled code.
#
# 82 -
#
# `<M-U>` (uppercase word) doesn't always work in normal mode.
# The issue comes from this function:
#
#     # ~/.vim/pack/mine/opt/window/autoload/window/popup.vim
#     ScrollTmuxPreviousPane()
#
# In particular from this tmux command:
#
#     var tmux_cmd: string =
#          'tmux display -p -t "{last}" "#{pane_current_command}"'
#         .. '\; display -p             "#{window_zoomed_flag}"'
#
# I think `{last}` can refer to a pane in a different window.
# And/or maybe to a different window.
# At the very least, we should not run  any tmux command if there is only 1 pane
# in  the current  tmux window.   Not  sure it's  enough  to fix  all the  cases
# though...
#
# 83 -
#
# `synIDattr()` is not reliable if you want to know which attribute is currently
# used for a given syntax/highlight group.
# That's because  the function considers that  `gui=` is relevant in  a terminal
# where `'termguicolors'` is set.  It's not.  `cterm=` *is* relevant.
# To be reliable, you need to pass to the function the optional argument `{mode}`:
#
#     synIDattr({synID}, {what}, has('gui_running') ? 'gui' : 'cterm')
#                                ^----------------------------------^
#                                is that correct?
#                                what about 'term'?
#
# https://github.com/vim/vim/issues/1740#issuecomment-687583106
#
# Bug to report?
# Should we fix some code here and there?
#
# 84 -
#
# Finish refactoring our colorscheme.
# Make it simpler.
# Make it work in the TTY console.
# Make it more consistent with default color schemes.
#
# 85 -
#
# In a tmux file:
#
#     '#{||:#{m:*vim,#{pane_current_command}},#{==:#{pane_current_command},man}}' ls
#                                                                         ^----^
#
# Some parts of this code are wrongly highlighted as a string.
# The issue disappears if we remove `keepend` from `tmuxFmtInpol`.
# Is that correct?
# Should we?
# I thought we should always use `keepend` for a region...
#
# 86 -
#
# `'virtualedit'` is global-local since 8.2.3227.
# And it's local to the window since 8.2.3280.
# Review all occurrences of `virtualedit`.
# Check whether we should sometimes read/write the local value.
#
# 87 -
#
# Why do  we need  the `&` shell  control operator  in the GUI,  but not  in the
# terminal, when  we want to  open a web link  with `xdg-open(1)` with  `:!`? Is
# there a bug in Vim?  Is it because we forgot to set some option?
#
# 88 -
#
# Look for `system()` everywhere.
# Consider replacing it with `job_start()` whenever possible.
#
# Rationale: Too many weird issues with `system()`.
#
# For example, in the GUI, if the  `!` flag is in `'guioptions'`, we cannot open
# a web  link neither  with `:!` nor  with `system()`; even  with the  `&` shell
# control operator.
#
# Also, still in  the GUI, if `'shell'`  is set to use zsh  and `'shelltemp'` is
# `on` (it is by default), we cannot  open a web link with `system()`; even with
# the `&` shell control operator (resetting the zsh option `HUP` might help; not
# sure...).
#
# I think all these  issues stem from the fact that we start  a shell.  But most
# of the time,  we don't need a shell;  so, it makes sense to  bypass the latter
# completely using `job_start()`.
#
# 89 -
#
# We can't open a web link if:
#
#    - we are in the GUI
#    - `'shell'` is `zsh`
#    - `'shelltemp'` is `on`
#    - we use `:!`
#    - the zsh option `HUP` is set
#
# Context:
#
# https://github.com/vim/vim/issues/4738#issuecomment-851695491
# https://github.com/vim/vim/releases/tag/v8.2.2919
# https://github.com/vim/vim/issues/8951#issuecomment-934442496
# https://github.com/vim/vim/releases/tag/v8.2.3502
#
# But  it  might   be  that  `system()`  (+  `&`  shell   control  operator)  or
# `job_start()` are “acceptable” solutions.
# They are if there is no situation where we *must* use `:!` and where the issue
# can be reproduced  at the same time.   Is there?  To answer  this question, we
# need to  better understand the  issue.  In particular,  why is there  an issue
# with `:!xdg-open`, but not with `:!ls`?
#
# If `system()` and `job_start()` are acceptable solutions, leave a comment here:
# https://github.com/vim/vim/issues/8951
# Give all your findings.  The issue might be closed.
#
# ---
#
# What's the influence of `'guipty'` on this kind of issue?
#
# 90 -
#
# Look for this pattern in all our config:
#
#     \%(xnoremap\|xmap\)\s\+.*<C-\\><C-N>
#
# Check whether we call a function right after.
# If we do, check whether it correctly handles the visual mode.
# That  is, if  it calls  `mode()` to  inspect the  current mode,  it's probably
# broken, because we're probably always in normal mode.
# If it  *is* broken, consider  not quitting visual  mode from the  mapping, but
# from the function via `:normal`.
#
# 91 -
#
# A `<Plug>` keycode is remapped even in a *non*-recursive mapping since 8.2.4498.
# Could we use this to refactor some of our mappings?
# For example, should we rewrite this:
#
#     nmap g; <Plug>(next-change)
#
# Into this:
#
#     nnoremap g; <Plug>(next-change)
#
# 92 - Replace `:quit` with `:close` whenever you can.
# Rationale: `:quit` can make Vim quit unexpectedly.
#
# 93  -  Implement  a  `-I` (**I**nterface)  mapping  showing  the  available
# abbreviations, commands, autocmds, mappings, options in the quickfix window.
#
# For inspiration, look at how we implemented our `-F` mapping, and look at this:
# https://github.com/vim/vim/issues/6373#issuecomment-652664179
#
# Try to support all Ex commands which include a `Last  set from` message when
# the verbosity level is increased.
#
# 94 - Sometimes, we get this command in our `:` commands history:
#
#     call textobj#sandwich#select()
#
# I think it comes from this script:
#
#     ~/.vim/pack/vendor/opt/vim-sandwich/autoload/textobj/sandwich.vim
#
# Find a way to prevent that.





# fast lookup:
#     cheatkeys
#     config files (options)
#     resources
#     shell abbreviations
#     snippets Vim
#     snippets shell
#     README
#
# passive exposition:
#     code (scripts, plugins, ...)
#     linter or custom syntax highlighting for pitfalls
#
# no exposition:
#     Wiki
